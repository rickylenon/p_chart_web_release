"use strict";(()=>{var e={};e.id=3471,e.ids=[3471],e.modules={53524:e=>{e.exports=require("@prisma/client")},63844:e=>{e.exports=require("adm-zip")},98432:e=>{e.exports=require("bcryptjs")},73227:e=>{e.exports=require("next-auth")},60614:e=>{e.exports=require("next-auth/jwt")},62113:e=>{e.exports=require("next-auth/next")},47449:e=>{e.exports=require("next-auth/providers/credentials")},41649:e=>{e.exports=require("next-auth/react")},20145:e=>{e.exports=require("next/dist/compiled/next-server/pages-api.runtime.prod.js")},32081:e=>{e.exports=require("child_process")},57147:e=>{e.exports=require("fs")},71017:e=>{e.exports=require("path")},82897:(e,t,r)=>{r.r(t),r.d(t,{config:()=>d,default:()=>u,routeModule:()=>h});var i={};r.r(i),r.d(i,{default:()=>p});var n=r(71802),s=r(47153),o=r(56249),a=r(73227),c=r(66826),l=r(7815);async function p(e,t){let r=await (0,a.getServerSession)(e,t,c.Lz);if(r?.user?.role!=="ADMIN")return t.status(401).json({error:"Unauthorized"});if("GET"!==e.method)return t.status(405).json({error:"Method not allowed"});try{let e=new l.y,r=await e.checkGitConfiguration();return t.status(200).json({success:!0,gitConfig:r})}catch(e){return console.error("Error checking git configuration:",e),t.status(500).json({error:"Failed to check git configuration",details:e instanceof Error?e.message:String(e)})}}let u=(0,o.l)(i,"default"),d=(0,o.l)(i,"config"),h=new n.PagesAPIRouteModule({definition:{kind:s.x.PAGES_API,page:"/api/admin/system-update/git-config",pathname:"/api/admin/system-update/git-config",bundlePath:"",filename:""},userland:i})},7815:(e,t,r)=>{r.d(t,{Z:()=>u,y:()=>p});var i=r(57147),n=r.n(i),s=r(71017),o=r.n(s),a=r(63844),c=r.n(a),l=r(32081);class p{constructor(){this.productionPath=process.cwd(),this.tempPath=o().join(this.productionPath,"temp","system-updates"),this.backupPath=o().join(this.productionPath,"backup")}async getUpdateInfo(e){try{let t=o().join(this.tempPath,`${e}.json`);if(!n().existsSync(t))return null;return JSON.parse(n().readFileSync(t,"utf8"))}catch(e){return console.error("Failed to get update info:",e),null}}async createBackup(e){let t=o().join(this.backupPath,`backup_${e}_${Date.now()}`);for(let e of(n().existsSync(this.backupPath)||n().mkdirSync(this.backupPath,{recursive:!0}),n().mkdirSync(t,{recursive:!0}),["server.js","package.json",".next","public"])){let r=o().join(this.productionPath,e),i=o().join(t,e);n().existsSync(r)&&(n().statSync(r).isDirectory()?await this.copyDirectory(r,i):n().copyFileSync(r,i))}console.log(`Backup created at: ${t}`)}async copyDirectory(e,t){for(let r of(n().existsSync(t)||n().mkdirSync(t,{recursive:!0}),n().readdirSync(e,{withFileTypes:!0}))){let i=o().join(e,r.name),s=o().join(t,r.name);r.isDirectory()?await this.copyDirectory(i,s):n().copyFileSync(i,s)}}async stopApplication(){return new Promise(e=>{let t=o().join(this.productionPath,"stop.bat");if(!n().existsSync(t)){console.log("stop.bat not found, assuming application is stopped"),e(!0);return}let r=(0,l.spawn)("cmd.exe",["/c",t],{cwd:this.productionPath,stdio:"inherit"});r.on("close",t=>{console.log(`Stop script exited with code: ${t}`),e(0===t)}),r.on("error",t=>{console.error("Error stopping application:",t),e(!1)}),setTimeout(()=>{r.kill(),e(!1)},3e4)})}async startApplication(){return new Promise(e=>{let t=o().join(this.productionPath,"start.bat");if(!n().existsSync(t)){console.log("start.bat not found, cannot start application"),e(!1);return}let r=(0,l.spawn)("cmd.exe",["/c",t],{cwd:this.productionPath,stdio:"inherit",detached:!0});r.on("close",t=>{console.log(`Start script exited with code: ${t}`),e(0===t)}),r.on("error",t=>{console.error("Error starting application:",t),e(!1)}),setTimeout(()=>{e(!0)},1e4)})}async extractAndApplyUpdate(e){let t=new(c())(e),r=o().join(this.tempPath,"staging");for(let e of(n().existsSync(r)&&n().rmSync(r,{recursive:!0,force:!0}),n().mkdirSync(r,{recursive:!0}),t.extractAllTo(r,!0),[{source:"server.js",dest:"server.js"},{source:"package.json",dest:"package.json"},{source:".next",dest:".next"},{source:"public",dest:"public"}])){let t=o().join(r,e.source),i=o().join(this.productionPath,e.dest);n().existsSync(t)&&(n().existsSync(i)&&n().rmSync(i,{recursive:!0,force:!0}),n().statSync(t).isDirectory()?await this.copyDirectory(t,i):n().copyFileSync(t,i),console.log(`Updated: ${e.dest}`))}n().rmSync(r,{recursive:!0,force:!0})}async applyUpdate(e){let t=o().join(this.tempPath,"MANUAL_UPDATE_ACTIVE"),r=o().join(this.tempPath,"MANUAL_UPDATE_APPLIED");try{console.log(`Applying system update: ${e}`),n().writeFileSync(t,new Date().toISOString());let i=await this.getUpdateInfo(e);if(!i)return n().existsSync(t)&&n().unlinkSync(t),{success:!1,message:"Update not found"};if(i.applied)return n().existsSync(t)&&n().unlinkSync(t),{success:!1,message:"Update already applied"};console.log("Creating backup..."),await this.createBackup(e),console.log("Launching external update process...");let s=o().join(this.productionPath,"apply-update.bat");if(!n().existsSync(s))return{success:!1,message:"Update script not found: apply-update.bat",needsManualRestart:!0};let a=(0,l.spawn)("cmd.exe",["/c",s,e,this.tempPath,this.productionPath],{cwd:this.productionPath,stdio:"ignore",detached:!0});a.unref(),console.log(`External update process started (PID: ${a.pid})`),i.applied=!0;let c=o().join(this.tempPath,`${e}.json`);return n().writeFileSync(c,JSON.stringify(i,null,2)),n().writeFileSync(r,new Date().toISOString()),n().existsSync(t)&&n().unlinkSync(t),console.log("Stopping application..."),setTimeout(()=>{this.stopApplication()},1e3),{success:!0,message:`Update to version ${i.version} will be applied. The application will restart automatically.`,details:{version:i.version,updateId:e,externalProcess:!0}}}catch(e){return console.error("Error applying update:",e),n().existsSync(t)&&n().unlinkSync(t),{success:!1,message:"Update failed",details:{error:e instanceof Error?e.message:String(e)}}}}async checkGitConfiguration(){try{let e=r(57147),{execSync:t}=r(32081),i=o().join(this.productionPath,".git");if(!e.existsSync(i))return{isGitRepo:!1,hasRemote:!1,currentBranch:null,remoteUrl:null,hasCredentials:!1,canPush:!1,error:"Not a git repository"};let n=null,s=null,a=!1,c=!1;try{n=t("git rev-parse --abbrev-ref HEAD",{cwd:this.productionPath,encoding:"utf8"}).trim(),s=t("git config --get remote.origin.url",{cwd:this.productionPath,encoding:"utf8"}).trim(),a=!0,t("git push --dry-run origin HEAD",{cwd:this.productionPath,encoding:"utf8"}),c=!0}catch(e){e instanceof Error&&e.message.includes("push")&&(c=!1)}return{isGitRepo:!0,hasRemote:a,currentBranch:n,remoteUrl:s,hasCredentials:c,canPush:c}}catch(e){return{isGitRepo:!1,hasRemote:!1,currentBranch:null,remoteUrl:null,hasCredentials:!1,canPush:!1,error:e instanceof Error?e.message:String(e)}}}async getAvailableUpdates(){try{if(!n().existsSync(this.tempPath))return[];let e=n().readdirSync(this.tempPath).filter(e=>e.endsWith(".json")),t=[];for(let r of e)try{let e=JSON.parse(n().readFileSync(o().join(this.tempPath,r),"utf8"));t.push(e)}catch(e){console.warn(`Failed to parse update info file: ${r}`,e)}return t.sort((e,t)=>new Date(t.uploadedAt).getTime()-new Date(e.uploadedAt).getTime())}catch(e){return console.error("Error getting available updates:",e),[]}}async cleanup(){try{let e=await this.getAvailableUpdates(),t=new Date(Date.now()-2592e6);for(let r of e)if(new Date(r.uploadedAt)<t){let e=o().join(this.tempPath,`${r.id}.zip`),t=o().join(this.tempPath,`${r.id}.json`);n().existsSync(e)&&n().unlinkSync(e),n().existsSync(t)&&n().unlinkSync(t),console.log(`Cleaned up old update: ${r.id}`)}if(n().existsSync(this.backupPath)){let e=n().readdirSync(this.backupPath),t=new Date(Date.now()-6048e5);for(let r of e){let e=o().join(this.backupPath,r);n().statSync(e).mtime<t&&(n().rmSync(e,{recursive:!0,force:!0}),console.log(`Cleaned up old backup: ${r}`))}}}catch(e){console.error("Error during cleanup:",e)}}}let u=p}};var t=require("../../../../webpack-api-runtime.js");t.C(e);var r=e=>t(t.s=e),i=t.X(0,[549],()=>r(82897));module.exports=i})();