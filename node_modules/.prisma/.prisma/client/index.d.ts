
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ProductionOrder
 * 
 */
export type ProductionOrder = $Result.DefaultSelection<Prisma.$ProductionOrderPayload>
/**
 * Model Operation
 * 
 */
export type Operation = $Result.DefaultSelection<Prisma.$OperationPayload>
/**
 * Model MasterDefect
 * 
 */
export type MasterDefect = $Result.DefaultSelection<Prisma.$MasterDefectPayload>
/**
 * Model StandardCost
 * 
 */
export type StandardCost = $Result.DefaultSelection<Prisma.$StandardCostPayload>
/**
 * Model OperationDefect
 * 
 */
export type OperationDefect = $Result.DefaultSelection<Prisma.$OperationDefectPayload>
/**
 * Model OperationDefectEditRequest
 * 
 */
export type OperationDefectEditRequest = $Result.DefaultSelection<Prisma.$OperationDefectEditRequestPayload>
/**
 * Model OperationStep
 * 
 */
export type OperationStep = $Result.DefaultSelection<Prisma.$OperationStepPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model OperationLine
 * 
 */
export type OperationLine = $Result.DefaultSelection<Prisma.$OperationLinePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.productionOrder`: Exposes CRUD operations for the **ProductionOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionOrders
    * const productionOrders = await prisma.productionOrder.findMany()
    * ```
    */
  get productionOrder(): Prisma.ProductionOrderDelegate<ExtArgs>;

  /**
   * `prisma.operation`: Exposes CRUD operations for the **Operation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operations
    * const operations = await prisma.operation.findMany()
    * ```
    */
  get operation(): Prisma.OperationDelegate<ExtArgs>;

  /**
   * `prisma.masterDefect`: Exposes CRUD operations for the **MasterDefect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterDefects
    * const masterDefects = await prisma.masterDefect.findMany()
    * ```
    */
  get masterDefect(): Prisma.MasterDefectDelegate<ExtArgs>;

  /**
   * `prisma.standardCost`: Exposes CRUD operations for the **StandardCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StandardCosts
    * const standardCosts = await prisma.standardCost.findMany()
    * ```
    */
  get standardCost(): Prisma.StandardCostDelegate<ExtArgs>;

  /**
   * `prisma.operationDefect`: Exposes CRUD operations for the **OperationDefect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationDefects
    * const operationDefects = await prisma.operationDefect.findMany()
    * ```
    */
  get operationDefect(): Prisma.OperationDefectDelegate<ExtArgs>;

  /**
   * `prisma.operationDefectEditRequest`: Exposes CRUD operations for the **OperationDefectEditRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationDefectEditRequests
    * const operationDefectEditRequests = await prisma.operationDefectEditRequest.findMany()
    * ```
    */
  get operationDefectEditRequest(): Prisma.OperationDefectEditRequestDelegate<ExtArgs>;

  /**
   * `prisma.operationStep`: Exposes CRUD operations for the **OperationStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationSteps
    * const operationSteps = await prisma.operationStep.findMany()
    * ```
    */
  get operationStep(): Prisma.OperationStepDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.operationLine`: Exposes CRUD operations for the **OperationLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationLines
    * const operationLines = await prisma.operationLine.findMany()
    * ```
    */
  get operationLine(): Prisma.OperationLineDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ProductionOrder: 'ProductionOrder',
    Operation: 'Operation',
    MasterDefect: 'MasterDefect',
    StandardCost: 'StandardCost',
    OperationDefect: 'OperationDefect',
    OperationDefectEditRequest: 'OperationDefectEditRequest',
    OperationStep: 'OperationStep',
    AuditLog: 'AuditLog',
    Session: 'Session',
    Notification: 'Notification',
    OperationLine: 'OperationLine'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "productionOrder" | "operation" | "masterDefect" | "standardCost" | "operationDefect" | "operationDefectEditRequest" | "operationStep" | "auditLog" | "session" | "notification" | "operationLine"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ProductionOrder: {
        payload: Prisma.$ProductionOrderPayload<ExtArgs>
        fields: Prisma.ProductionOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          findFirst: {
            args: Prisma.ProductionOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          findMany: {
            args: Prisma.ProductionOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>[]
          }
          create: {
            args: Prisma.ProductionOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          createMany: {
            args: Prisma.ProductionOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductionOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          update: {
            args: Prisma.ProductionOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          deleteMany: {
            args: Prisma.ProductionOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductionOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          aggregate: {
            args: Prisma.ProductionOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionOrder>
          }
          groupBy: {
            args: Prisma.ProductionOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionOrderCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionOrderCountAggregateOutputType> | number
          }
        }
      }
      Operation: {
        payload: Prisma.$OperationPayload<ExtArgs>
        fields: Prisma.OperationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          findFirst: {
            args: Prisma.OperationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          findMany: {
            args: Prisma.OperationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>[]
          }
          create: {
            args: Prisma.OperationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          createMany: {
            args: Prisma.OperationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OperationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          update: {
            args: Prisma.OperationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          deleteMany: {
            args: Prisma.OperationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationPayload>
          }
          aggregate: {
            args: Prisma.OperationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperation>
          }
          groupBy: {
            args: Prisma.OperationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationCountArgs<ExtArgs>
            result: $Utils.Optional<OperationCountAggregateOutputType> | number
          }
        }
      }
      MasterDefect: {
        payload: Prisma.$MasterDefectPayload<ExtArgs>
        fields: Prisma.MasterDefectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterDefectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterDefectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterDefectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterDefectPayload>
          }
          findFirst: {
            args: Prisma.MasterDefectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterDefectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterDefectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterDefectPayload>
          }
          findMany: {
            args: Prisma.MasterDefectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterDefectPayload>[]
          }
          create: {
            args: Prisma.MasterDefectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterDefectPayload>
          }
          createMany: {
            args: Prisma.MasterDefectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MasterDefectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterDefectPayload>
          }
          update: {
            args: Prisma.MasterDefectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterDefectPayload>
          }
          deleteMany: {
            args: Prisma.MasterDefectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MasterDefectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MasterDefectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterDefectPayload>
          }
          aggregate: {
            args: Prisma.MasterDefectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMasterDefect>
          }
          groupBy: {
            args: Prisma.MasterDefectGroupByArgs<ExtArgs>
            result: $Utils.Optional<MasterDefectGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterDefectCountArgs<ExtArgs>
            result: $Utils.Optional<MasterDefectCountAggregateOutputType> | number
          }
        }
      }
      StandardCost: {
        payload: Prisma.$StandardCostPayload<ExtArgs>
        fields: Prisma.StandardCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandardCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandardCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCostPayload>
          }
          findFirst: {
            args: Prisma.StandardCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandardCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCostPayload>
          }
          findMany: {
            args: Prisma.StandardCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCostPayload>[]
          }
          create: {
            args: Prisma.StandardCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCostPayload>
          }
          createMany: {
            args: Prisma.StandardCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StandardCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCostPayload>
          }
          update: {
            args: Prisma.StandardCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCostPayload>
          }
          deleteMany: {
            args: Prisma.StandardCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandardCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StandardCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCostPayload>
          }
          aggregate: {
            args: Prisma.StandardCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandardCost>
          }
          groupBy: {
            args: Prisma.StandardCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandardCostCountArgs<ExtArgs>
            result: $Utils.Optional<StandardCostCountAggregateOutputType> | number
          }
        }
      }
      OperationDefect: {
        payload: Prisma.$OperationDefectPayload<ExtArgs>
        fields: Prisma.OperationDefectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationDefectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationDefectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectPayload>
          }
          findFirst: {
            args: Prisma.OperationDefectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationDefectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectPayload>
          }
          findMany: {
            args: Prisma.OperationDefectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectPayload>[]
          }
          create: {
            args: Prisma.OperationDefectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectPayload>
          }
          createMany: {
            args: Prisma.OperationDefectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OperationDefectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectPayload>
          }
          update: {
            args: Prisma.OperationDefectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectPayload>
          }
          deleteMany: {
            args: Prisma.OperationDefectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationDefectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperationDefectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectPayload>
          }
          aggregate: {
            args: Prisma.OperationDefectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperationDefect>
          }
          groupBy: {
            args: Prisma.OperationDefectGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationDefectGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationDefectCountArgs<ExtArgs>
            result: $Utils.Optional<OperationDefectCountAggregateOutputType> | number
          }
        }
      }
      OperationDefectEditRequest: {
        payload: Prisma.$OperationDefectEditRequestPayload<ExtArgs>
        fields: Prisma.OperationDefectEditRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationDefectEditRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectEditRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationDefectEditRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectEditRequestPayload>
          }
          findFirst: {
            args: Prisma.OperationDefectEditRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectEditRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationDefectEditRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectEditRequestPayload>
          }
          findMany: {
            args: Prisma.OperationDefectEditRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectEditRequestPayload>[]
          }
          create: {
            args: Prisma.OperationDefectEditRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectEditRequestPayload>
          }
          createMany: {
            args: Prisma.OperationDefectEditRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OperationDefectEditRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectEditRequestPayload>
          }
          update: {
            args: Prisma.OperationDefectEditRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectEditRequestPayload>
          }
          deleteMany: {
            args: Prisma.OperationDefectEditRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationDefectEditRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperationDefectEditRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationDefectEditRequestPayload>
          }
          aggregate: {
            args: Prisma.OperationDefectEditRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperationDefectEditRequest>
          }
          groupBy: {
            args: Prisma.OperationDefectEditRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationDefectEditRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationDefectEditRequestCountArgs<ExtArgs>
            result: $Utils.Optional<OperationDefectEditRequestCountAggregateOutputType> | number
          }
        }
      }
      OperationStep: {
        payload: Prisma.$OperationStepPayload<ExtArgs>
        fields: Prisma.OperationStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationStepPayload>
          }
          findFirst: {
            args: Prisma.OperationStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationStepPayload>
          }
          findMany: {
            args: Prisma.OperationStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationStepPayload>[]
          }
          create: {
            args: Prisma.OperationStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationStepPayload>
          }
          createMany: {
            args: Prisma.OperationStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OperationStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationStepPayload>
          }
          update: {
            args: Prisma.OperationStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationStepPayload>
          }
          deleteMany: {
            args: Prisma.OperationStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperationStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationStepPayload>
          }
          aggregate: {
            args: Prisma.OperationStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperationStep>
          }
          groupBy: {
            args: Prisma.OperationStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationStepCountArgs<ExtArgs>
            result: $Utils.Optional<OperationStepCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      OperationLine: {
        payload: Prisma.$OperationLinePayload<ExtArgs>
        fields: Prisma.OperationLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLinePayload>
          }
          findFirst: {
            args: Prisma.OperationLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLinePayload>
          }
          findMany: {
            args: Prisma.OperationLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLinePayload>[]
          }
          create: {
            args: Prisma.OperationLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLinePayload>
          }
          createMany: {
            args: Prisma.OperationLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OperationLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLinePayload>
          }
          update: {
            args: Prisma.OperationLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLinePayload>
          }
          deleteMany: {
            args: Prisma.OperationLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperationLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLinePayload>
          }
          aggregate: {
            args: Prisma.OperationLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperationLine>
          }
          groupBy: {
            args: Prisma.OperationLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationLineCountArgs<ExtArgs>
            result: $Utils.Optional<OperationLineCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    auditLogs: number
    deactivatedDefects: number
    requestedEditRequests: number
    resolvedEditRequests: number
    recordedDefects: number
    encodedOperations: number
    operations: number
    sessions: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    deactivatedDefects?: boolean | UserCountOutputTypeCountDeactivatedDefectsArgs
    requestedEditRequests?: boolean | UserCountOutputTypeCountRequestedEditRequestsArgs
    resolvedEditRequests?: boolean | UserCountOutputTypeCountResolvedEditRequestsArgs
    recordedDefects?: boolean | UserCountOutputTypeCountRecordedDefectsArgs
    encodedOperations?: boolean | UserCountOutputTypeCountEncodedOperationsArgs
    operations?: boolean | UserCountOutputTypeCountOperationsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeactivatedDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterDefectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequestedEditRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationDefectEditRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResolvedEditRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationDefectEditRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecordedDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationDefectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEncodedOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ProductionOrderCountOutputType
   */

  export type ProductionOrderCountOutputType = {
    editRequests: number
    operations: number
  }

  export type ProductionOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    editRequests?: boolean | ProductionOrderCountOutputTypeCountEditRequestsArgs
    operations?: boolean | ProductionOrderCountOutputTypeCountOperationsArgs
  }

  // Custom InputTypes
  /**
   * ProductionOrderCountOutputType without action
   */
  export type ProductionOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrderCountOutputType
     */
    select?: ProductionOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionOrderCountOutputType without action
   */
  export type ProductionOrderCountOutputTypeCountEditRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationDefectEditRequestWhereInput
  }

  /**
   * ProductionOrderCountOutputType without action
   */
  export type ProductionOrderCountOutputTypeCountOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationWhereInput
  }


  /**
   * Count Type OperationCountOutputType
   */

  export type OperationCountOutputType = {
    editRequests: number
    operationDefects: number
  }

  export type OperationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    editRequests?: boolean | OperationCountOutputTypeCountEditRequestsArgs
    operationDefects?: boolean | OperationCountOutputTypeCountOperationDefectsArgs
  }

  // Custom InputTypes
  /**
   * OperationCountOutputType without action
   */
  export type OperationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationCountOutputType
     */
    select?: OperationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OperationCountOutputType without action
   */
  export type OperationCountOutputTypeCountEditRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationDefectEditRequestWhereInput
  }

  /**
   * OperationCountOutputType without action
   */
  export type OperationCountOutputTypeCountOperationDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationDefectWhereInput
  }


  /**
   * Count Type MasterDefectCountOutputType
   */

  export type MasterDefectCountOutputType = {
    operationDefects: number
  }

  export type MasterDefectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operationDefects?: boolean | MasterDefectCountOutputTypeCountOperationDefectsArgs
  }

  // Custom InputTypes
  /**
   * MasterDefectCountOutputType without action
   */
  export type MasterDefectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefectCountOutputType
     */
    select?: MasterDefectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MasterDefectCountOutputType without action
   */
  export type MasterDefectCountOutputTypeCountOperationDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationDefectWhereInput
  }


  /**
   * Count Type OperationDefectCountOutputType
   */

  export type OperationDefectCountOutputType = {
    editRequests: number
  }

  export type OperationDefectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    editRequests?: boolean | OperationDefectCountOutputTypeCountEditRequestsArgs
  }

  // Custom InputTypes
  /**
   * OperationDefectCountOutputType without action
   */
  export type OperationDefectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectCountOutputType
     */
    select?: OperationDefectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OperationDefectCountOutputType without action
   */
  export type OperationDefectCountOutputTypeCountEditRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationDefectEditRequestWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    name: string | null
    email: string | null
    role: string | null
    isActive: boolean | null
    createdAt: Date | null
    lastLogin: Date | null
    department: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    name: string | null
    email: string | null
    role: string | null
    isActive: boolean | null
    createdAt: Date | null
    lastLogin: Date | null
    department: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    name: number
    email: number
    role: number
    isActive: number
    createdAt: number
    lastLogin: number
    department: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    email?: true
    role?: true
    isActive?: true
    createdAt?: true
    lastLogin?: true
    department?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    email?: true
    role?: true
    isActive?: true
    createdAt?: true
    lastLogin?: true
    department?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    email?: true
    role?: true
    isActive?: true
    createdAt?: true
    lastLogin?: true
    department?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    name: string | null
    email: string | null
    role: string
    isActive: boolean
    createdAt: Date
    lastLogin: Date | null
    department: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    lastLogin?: boolean
    department?: boolean
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    deactivatedDefects?: boolean | User$deactivatedDefectsArgs<ExtArgs>
    requestedEditRequests?: boolean | User$requestedEditRequestsArgs<ExtArgs>
    resolvedEditRequests?: boolean | User$resolvedEditRequestsArgs<ExtArgs>
    recordedDefects?: boolean | User$recordedDefectsArgs<ExtArgs>
    encodedOperations?: boolean | User$encodedOperationsArgs<ExtArgs>
    operations?: boolean | User$operationsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    lastLogin?: boolean
    department?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    deactivatedDefects?: boolean | User$deactivatedDefectsArgs<ExtArgs>
    requestedEditRequests?: boolean | User$requestedEditRequestsArgs<ExtArgs>
    resolvedEditRequests?: boolean | User$resolvedEditRequestsArgs<ExtArgs>
    recordedDefects?: boolean | User$recordedDefectsArgs<ExtArgs>
    encodedOperations?: boolean | User$encodedOperationsArgs<ExtArgs>
    operations?: boolean | User$operationsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      deactivatedDefects: Prisma.$MasterDefectPayload<ExtArgs>[]
      requestedEditRequests: Prisma.$OperationDefectEditRequestPayload<ExtArgs>[]
      resolvedEditRequests: Prisma.$OperationDefectEditRequestPayload<ExtArgs>[]
      recordedDefects: Prisma.$OperationDefectPayload<ExtArgs>[]
      encodedOperations: Prisma.$OperationPayload<ExtArgs>[]
      operations: Prisma.$OperationPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      name: string | null
      email: string | null
      role: string
      isActive: boolean
      createdAt: Date
      lastLogin: Date | null
      department: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    deactivatedDefects<T extends User$deactivatedDefectsArgs<ExtArgs> = {}>(args?: Subset<T, User$deactivatedDefectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterDefectPayload<ExtArgs>, T, "findMany"> | Null>
    requestedEditRequests<T extends User$requestedEditRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$requestedEditRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "findMany"> | Null>
    resolvedEditRequests<T extends User$resolvedEditRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$resolvedEditRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "findMany"> | Null>
    recordedDefects<T extends User$recordedDefectsArgs<ExtArgs> = {}>(args?: Subset<T, User$recordedDefectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "findMany"> | Null>
    encodedOperations<T extends User$encodedOperationsArgs<ExtArgs> = {}>(args?: Subset<T, User$encodedOperationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "findMany"> | Null>
    operations<T extends User$operationsArgs<ExtArgs> = {}>(args?: Subset<T, User$operationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly department: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.deactivatedDefects
   */
  export type User$deactivatedDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
    where?: MasterDefectWhereInput
    orderBy?: MasterDefectOrderByWithRelationInput | MasterDefectOrderByWithRelationInput[]
    cursor?: MasterDefectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MasterDefectScalarFieldEnum | MasterDefectScalarFieldEnum[]
  }

  /**
   * User.requestedEditRequests
   */
  export type User$requestedEditRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    where?: OperationDefectEditRequestWhereInput
    orderBy?: OperationDefectEditRequestOrderByWithRelationInput | OperationDefectEditRequestOrderByWithRelationInput[]
    cursor?: OperationDefectEditRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationDefectEditRequestScalarFieldEnum | OperationDefectEditRequestScalarFieldEnum[]
  }

  /**
   * User.resolvedEditRequests
   */
  export type User$resolvedEditRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    where?: OperationDefectEditRequestWhereInput
    orderBy?: OperationDefectEditRequestOrderByWithRelationInput | OperationDefectEditRequestOrderByWithRelationInput[]
    cursor?: OperationDefectEditRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationDefectEditRequestScalarFieldEnum | OperationDefectEditRequestScalarFieldEnum[]
  }

  /**
   * User.recordedDefects
   */
  export type User$recordedDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    where?: OperationDefectWhereInput
    orderBy?: OperationDefectOrderByWithRelationInput | OperationDefectOrderByWithRelationInput[]
    cursor?: OperationDefectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationDefectScalarFieldEnum | OperationDefectScalarFieldEnum[]
  }

  /**
   * User.encodedOperations
   */
  export type User$encodedOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    where?: OperationWhereInput
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    cursor?: OperationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationScalarFieldEnum | OperationScalarFieldEnum[]
  }

  /**
   * User.operations
   */
  export type User$operationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    where?: OperationWhereInput
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    cursor?: OperationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationScalarFieldEnum | OperationScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ProductionOrder
   */

  export type AggregateProductionOrder = {
    _count: ProductionOrderCountAggregateOutputType | null
    _avg: ProductionOrderAvgAggregateOutputType | null
    _sum: ProductionOrderSumAggregateOutputType | null
    _min: ProductionOrderMinAggregateOutputType | null
    _max: ProductionOrderMaxAggregateOutputType | null
  }

  export type ProductionOrderAvgAggregateOutputType = {
    id: number | null
    poQuantity: number | null
    editingUserId: number | null
    costPerUnit: Decimal | null
    totalDefectCost: Decimal | null
  }

  export type ProductionOrderSumAggregateOutputType = {
    id: number | null
    poQuantity: number | null
    editingUserId: number | null
    costPerUnit: Decimal | null
    totalDefectCost: Decimal | null
  }

  export type ProductionOrderMinAggregateOutputType = {
    id: number | null
    poNumber: string | null
    lotNumber: string | null
    poQuantity: number | null
    itemName: string | null
    status: string | null
    currentOperation: string | null
    currentOperationStartTime: Date | null
    currentOperationEndTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    editingUserId: number | null
    editingUserName: string | null
    lockedAt: Date | null
    costPerUnit: Decimal | null
    totalDefectCost: Decimal | null
    lastCostUpdate: Date | null
  }

  export type ProductionOrderMaxAggregateOutputType = {
    id: number | null
    poNumber: string | null
    lotNumber: string | null
    poQuantity: number | null
    itemName: string | null
    status: string | null
    currentOperation: string | null
    currentOperationStartTime: Date | null
    currentOperationEndTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    editingUserId: number | null
    editingUserName: string | null
    lockedAt: Date | null
    costPerUnit: Decimal | null
    totalDefectCost: Decimal | null
    lastCostUpdate: Date | null
  }

  export type ProductionOrderCountAggregateOutputType = {
    id: number
    poNumber: number
    lotNumber: number
    poQuantity: number
    itemName: number
    status: number
    currentOperation: number
    currentOperationStartTime: number
    currentOperationEndTime: number
    createdAt: number
    updatedAt: number
    editingUserId: number
    editingUserName: number
    lockedAt: number
    costPerUnit: number
    totalDefectCost: number
    lastCostUpdate: number
    _all: number
  }


  export type ProductionOrderAvgAggregateInputType = {
    id?: true
    poQuantity?: true
    editingUserId?: true
    costPerUnit?: true
    totalDefectCost?: true
  }

  export type ProductionOrderSumAggregateInputType = {
    id?: true
    poQuantity?: true
    editingUserId?: true
    costPerUnit?: true
    totalDefectCost?: true
  }

  export type ProductionOrderMinAggregateInputType = {
    id?: true
    poNumber?: true
    lotNumber?: true
    poQuantity?: true
    itemName?: true
    status?: true
    currentOperation?: true
    currentOperationStartTime?: true
    currentOperationEndTime?: true
    createdAt?: true
    updatedAt?: true
    editingUserId?: true
    editingUserName?: true
    lockedAt?: true
    costPerUnit?: true
    totalDefectCost?: true
    lastCostUpdate?: true
  }

  export type ProductionOrderMaxAggregateInputType = {
    id?: true
    poNumber?: true
    lotNumber?: true
    poQuantity?: true
    itemName?: true
    status?: true
    currentOperation?: true
    currentOperationStartTime?: true
    currentOperationEndTime?: true
    createdAt?: true
    updatedAt?: true
    editingUserId?: true
    editingUserName?: true
    lockedAt?: true
    costPerUnit?: true
    totalDefectCost?: true
    lastCostUpdate?: true
  }

  export type ProductionOrderCountAggregateInputType = {
    id?: true
    poNumber?: true
    lotNumber?: true
    poQuantity?: true
    itemName?: true
    status?: true
    currentOperation?: true
    currentOperationStartTime?: true
    currentOperationEndTime?: true
    createdAt?: true
    updatedAt?: true
    editingUserId?: true
    editingUserName?: true
    lockedAt?: true
    costPerUnit?: true
    totalDefectCost?: true
    lastCostUpdate?: true
    _all?: true
  }

  export type ProductionOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionOrder to aggregate.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionOrders
    **/
    _count?: true | ProductionOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionOrderMaxAggregateInputType
  }

  export type GetProductionOrderAggregateType<T extends ProductionOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionOrder[P]>
      : GetScalarType<T[P], AggregateProductionOrder[P]>
  }




  export type ProductionOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionOrderWhereInput
    orderBy?: ProductionOrderOrderByWithAggregationInput | ProductionOrderOrderByWithAggregationInput[]
    by: ProductionOrderScalarFieldEnum[] | ProductionOrderScalarFieldEnum
    having?: ProductionOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionOrderCountAggregateInputType | true
    _avg?: ProductionOrderAvgAggregateInputType
    _sum?: ProductionOrderSumAggregateInputType
    _min?: ProductionOrderMinAggregateInputType
    _max?: ProductionOrderMaxAggregateInputType
  }

  export type ProductionOrderGroupByOutputType = {
    id: number
    poNumber: string
    lotNumber: string | null
    poQuantity: number
    itemName: string | null
    status: string
    currentOperation: string | null
    currentOperationStartTime: Date | null
    currentOperationEndTime: Date | null
    createdAt: Date
    updatedAt: Date
    editingUserId: number | null
    editingUserName: string | null
    lockedAt: Date | null
    costPerUnit: Decimal | null
    totalDefectCost: Decimal | null
    lastCostUpdate: Date | null
    _count: ProductionOrderCountAggregateOutputType | null
    _avg: ProductionOrderAvgAggregateOutputType | null
    _sum: ProductionOrderSumAggregateOutputType | null
    _min: ProductionOrderMinAggregateOutputType | null
    _max: ProductionOrderMaxAggregateOutputType | null
  }

  type GetProductionOrderGroupByPayload<T extends ProductionOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionOrderGroupByOutputType[P]>
        }
      >
    >


  export type ProductionOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poNumber?: boolean
    lotNumber?: boolean
    poQuantity?: boolean
    itemName?: boolean
    status?: boolean
    currentOperation?: boolean
    currentOperationStartTime?: boolean
    currentOperationEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    editingUserId?: boolean
    editingUserName?: boolean
    lockedAt?: boolean
    costPerUnit?: boolean
    totalDefectCost?: boolean
    lastCostUpdate?: boolean
    editRequests?: boolean | ProductionOrder$editRequestsArgs<ExtArgs>
    operations?: boolean | ProductionOrder$operationsArgs<ExtArgs>
    _count?: boolean | ProductionOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionOrder"]>


  export type ProductionOrderSelectScalar = {
    id?: boolean
    poNumber?: boolean
    lotNumber?: boolean
    poQuantity?: boolean
    itemName?: boolean
    status?: boolean
    currentOperation?: boolean
    currentOperationStartTime?: boolean
    currentOperationEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    editingUserId?: boolean
    editingUserName?: boolean
    lockedAt?: boolean
    costPerUnit?: boolean
    totalDefectCost?: boolean
    lastCostUpdate?: boolean
  }

  export type ProductionOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    editRequests?: boolean | ProductionOrder$editRequestsArgs<ExtArgs>
    operations?: boolean | ProductionOrder$operationsArgs<ExtArgs>
    _count?: boolean | ProductionOrderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductionOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionOrder"
    objects: {
      editRequests: Prisma.$OperationDefectEditRequestPayload<ExtArgs>[]
      operations: Prisma.$OperationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      poNumber: string
      lotNumber: string | null
      poQuantity: number
      itemName: string | null
      status: string
      currentOperation: string | null
      currentOperationStartTime: Date | null
      currentOperationEndTime: Date | null
      createdAt: Date
      updatedAt: Date
      editingUserId: number | null
      editingUserName: string | null
      lockedAt: Date | null
      costPerUnit: Prisma.Decimal | null
      totalDefectCost: Prisma.Decimal | null
      lastCostUpdate: Date | null
    }, ExtArgs["result"]["productionOrder"]>
    composites: {}
  }

  type ProductionOrderGetPayload<S extends boolean | null | undefined | ProductionOrderDefaultArgs> = $Result.GetResult<Prisma.$ProductionOrderPayload, S>

  type ProductionOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductionOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductionOrderCountAggregateInputType | true
    }

  export interface ProductionOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionOrder'], meta: { name: 'ProductionOrder' } }
    /**
     * Find zero or one ProductionOrder that matches the filter.
     * @param {ProductionOrderFindUniqueArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionOrderFindUniqueArgs>(args: SelectSubset<T, ProductionOrderFindUniqueArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductionOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductionOrderFindUniqueOrThrowArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductionOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderFindFirstArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionOrderFindFirstArgs>(args?: SelectSubset<T, ProductionOrderFindFirstArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductionOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderFindFirstOrThrowArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductionOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionOrders
     * const productionOrders = await prisma.productionOrder.findMany()
     * 
     * // Get first 10 ProductionOrders
     * const productionOrders = await prisma.productionOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionOrderWithIdOnly = await prisma.productionOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionOrderFindManyArgs>(args?: SelectSubset<T, ProductionOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductionOrder.
     * @param {ProductionOrderCreateArgs} args - Arguments to create a ProductionOrder.
     * @example
     * // Create one ProductionOrder
     * const ProductionOrder = await prisma.productionOrder.create({
     *   data: {
     *     // ... data to create a ProductionOrder
     *   }
     * })
     * 
     */
    create<T extends ProductionOrderCreateArgs>(args: SelectSubset<T, ProductionOrderCreateArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductionOrders.
     * @param {ProductionOrderCreateManyArgs} args - Arguments to create many ProductionOrders.
     * @example
     * // Create many ProductionOrders
     * const productionOrder = await prisma.productionOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionOrderCreateManyArgs>(args?: SelectSubset<T, ProductionOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductionOrder.
     * @param {ProductionOrderDeleteArgs} args - Arguments to delete one ProductionOrder.
     * @example
     * // Delete one ProductionOrder
     * const ProductionOrder = await prisma.productionOrder.delete({
     *   where: {
     *     // ... filter to delete one ProductionOrder
     *   }
     * })
     * 
     */
    delete<T extends ProductionOrderDeleteArgs>(args: SelectSubset<T, ProductionOrderDeleteArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductionOrder.
     * @param {ProductionOrderUpdateArgs} args - Arguments to update one ProductionOrder.
     * @example
     * // Update one ProductionOrder
     * const productionOrder = await prisma.productionOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionOrderUpdateArgs>(args: SelectSubset<T, ProductionOrderUpdateArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductionOrders.
     * @param {ProductionOrderDeleteManyArgs} args - Arguments to filter ProductionOrders to delete.
     * @example
     * // Delete a few ProductionOrders
     * const { count } = await prisma.productionOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionOrderDeleteManyArgs>(args?: SelectSubset<T, ProductionOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionOrders
     * const productionOrder = await prisma.productionOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionOrderUpdateManyArgs>(args: SelectSubset<T, ProductionOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductionOrder.
     * @param {ProductionOrderUpsertArgs} args - Arguments to update or create a ProductionOrder.
     * @example
     * // Update or create a ProductionOrder
     * const productionOrder = await prisma.productionOrder.upsert({
     *   create: {
     *     // ... data to create a ProductionOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionOrder we want to update
     *   }
     * })
     */
    upsert<T extends ProductionOrderUpsertArgs>(args: SelectSubset<T, ProductionOrderUpsertArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductionOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderCountArgs} args - Arguments to filter ProductionOrders to count.
     * @example
     * // Count the number of ProductionOrders
     * const count = await prisma.productionOrder.count({
     *   where: {
     *     // ... the filter for the ProductionOrders we want to count
     *   }
     * })
    **/
    count<T extends ProductionOrderCountArgs>(
      args?: Subset<T, ProductionOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionOrderAggregateArgs>(args: Subset<T, ProductionOrderAggregateArgs>): Prisma.PrismaPromise<GetProductionOrderAggregateType<T>>

    /**
     * Group by ProductionOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionOrderGroupByArgs['orderBy'] }
        : { orderBy?: ProductionOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionOrder model
   */
  readonly fields: ProductionOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    editRequests<T extends ProductionOrder$editRequestsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionOrder$editRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "findMany"> | Null>
    operations<T extends ProductionOrder$operationsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionOrder$operationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionOrder model
   */ 
  interface ProductionOrderFieldRefs {
    readonly id: FieldRef<"ProductionOrder", 'Int'>
    readonly poNumber: FieldRef<"ProductionOrder", 'String'>
    readonly lotNumber: FieldRef<"ProductionOrder", 'String'>
    readonly poQuantity: FieldRef<"ProductionOrder", 'Int'>
    readonly itemName: FieldRef<"ProductionOrder", 'String'>
    readonly status: FieldRef<"ProductionOrder", 'String'>
    readonly currentOperation: FieldRef<"ProductionOrder", 'String'>
    readonly currentOperationStartTime: FieldRef<"ProductionOrder", 'DateTime'>
    readonly currentOperationEndTime: FieldRef<"ProductionOrder", 'DateTime'>
    readonly createdAt: FieldRef<"ProductionOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionOrder", 'DateTime'>
    readonly editingUserId: FieldRef<"ProductionOrder", 'Int'>
    readonly editingUserName: FieldRef<"ProductionOrder", 'String'>
    readonly lockedAt: FieldRef<"ProductionOrder", 'DateTime'>
    readonly costPerUnit: FieldRef<"ProductionOrder", 'Decimal'>
    readonly totalDefectCost: FieldRef<"ProductionOrder", 'Decimal'>
    readonly lastCostUpdate: FieldRef<"ProductionOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionOrder findUnique
   */
  export type ProductionOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder findUniqueOrThrow
   */
  export type ProductionOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder findFirst
   */
  export type ProductionOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionOrders.
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionOrders.
     */
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * ProductionOrder findFirstOrThrow
   */
  export type ProductionOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionOrders.
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionOrders.
     */
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * ProductionOrder findMany
   */
  export type ProductionOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOrders to fetch.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionOrders.
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * ProductionOrder create
   */
  export type ProductionOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionOrder.
     */
    data: XOR<ProductionOrderCreateInput, ProductionOrderUncheckedCreateInput>
  }

  /**
   * ProductionOrder createMany
   */
  export type ProductionOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionOrders.
     */
    data: ProductionOrderCreateManyInput | ProductionOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionOrder update
   */
  export type ProductionOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionOrder.
     */
    data: XOR<ProductionOrderUpdateInput, ProductionOrderUncheckedUpdateInput>
    /**
     * Choose, which ProductionOrder to update.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder updateMany
   */
  export type ProductionOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionOrders.
     */
    data: XOR<ProductionOrderUpdateManyMutationInput, ProductionOrderUncheckedUpdateManyInput>
    /**
     * Filter which ProductionOrders to update
     */
    where?: ProductionOrderWhereInput
  }

  /**
   * ProductionOrder upsert
   */
  export type ProductionOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionOrder to update in case it exists.
     */
    where: ProductionOrderWhereUniqueInput
    /**
     * In case the ProductionOrder found by the `where` argument doesn't exist, create a new ProductionOrder with this data.
     */
    create: XOR<ProductionOrderCreateInput, ProductionOrderUncheckedCreateInput>
    /**
     * In case the ProductionOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionOrderUpdateInput, ProductionOrderUncheckedUpdateInput>
  }

  /**
   * ProductionOrder delete
   */
  export type ProductionOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter which ProductionOrder to delete.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder deleteMany
   */
  export type ProductionOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionOrders to delete
     */
    where?: ProductionOrderWhereInput
  }

  /**
   * ProductionOrder.editRequests
   */
  export type ProductionOrder$editRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    where?: OperationDefectEditRequestWhereInput
    orderBy?: OperationDefectEditRequestOrderByWithRelationInput | OperationDefectEditRequestOrderByWithRelationInput[]
    cursor?: OperationDefectEditRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationDefectEditRequestScalarFieldEnum | OperationDefectEditRequestScalarFieldEnum[]
  }

  /**
   * ProductionOrder.operations
   */
  export type ProductionOrder$operationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    where?: OperationWhereInput
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    cursor?: OperationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationScalarFieldEnum | OperationScalarFieldEnum[]
  }

  /**
   * ProductionOrder without action
   */
  export type ProductionOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
  }


  /**
   * Model Operation
   */

  export type AggregateOperation = {
    _count: OperationCountAggregateOutputType | null
    _avg: OperationAvgAggregateOutputType | null
    _sum: OperationSumAggregateOutputType | null
    _min: OperationMinAggregateOutputType | null
    _max: OperationMaxAggregateOutputType | null
  }

  export type OperationAvgAggregateOutputType = {
    id: number | null
    productionOrderId: number | null
    operatorId: number | null
    inputQuantity: number | null
    outputQuantity: number | null
    productionHours: number | null
    accumulatedManHours: number | null
    rf: number | null
    encodedById: number | null
    defectCost: Decimal | null
  }

  export type OperationSumAggregateOutputType = {
    id: number | null
    productionOrderId: number | null
    operatorId: number | null
    inputQuantity: number | null
    outputQuantity: number | null
    productionHours: number | null
    accumulatedManHours: number | null
    rf: number | null
    encodedById: number | null
    defectCost: Decimal | null
  }

  export type OperationMinAggregateOutputType = {
    id: number | null
    productionOrderId: number | null
    operation: string | null
    operatorId: number | null
    startTime: Date | null
    endTime: Date | null
    inputQuantity: number | null
    outputQuantity: number | null
    productionHours: number | null
    accumulatedManHours: number | null
    rf: number | null
    lineNo: string | null
    shift: string | null
    encodedById: number | null
    encodedTime: Date | null
    defectCost: Decimal | null
  }

  export type OperationMaxAggregateOutputType = {
    id: number | null
    productionOrderId: number | null
    operation: string | null
    operatorId: number | null
    startTime: Date | null
    endTime: Date | null
    inputQuantity: number | null
    outputQuantity: number | null
    productionHours: number | null
    accumulatedManHours: number | null
    rf: number | null
    lineNo: string | null
    shift: string | null
    encodedById: number | null
    encodedTime: Date | null
    defectCost: Decimal | null
  }

  export type OperationCountAggregateOutputType = {
    id: number
    productionOrderId: number
    operation: number
    operatorId: number
    startTime: number
    endTime: number
    inputQuantity: number
    outputQuantity: number
    productionHours: number
    accumulatedManHours: number
    rf: number
    lineNo: number
    shift: number
    encodedById: number
    encodedTime: number
    defectCost: number
    _all: number
  }


  export type OperationAvgAggregateInputType = {
    id?: true
    productionOrderId?: true
    operatorId?: true
    inputQuantity?: true
    outputQuantity?: true
    productionHours?: true
    accumulatedManHours?: true
    rf?: true
    encodedById?: true
    defectCost?: true
  }

  export type OperationSumAggregateInputType = {
    id?: true
    productionOrderId?: true
    operatorId?: true
    inputQuantity?: true
    outputQuantity?: true
    productionHours?: true
    accumulatedManHours?: true
    rf?: true
    encodedById?: true
    defectCost?: true
  }

  export type OperationMinAggregateInputType = {
    id?: true
    productionOrderId?: true
    operation?: true
    operatorId?: true
    startTime?: true
    endTime?: true
    inputQuantity?: true
    outputQuantity?: true
    productionHours?: true
    accumulatedManHours?: true
    rf?: true
    lineNo?: true
    shift?: true
    encodedById?: true
    encodedTime?: true
    defectCost?: true
  }

  export type OperationMaxAggregateInputType = {
    id?: true
    productionOrderId?: true
    operation?: true
    operatorId?: true
    startTime?: true
    endTime?: true
    inputQuantity?: true
    outputQuantity?: true
    productionHours?: true
    accumulatedManHours?: true
    rf?: true
    lineNo?: true
    shift?: true
    encodedById?: true
    encodedTime?: true
    defectCost?: true
  }

  export type OperationCountAggregateInputType = {
    id?: true
    productionOrderId?: true
    operation?: true
    operatorId?: true
    startTime?: true
    endTime?: true
    inputQuantity?: true
    outputQuantity?: true
    productionHours?: true
    accumulatedManHours?: true
    rf?: true
    lineNo?: true
    shift?: true
    encodedById?: true
    encodedTime?: true
    defectCost?: true
    _all?: true
  }

  export type OperationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operation to aggregate.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Operations
    **/
    _count?: true | OperationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationMaxAggregateInputType
  }

  export type GetOperationAggregateType<T extends OperationAggregateArgs> = {
        [P in keyof T & keyof AggregateOperation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperation[P]>
      : GetScalarType<T[P], AggregateOperation[P]>
  }




  export type OperationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationWhereInput
    orderBy?: OperationOrderByWithAggregationInput | OperationOrderByWithAggregationInput[]
    by: OperationScalarFieldEnum[] | OperationScalarFieldEnum
    having?: OperationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationCountAggregateInputType | true
    _avg?: OperationAvgAggregateInputType
    _sum?: OperationSumAggregateInputType
    _min?: OperationMinAggregateInputType
    _max?: OperationMaxAggregateInputType
  }

  export type OperationGroupByOutputType = {
    id: number
    productionOrderId: number
    operation: string
    operatorId: number
    startTime: Date | null
    endTime: Date | null
    inputQuantity: number
    outputQuantity: number | null
    productionHours: number | null
    accumulatedManHours: number | null
    rf: number | null
    lineNo: string | null
    shift: string | null
    encodedById: number
    encodedTime: Date
    defectCost: Decimal | null
    _count: OperationCountAggregateOutputType | null
    _avg: OperationAvgAggregateOutputType | null
    _sum: OperationSumAggregateOutputType | null
    _min: OperationMinAggregateOutputType | null
    _max: OperationMaxAggregateOutputType | null
  }

  type GetOperationGroupByPayload<T extends OperationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationGroupByOutputType[P]>
            : GetScalarType<T[P], OperationGroupByOutputType[P]>
        }
      >
    >


  export type OperationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionOrderId?: boolean
    operation?: boolean
    operatorId?: boolean
    startTime?: boolean
    endTime?: boolean
    inputQuantity?: boolean
    outputQuantity?: boolean
    productionHours?: boolean
    accumulatedManHours?: boolean
    rf?: boolean
    lineNo?: boolean
    shift?: boolean
    encodedById?: boolean
    encodedTime?: boolean
    defectCost?: boolean
    editRequests?: boolean | Operation$editRequestsArgs<ExtArgs>
    operationDefects?: boolean | Operation$operationDefectsArgs<ExtArgs>
    encodedBy?: boolean | UserDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
    _count?: boolean | OperationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operation"]>


  export type OperationSelectScalar = {
    id?: boolean
    productionOrderId?: boolean
    operation?: boolean
    operatorId?: boolean
    startTime?: boolean
    endTime?: boolean
    inputQuantity?: boolean
    outputQuantity?: boolean
    productionHours?: boolean
    accumulatedManHours?: boolean
    rf?: boolean
    lineNo?: boolean
    shift?: boolean
    encodedById?: boolean
    encodedTime?: boolean
    defectCost?: boolean
  }

  export type OperationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    editRequests?: boolean | Operation$editRequestsArgs<ExtArgs>
    operationDefects?: boolean | Operation$operationDefectsArgs<ExtArgs>
    encodedBy?: boolean | UserDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
    _count?: boolean | OperationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OperationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Operation"
    objects: {
      editRequests: Prisma.$OperationDefectEditRequestPayload<ExtArgs>[]
      operationDefects: Prisma.$OperationDefectPayload<ExtArgs>[]
      encodedBy: Prisma.$UserPayload<ExtArgs>
      operator: Prisma.$UserPayload<ExtArgs>
      productionOrder: Prisma.$ProductionOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productionOrderId: number
      operation: string
      operatorId: number
      startTime: Date | null
      endTime: Date | null
      inputQuantity: number
      outputQuantity: number | null
      productionHours: number | null
      accumulatedManHours: number | null
      rf: number | null
      lineNo: string | null
      shift: string | null
      encodedById: number
      encodedTime: Date
      defectCost: Prisma.Decimal | null
    }, ExtArgs["result"]["operation"]>
    composites: {}
  }

  type OperationGetPayload<S extends boolean | null | undefined | OperationDefaultArgs> = $Result.GetResult<Prisma.$OperationPayload, S>

  type OperationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationCountAggregateInputType | true
    }

  export interface OperationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Operation'], meta: { name: 'Operation' } }
    /**
     * Find zero or one Operation that matches the filter.
     * @param {OperationFindUniqueArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationFindUniqueArgs>(args: SelectSubset<T, OperationFindUniqueArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Operation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationFindUniqueOrThrowArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Operation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationFindFirstArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationFindFirstArgs>(args?: SelectSubset<T, OperationFindFirstArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Operation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationFindFirstOrThrowArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Operations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operations
     * const operations = await prisma.operation.findMany()
     * 
     * // Get first 10 Operations
     * const operations = await prisma.operation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationWithIdOnly = await prisma.operation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperationFindManyArgs>(args?: SelectSubset<T, OperationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Operation.
     * @param {OperationCreateArgs} args - Arguments to create a Operation.
     * @example
     * // Create one Operation
     * const Operation = await prisma.operation.create({
     *   data: {
     *     // ... data to create a Operation
     *   }
     * })
     * 
     */
    create<T extends OperationCreateArgs>(args: SelectSubset<T, OperationCreateArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Operations.
     * @param {OperationCreateManyArgs} args - Arguments to create many Operations.
     * @example
     * // Create many Operations
     * const operation = await prisma.operation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationCreateManyArgs>(args?: SelectSubset<T, OperationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Operation.
     * @param {OperationDeleteArgs} args - Arguments to delete one Operation.
     * @example
     * // Delete one Operation
     * const Operation = await prisma.operation.delete({
     *   where: {
     *     // ... filter to delete one Operation
     *   }
     * })
     * 
     */
    delete<T extends OperationDeleteArgs>(args: SelectSubset<T, OperationDeleteArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Operation.
     * @param {OperationUpdateArgs} args - Arguments to update one Operation.
     * @example
     * // Update one Operation
     * const operation = await prisma.operation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationUpdateArgs>(args: SelectSubset<T, OperationUpdateArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Operations.
     * @param {OperationDeleteManyArgs} args - Arguments to filter Operations to delete.
     * @example
     * // Delete a few Operations
     * const { count } = await prisma.operation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationDeleteManyArgs>(args?: SelectSubset<T, OperationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operations
     * const operation = await prisma.operation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationUpdateManyArgs>(args: SelectSubset<T, OperationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operation.
     * @param {OperationUpsertArgs} args - Arguments to update or create a Operation.
     * @example
     * // Update or create a Operation
     * const operation = await prisma.operation.upsert({
     *   create: {
     *     // ... data to create a Operation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operation we want to update
     *   }
     * })
     */
    upsert<T extends OperationUpsertArgs>(args: SelectSubset<T, OperationUpsertArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationCountArgs} args - Arguments to filter Operations to count.
     * @example
     * // Count the number of Operations
     * const count = await prisma.operation.count({
     *   where: {
     *     // ... the filter for the Operations we want to count
     *   }
     * })
    **/
    count<T extends OperationCountArgs>(
      args?: Subset<T, OperationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationAggregateArgs>(args: Subset<T, OperationAggregateArgs>): Prisma.PrismaPromise<GetOperationAggregateType<T>>

    /**
     * Group by Operation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationGroupByArgs['orderBy'] }
        : { orderBy?: OperationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Operation model
   */
  readonly fields: OperationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Operation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    editRequests<T extends Operation$editRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Operation$editRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "findMany"> | Null>
    operationDefects<T extends Operation$operationDefectsArgs<ExtArgs> = {}>(args?: Subset<T, Operation$operationDefectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "findMany"> | Null>
    encodedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    operator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    productionOrder<T extends ProductionOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionOrderDefaultArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Operation model
   */ 
  interface OperationFieldRefs {
    readonly id: FieldRef<"Operation", 'Int'>
    readonly productionOrderId: FieldRef<"Operation", 'Int'>
    readonly operation: FieldRef<"Operation", 'String'>
    readonly operatorId: FieldRef<"Operation", 'Int'>
    readonly startTime: FieldRef<"Operation", 'DateTime'>
    readonly endTime: FieldRef<"Operation", 'DateTime'>
    readonly inputQuantity: FieldRef<"Operation", 'Int'>
    readonly outputQuantity: FieldRef<"Operation", 'Int'>
    readonly productionHours: FieldRef<"Operation", 'Float'>
    readonly accumulatedManHours: FieldRef<"Operation", 'Float'>
    readonly rf: FieldRef<"Operation", 'Int'>
    readonly lineNo: FieldRef<"Operation", 'String'>
    readonly shift: FieldRef<"Operation", 'String'>
    readonly encodedById: FieldRef<"Operation", 'Int'>
    readonly encodedTime: FieldRef<"Operation", 'DateTime'>
    readonly defectCost: FieldRef<"Operation", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Operation findUnique
   */
  export type OperationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter, which Operation to fetch.
     */
    where: OperationWhereUniqueInput
  }

  /**
   * Operation findUniqueOrThrow
   */
  export type OperationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter, which Operation to fetch.
     */
    where: OperationWhereUniqueInput
  }

  /**
   * Operation findFirst
   */
  export type OperationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter, which Operation to fetch.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operations.
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operations.
     */
    distinct?: OperationScalarFieldEnum | OperationScalarFieldEnum[]
  }

  /**
   * Operation findFirstOrThrow
   */
  export type OperationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter, which Operation to fetch.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operations.
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operations.
     */
    distinct?: OperationScalarFieldEnum | OperationScalarFieldEnum[]
  }

  /**
   * Operation findMany
   */
  export type OperationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter, which Operations to fetch.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: OperationOrderByWithRelationInput | OperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Operations.
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    distinct?: OperationScalarFieldEnum | OperationScalarFieldEnum[]
  }

  /**
   * Operation create
   */
  export type OperationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * The data needed to create a Operation.
     */
    data: XOR<OperationCreateInput, OperationUncheckedCreateInput>
  }

  /**
   * Operation createMany
   */
  export type OperationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Operations.
     */
    data: OperationCreateManyInput | OperationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Operation update
   */
  export type OperationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * The data needed to update a Operation.
     */
    data: XOR<OperationUpdateInput, OperationUncheckedUpdateInput>
    /**
     * Choose, which Operation to update.
     */
    where: OperationWhereUniqueInput
  }

  /**
   * Operation updateMany
   */
  export type OperationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Operations.
     */
    data: XOR<OperationUpdateManyMutationInput, OperationUncheckedUpdateManyInput>
    /**
     * Filter which Operations to update
     */
    where?: OperationWhereInput
  }

  /**
   * Operation upsert
   */
  export type OperationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * The filter to search for the Operation to update in case it exists.
     */
    where: OperationWhereUniqueInput
    /**
     * In case the Operation found by the `where` argument doesn't exist, create a new Operation with this data.
     */
    create: XOR<OperationCreateInput, OperationUncheckedCreateInput>
    /**
     * In case the Operation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationUpdateInput, OperationUncheckedUpdateInput>
  }

  /**
   * Operation delete
   */
  export type OperationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
    /**
     * Filter which Operation to delete.
     */
    where: OperationWhereUniqueInput
  }

  /**
   * Operation deleteMany
   */
  export type OperationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operations to delete
     */
    where?: OperationWhereInput
  }

  /**
   * Operation.editRequests
   */
  export type Operation$editRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    where?: OperationDefectEditRequestWhereInput
    orderBy?: OperationDefectEditRequestOrderByWithRelationInput | OperationDefectEditRequestOrderByWithRelationInput[]
    cursor?: OperationDefectEditRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationDefectEditRequestScalarFieldEnum | OperationDefectEditRequestScalarFieldEnum[]
  }

  /**
   * Operation.operationDefects
   */
  export type Operation$operationDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    where?: OperationDefectWhereInput
    orderBy?: OperationDefectOrderByWithRelationInput | OperationDefectOrderByWithRelationInput[]
    cursor?: OperationDefectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationDefectScalarFieldEnum | OperationDefectScalarFieldEnum[]
  }

  /**
   * Operation without action
   */
  export type OperationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationInclude<ExtArgs> | null
  }


  /**
   * Model MasterDefect
   */

  export type AggregateMasterDefect = {
    _count: MasterDefectCountAggregateOutputType | null
    _avg: MasterDefectAvgAggregateOutputType | null
    _sum: MasterDefectSumAggregateOutputType | null
    _min: MasterDefectMinAggregateOutputType | null
    _max: MasterDefectMaxAggregateOutputType | null
  }

  export type MasterDefectAvgAggregateOutputType = {
    id: number | null
    deactivatedById: number | null
  }

  export type MasterDefectSumAggregateOutputType = {
    id: number | null
    deactivatedById: number | null
  }

  export type MasterDefectMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    applicableOperation: string | null
    reworkable: boolean | null
    machine: string | null
    isActive: boolean | null
    deactivatedAt: Date | null
    deactivatedById: number | null
  }

  export type MasterDefectMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    applicableOperation: string | null
    reworkable: boolean | null
    machine: string | null
    isActive: boolean | null
    deactivatedAt: Date | null
    deactivatedById: number | null
  }

  export type MasterDefectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    applicableOperation: number
    reworkable: number
    machine: number
    isActive: number
    deactivatedAt: number
    deactivatedById: number
    _all: number
  }


  export type MasterDefectAvgAggregateInputType = {
    id?: true
    deactivatedById?: true
  }

  export type MasterDefectSumAggregateInputType = {
    id?: true
    deactivatedById?: true
  }

  export type MasterDefectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    applicableOperation?: true
    reworkable?: true
    machine?: true
    isActive?: true
    deactivatedAt?: true
    deactivatedById?: true
  }

  export type MasterDefectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    applicableOperation?: true
    reworkable?: true
    machine?: true
    isActive?: true
    deactivatedAt?: true
    deactivatedById?: true
  }

  export type MasterDefectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    applicableOperation?: true
    reworkable?: true
    machine?: true
    isActive?: true
    deactivatedAt?: true
    deactivatedById?: true
    _all?: true
  }

  export type MasterDefectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterDefect to aggregate.
     */
    where?: MasterDefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDefects to fetch.
     */
    orderBy?: MasterDefectOrderByWithRelationInput | MasterDefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterDefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDefects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDefects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterDefects
    **/
    _count?: true | MasterDefectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterDefectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterDefectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterDefectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterDefectMaxAggregateInputType
  }

  export type GetMasterDefectAggregateType<T extends MasterDefectAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterDefect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterDefect[P]>
      : GetScalarType<T[P], AggregateMasterDefect[P]>
  }




  export type MasterDefectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterDefectWhereInput
    orderBy?: MasterDefectOrderByWithAggregationInput | MasterDefectOrderByWithAggregationInput[]
    by: MasterDefectScalarFieldEnum[] | MasterDefectScalarFieldEnum
    having?: MasterDefectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterDefectCountAggregateInputType | true
    _avg?: MasterDefectAvgAggregateInputType
    _sum?: MasterDefectSumAggregateInputType
    _min?: MasterDefectMinAggregateInputType
    _max?: MasterDefectMaxAggregateInputType
  }

  export type MasterDefectGroupByOutputType = {
    id: number
    name: string
    description: string | null
    category: string | null
    applicableOperation: string | null
    reworkable: boolean
    machine: string | null
    isActive: boolean
    deactivatedAt: Date | null
    deactivatedById: number | null
    _count: MasterDefectCountAggregateOutputType | null
    _avg: MasterDefectAvgAggregateOutputType | null
    _sum: MasterDefectSumAggregateOutputType | null
    _min: MasterDefectMinAggregateOutputType | null
    _max: MasterDefectMaxAggregateOutputType | null
  }

  type GetMasterDefectGroupByPayload<T extends MasterDefectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterDefectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterDefectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterDefectGroupByOutputType[P]>
            : GetScalarType<T[P], MasterDefectGroupByOutputType[P]>
        }
      >
    >


  export type MasterDefectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    applicableOperation?: boolean
    reworkable?: boolean
    machine?: boolean
    isActive?: boolean
    deactivatedAt?: boolean
    deactivatedById?: boolean
    deactivatedBy?: boolean | MasterDefect$deactivatedByArgs<ExtArgs>
    operationDefects?: boolean | MasterDefect$operationDefectsArgs<ExtArgs>
    _count?: boolean | MasterDefectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["masterDefect"]>


  export type MasterDefectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    applicableOperation?: boolean
    reworkable?: boolean
    machine?: boolean
    isActive?: boolean
    deactivatedAt?: boolean
    deactivatedById?: boolean
  }

  export type MasterDefectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deactivatedBy?: boolean | MasterDefect$deactivatedByArgs<ExtArgs>
    operationDefects?: boolean | MasterDefect$operationDefectsArgs<ExtArgs>
    _count?: boolean | MasterDefectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MasterDefectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MasterDefect"
    objects: {
      deactivatedBy: Prisma.$UserPayload<ExtArgs> | null
      operationDefects: Prisma.$OperationDefectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      category: string | null
      applicableOperation: string | null
      reworkable: boolean
      machine: string | null
      isActive: boolean
      deactivatedAt: Date | null
      deactivatedById: number | null
    }, ExtArgs["result"]["masterDefect"]>
    composites: {}
  }

  type MasterDefectGetPayload<S extends boolean | null | undefined | MasterDefectDefaultArgs> = $Result.GetResult<Prisma.$MasterDefectPayload, S>

  type MasterDefectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MasterDefectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MasterDefectCountAggregateInputType | true
    }

  export interface MasterDefectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MasterDefect'], meta: { name: 'MasterDefect' } }
    /**
     * Find zero or one MasterDefect that matches the filter.
     * @param {MasterDefectFindUniqueArgs} args - Arguments to find a MasterDefect
     * @example
     * // Get one MasterDefect
     * const masterDefect = await prisma.masterDefect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MasterDefectFindUniqueArgs>(args: SelectSubset<T, MasterDefectFindUniqueArgs<ExtArgs>>): Prisma__MasterDefectClient<$Result.GetResult<Prisma.$MasterDefectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MasterDefect that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MasterDefectFindUniqueOrThrowArgs} args - Arguments to find a MasterDefect
     * @example
     * // Get one MasterDefect
     * const masterDefect = await prisma.masterDefect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MasterDefectFindUniqueOrThrowArgs>(args: SelectSubset<T, MasterDefectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MasterDefectClient<$Result.GetResult<Prisma.$MasterDefectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MasterDefect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDefectFindFirstArgs} args - Arguments to find a MasterDefect
     * @example
     * // Get one MasterDefect
     * const masterDefect = await prisma.masterDefect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MasterDefectFindFirstArgs>(args?: SelectSubset<T, MasterDefectFindFirstArgs<ExtArgs>>): Prisma__MasterDefectClient<$Result.GetResult<Prisma.$MasterDefectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MasterDefect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDefectFindFirstOrThrowArgs} args - Arguments to find a MasterDefect
     * @example
     * // Get one MasterDefect
     * const masterDefect = await prisma.masterDefect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MasterDefectFindFirstOrThrowArgs>(args?: SelectSubset<T, MasterDefectFindFirstOrThrowArgs<ExtArgs>>): Prisma__MasterDefectClient<$Result.GetResult<Prisma.$MasterDefectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MasterDefects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDefectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterDefects
     * const masterDefects = await prisma.masterDefect.findMany()
     * 
     * // Get first 10 MasterDefects
     * const masterDefects = await prisma.masterDefect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterDefectWithIdOnly = await prisma.masterDefect.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MasterDefectFindManyArgs>(args?: SelectSubset<T, MasterDefectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterDefectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MasterDefect.
     * @param {MasterDefectCreateArgs} args - Arguments to create a MasterDefect.
     * @example
     * // Create one MasterDefect
     * const MasterDefect = await prisma.masterDefect.create({
     *   data: {
     *     // ... data to create a MasterDefect
     *   }
     * })
     * 
     */
    create<T extends MasterDefectCreateArgs>(args: SelectSubset<T, MasterDefectCreateArgs<ExtArgs>>): Prisma__MasterDefectClient<$Result.GetResult<Prisma.$MasterDefectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MasterDefects.
     * @param {MasterDefectCreateManyArgs} args - Arguments to create many MasterDefects.
     * @example
     * // Create many MasterDefects
     * const masterDefect = await prisma.masterDefect.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MasterDefectCreateManyArgs>(args?: SelectSubset<T, MasterDefectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MasterDefect.
     * @param {MasterDefectDeleteArgs} args - Arguments to delete one MasterDefect.
     * @example
     * // Delete one MasterDefect
     * const MasterDefect = await prisma.masterDefect.delete({
     *   where: {
     *     // ... filter to delete one MasterDefect
     *   }
     * })
     * 
     */
    delete<T extends MasterDefectDeleteArgs>(args: SelectSubset<T, MasterDefectDeleteArgs<ExtArgs>>): Prisma__MasterDefectClient<$Result.GetResult<Prisma.$MasterDefectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MasterDefect.
     * @param {MasterDefectUpdateArgs} args - Arguments to update one MasterDefect.
     * @example
     * // Update one MasterDefect
     * const masterDefect = await prisma.masterDefect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MasterDefectUpdateArgs>(args: SelectSubset<T, MasterDefectUpdateArgs<ExtArgs>>): Prisma__MasterDefectClient<$Result.GetResult<Prisma.$MasterDefectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MasterDefects.
     * @param {MasterDefectDeleteManyArgs} args - Arguments to filter MasterDefects to delete.
     * @example
     * // Delete a few MasterDefects
     * const { count } = await prisma.masterDefect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MasterDefectDeleteManyArgs>(args?: SelectSubset<T, MasterDefectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterDefects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDefectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterDefects
     * const masterDefect = await prisma.masterDefect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MasterDefectUpdateManyArgs>(args: SelectSubset<T, MasterDefectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterDefect.
     * @param {MasterDefectUpsertArgs} args - Arguments to update or create a MasterDefect.
     * @example
     * // Update or create a MasterDefect
     * const masterDefect = await prisma.masterDefect.upsert({
     *   create: {
     *     // ... data to create a MasterDefect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterDefect we want to update
     *   }
     * })
     */
    upsert<T extends MasterDefectUpsertArgs>(args: SelectSubset<T, MasterDefectUpsertArgs<ExtArgs>>): Prisma__MasterDefectClient<$Result.GetResult<Prisma.$MasterDefectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MasterDefects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDefectCountArgs} args - Arguments to filter MasterDefects to count.
     * @example
     * // Count the number of MasterDefects
     * const count = await prisma.masterDefect.count({
     *   where: {
     *     // ... the filter for the MasterDefects we want to count
     *   }
     * })
    **/
    count<T extends MasterDefectCountArgs>(
      args?: Subset<T, MasterDefectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterDefectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterDefect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDefectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterDefectAggregateArgs>(args: Subset<T, MasterDefectAggregateArgs>): Prisma.PrismaPromise<GetMasterDefectAggregateType<T>>

    /**
     * Group by MasterDefect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterDefectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterDefectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterDefectGroupByArgs['orderBy'] }
        : { orderBy?: MasterDefectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterDefectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterDefectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MasterDefect model
   */
  readonly fields: MasterDefectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterDefect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterDefectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deactivatedBy<T extends MasterDefect$deactivatedByArgs<ExtArgs> = {}>(args?: Subset<T, MasterDefect$deactivatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    operationDefects<T extends MasterDefect$operationDefectsArgs<ExtArgs> = {}>(args?: Subset<T, MasterDefect$operationDefectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MasterDefect model
   */ 
  interface MasterDefectFieldRefs {
    readonly id: FieldRef<"MasterDefect", 'Int'>
    readonly name: FieldRef<"MasterDefect", 'String'>
    readonly description: FieldRef<"MasterDefect", 'String'>
    readonly category: FieldRef<"MasterDefect", 'String'>
    readonly applicableOperation: FieldRef<"MasterDefect", 'String'>
    readonly reworkable: FieldRef<"MasterDefect", 'Boolean'>
    readonly machine: FieldRef<"MasterDefect", 'String'>
    readonly isActive: FieldRef<"MasterDefect", 'Boolean'>
    readonly deactivatedAt: FieldRef<"MasterDefect", 'DateTime'>
    readonly deactivatedById: FieldRef<"MasterDefect", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MasterDefect findUnique
   */
  export type MasterDefectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
    /**
     * Filter, which MasterDefect to fetch.
     */
    where: MasterDefectWhereUniqueInput
  }

  /**
   * MasterDefect findUniqueOrThrow
   */
  export type MasterDefectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
    /**
     * Filter, which MasterDefect to fetch.
     */
    where: MasterDefectWhereUniqueInput
  }

  /**
   * MasterDefect findFirst
   */
  export type MasterDefectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
    /**
     * Filter, which MasterDefect to fetch.
     */
    where?: MasterDefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDefects to fetch.
     */
    orderBy?: MasterDefectOrderByWithRelationInput | MasterDefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterDefects.
     */
    cursor?: MasterDefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDefects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDefects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterDefects.
     */
    distinct?: MasterDefectScalarFieldEnum | MasterDefectScalarFieldEnum[]
  }

  /**
   * MasterDefect findFirstOrThrow
   */
  export type MasterDefectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
    /**
     * Filter, which MasterDefect to fetch.
     */
    where?: MasterDefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDefects to fetch.
     */
    orderBy?: MasterDefectOrderByWithRelationInput | MasterDefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterDefects.
     */
    cursor?: MasterDefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDefects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDefects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterDefects.
     */
    distinct?: MasterDefectScalarFieldEnum | MasterDefectScalarFieldEnum[]
  }

  /**
   * MasterDefect findMany
   */
  export type MasterDefectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
    /**
     * Filter, which MasterDefects to fetch.
     */
    where?: MasterDefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterDefects to fetch.
     */
    orderBy?: MasterDefectOrderByWithRelationInput | MasterDefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterDefects.
     */
    cursor?: MasterDefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterDefects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterDefects.
     */
    skip?: number
    distinct?: MasterDefectScalarFieldEnum | MasterDefectScalarFieldEnum[]
  }

  /**
   * MasterDefect create
   */
  export type MasterDefectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
    /**
     * The data needed to create a MasterDefect.
     */
    data: XOR<MasterDefectCreateInput, MasterDefectUncheckedCreateInput>
  }

  /**
   * MasterDefect createMany
   */
  export type MasterDefectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MasterDefects.
     */
    data: MasterDefectCreateManyInput | MasterDefectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MasterDefect update
   */
  export type MasterDefectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
    /**
     * The data needed to update a MasterDefect.
     */
    data: XOR<MasterDefectUpdateInput, MasterDefectUncheckedUpdateInput>
    /**
     * Choose, which MasterDefect to update.
     */
    where: MasterDefectWhereUniqueInput
  }

  /**
   * MasterDefect updateMany
   */
  export type MasterDefectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MasterDefects.
     */
    data: XOR<MasterDefectUpdateManyMutationInput, MasterDefectUncheckedUpdateManyInput>
    /**
     * Filter which MasterDefects to update
     */
    where?: MasterDefectWhereInput
  }

  /**
   * MasterDefect upsert
   */
  export type MasterDefectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
    /**
     * The filter to search for the MasterDefect to update in case it exists.
     */
    where: MasterDefectWhereUniqueInput
    /**
     * In case the MasterDefect found by the `where` argument doesn't exist, create a new MasterDefect with this data.
     */
    create: XOR<MasterDefectCreateInput, MasterDefectUncheckedCreateInput>
    /**
     * In case the MasterDefect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterDefectUpdateInput, MasterDefectUncheckedUpdateInput>
  }

  /**
   * MasterDefect delete
   */
  export type MasterDefectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
    /**
     * Filter which MasterDefect to delete.
     */
    where: MasterDefectWhereUniqueInput
  }

  /**
   * MasterDefect deleteMany
   */
  export type MasterDefectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterDefects to delete
     */
    where?: MasterDefectWhereInput
  }

  /**
   * MasterDefect.deactivatedBy
   */
  export type MasterDefect$deactivatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MasterDefect.operationDefects
   */
  export type MasterDefect$operationDefectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    where?: OperationDefectWhereInput
    orderBy?: OperationDefectOrderByWithRelationInput | OperationDefectOrderByWithRelationInput[]
    cursor?: OperationDefectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationDefectScalarFieldEnum | OperationDefectScalarFieldEnum[]
  }

  /**
   * MasterDefect without action
   */
  export type MasterDefectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
  }


  /**
   * Model StandardCost
   */

  export type AggregateStandardCost = {
    _count: StandardCostCountAggregateOutputType | null
    _avg: StandardCostAvgAggregateOutputType | null
    _sum: StandardCostSumAggregateOutputType | null
    _min: StandardCostMinAggregateOutputType | null
    _max: StandardCostMaxAggregateOutputType | null
  }

  export type StandardCostAvgAggregateOutputType = {
    id: number | null
    costPerUnit: Decimal | null
    createdById: number | null
    updatedById: number | null
  }

  export type StandardCostSumAggregateOutputType = {
    id: number | null
    costPerUnit: Decimal | null
    createdById: number | null
    updatedById: number | null
  }

  export type StandardCostMinAggregateOutputType = {
    id: number | null
    itemName: string | null
    description: string | null
    costPerUnit: Decimal | null
    currency: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type StandardCostMaxAggregateOutputType = {
    id: number | null
    itemName: string | null
    description: string | null
    costPerUnit: Decimal | null
    currency: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type StandardCostCountAggregateOutputType = {
    id: number
    itemName: number
    description: number
    costPerUnit: number
    currency: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type StandardCostAvgAggregateInputType = {
    id?: true
    costPerUnit?: true
    createdById?: true
    updatedById?: true
  }

  export type StandardCostSumAggregateInputType = {
    id?: true
    costPerUnit?: true
    createdById?: true
    updatedById?: true
  }

  export type StandardCostMinAggregateInputType = {
    id?: true
    itemName?: true
    description?: true
    costPerUnit?: true
    currency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type StandardCostMaxAggregateInputType = {
    id?: true
    itemName?: true
    description?: true
    costPerUnit?: true
    currency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type StandardCostCountAggregateInputType = {
    id?: true
    itemName?: true
    description?: true
    costPerUnit?: true
    currency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type StandardCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardCost to aggregate.
     */
    where?: StandardCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCosts to fetch.
     */
    orderBy?: StandardCostOrderByWithRelationInput | StandardCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandardCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StandardCosts
    **/
    _count?: true | StandardCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StandardCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StandardCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardCostMaxAggregateInputType
  }

  export type GetStandardCostAggregateType<T extends StandardCostAggregateArgs> = {
        [P in keyof T & keyof AggregateStandardCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandardCost[P]>
      : GetScalarType<T[P], AggregateStandardCost[P]>
  }




  export type StandardCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardCostWhereInput
    orderBy?: StandardCostOrderByWithAggregationInput | StandardCostOrderByWithAggregationInput[]
    by: StandardCostScalarFieldEnum[] | StandardCostScalarFieldEnum
    having?: StandardCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardCostCountAggregateInputType | true
    _avg?: StandardCostAvgAggregateInputType
    _sum?: StandardCostSumAggregateInputType
    _min?: StandardCostMinAggregateInputType
    _max?: StandardCostMaxAggregateInputType
  }

  export type StandardCostGroupByOutputType = {
    id: number
    itemName: string
    description: string | null
    costPerUnit: Decimal
    currency: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdById: number | null
    updatedById: number | null
    _count: StandardCostCountAggregateOutputType | null
    _avg: StandardCostAvgAggregateOutputType | null
    _sum: StandardCostSumAggregateOutputType | null
    _min: StandardCostMinAggregateOutputType | null
    _max: StandardCostMaxAggregateOutputType | null
  }

  type GetStandardCostGroupByPayload<T extends StandardCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardCostGroupByOutputType[P]>
            : GetScalarType<T[P], StandardCostGroupByOutputType[P]>
        }
      >
    >


  export type StandardCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemName?: boolean
    description?: boolean
    costPerUnit?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }, ExtArgs["result"]["standardCost"]>


  export type StandardCostSelectScalar = {
    id?: boolean
    itemName?: boolean
    description?: boolean
    costPerUnit?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }


  export type $StandardCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StandardCost"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemName: string
      description: string | null
      costPerUnit: Prisma.Decimal
      currency: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdById: number | null
      updatedById: number | null
    }, ExtArgs["result"]["standardCost"]>
    composites: {}
  }

  type StandardCostGetPayload<S extends boolean | null | undefined | StandardCostDefaultArgs> = $Result.GetResult<Prisma.$StandardCostPayload, S>

  type StandardCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StandardCostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StandardCostCountAggregateInputType | true
    }

  export interface StandardCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StandardCost'], meta: { name: 'StandardCost' } }
    /**
     * Find zero or one StandardCost that matches the filter.
     * @param {StandardCostFindUniqueArgs} args - Arguments to find a StandardCost
     * @example
     * // Get one StandardCost
     * const standardCost = await prisma.standardCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandardCostFindUniqueArgs>(args: SelectSubset<T, StandardCostFindUniqueArgs<ExtArgs>>): Prisma__StandardCostClient<$Result.GetResult<Prisma.$StandardCostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StandardCost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StandardCostFindUniqueOrThrowArgs} args - Arguments to find a StandardCost
     * @example
     * // Get one StandardCost
     * const standardCost = await prisma.standardCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandardCostFindUniqueOrThrowArgs>(args: SelectSubset<T, StandardCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandardCostClient<$Result.GetResult<Prisma.$StandardCostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StandardCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCostFindFirstArgs} args - Arguments to find a StandardCost
     * @example
     * // Get one StandardCost
     * const standardCost = await prisma.standardCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandardCostFindFirstArgs>(args?: SelectSubset<T, StandardCostFindFirstArgs<ExtArgs>>): Prisma__StandardCostClient<$Result.GetResult<Prisma.$StandardCostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StandardCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCostFindFirstOrThrowArgs} args - Arguments to find a StandardCost
     * @example
     * // Get one StandardCost
     * const standardCost = await prisma.standardCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandardCostFindFirstOrThrowArgs>(args?: SelectSubset<T, StandardCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandardCostClient<$Result.GetResult<Prisma.$StandardCostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StandardCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StandardCosts
     * const standardCosts = await prisma.standardCost.findMany()
     * 
     * // Get first 10 StandardCosts
     * const standardCosts = await prisma.standardCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const standardCostWithIdOnly = await prisma.standardCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StandardCostFindManyArgs>(args?: SelectSubset<T, StandardCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardCostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StandardCost.
     * @param {StandardCostCreateArgs} args - Arguments to create a StandardCost.
     * @example
     * // Create one StandardCost
     * const StandardCost = await prisma.standardCost.create({
     *   data: {
     *     // ... data to create a StandardCost
     *   }
     * })
     * 
     */
    create<T extends StandardCostCreateArgs>(args: SelectSubset<T, StandardCostCreateArgs<ExtArgs>>): Prisma__StandardCostClient<$Result.GetResult<Prisma.$StandardCostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StandardCosts.
     * @param {StandardCostCreateManyArgs} args - Arguments to create many StandardCosts.
     * @example
     * // Create many StandardCosts
     * const standardCost = await prisma.standardCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandardCostCreateManyArgs>(args?: SelectSubset<T, StandardCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StandardCost.
     * @param {StandardCostDeleteArgs} args - Arguments to delete one StandardCost.
     * @example
     * // Delete one StandardCost
     * const StandardCost = await prisma.standardCost.delete({
     *   where: {
     *     // ... filter to delete one StandardCost
     *   }
     * })
     * 
     */
    delete<T extends StandardCostDeleteArgs>(args: SelectSubset<T, StandardCostDeleteArgs<ExtArgs>>): Prisma__StandardCostClient<$Result.GetResult<Prisma.$StandardCostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StandardCost.
     * @param {StandardCostUpdateArgs} args - Arguments to update one StandardCost.
     * @example
     * // Update one StandardCost
     * const standardCost = await prisma.standardCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandardCostUpdateArgs>(args: SelectSubset<T, StandardCostUpdateArgs<ExtArgs>>): Prisma__StandardCostClient<$Result.GetResult<Prisma.$StandardCostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StandardCosts.
     * @param {StandardCostDeleteManyArgs} args - Arguments to filter StandardCosts to delete.
     * @example
     * // Delete a few StandardCosts
     * const { count } = await prisma.standardCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandardCostDeleteManyArgs>(args?: SelectSubset<T, StandardCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StandardCosts
     * const standardCost = await prisma.standardCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandardCostUpdateManyArgs>(args: SelectSubset<T, StandardCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StandardCost.
     * @param {StandardCostUpsertArgs} args - Arguments to update or create a StandardCost.
     * @example
     * // Update or create a StandardCost
     * const standardCost = await prisma.standardCost.upsert({
     *   create: {
     *     // ... data to create a StandardCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StandardCost we want to update
     *   }
     * })
     */
    upsert<T extends StandardCostUpsertArgs>(args: SelectSubset<T, StandardCostUpsertArgs<ExtArgs>>): Prisma__StandardCostClient<$Result.GetResult<Prisma.$StandardCostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StandardCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCostCountArgs} args - Arguments to filter StandardCosts to count.
     * @example
     * // Count the number of StandardCosts
     * const count = await prisma.standardCost.count({
     *   where: {
     *     // ... the filter for the StandardCosts we want to count
     *   }
     * })
    **/
    count<T extends StandardCostCountArgs>(
      args?: Subset<T, StandardCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StandardCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardCostAggregateArgs>(args: Subset<T, StandardCostAggregateArgs>): Prisma.PrismaPromise<GetStandardCostAggregateType<T>>

    /**
     * Group by StandardCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandardCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandardCostGroupByArgs['orderBy'] }
        : { orderBy?: StandardCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandardCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StandardCost model
   */
  readonly fields: StandardCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StandardCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandardCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StandardCost model
   */ 
  interface StandardCostFieldRefs {
    readonly id: FieldRef<"StandardCost", 'Int'>
    readonly itemName: FieldRef<"StandardCost", 'String'>
    readonly description: FieldRef<"StandardCost", 'String'>
    readonly costPerUnit: FieldRef<"StandardCost", 'Decimal'>
    readonly currency: FieldRef<"StandardCost", 'String'>
    readonly isActive: FieldRef<"StandardCost", 'Boolean'>
    readonly createdAt: FieldRef<"StandardCost", 'DateTime'>
    readonly updatedAt: FieldRef<"StandardCost", 'DateTime'>
    readonly createdById: FieldRef<"StandardCost", 'Int'>
    readonly updatedById: FieldRef<"StandardCost", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StandardCost findUnique
   */
  export type StandardCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCost
     */
    select?: StandardCostSelect<ExtArgs> | null
    /**
     * Filter, which StandardCost to fetch.
     */
    where: StandardCostWhereUniqueInput
  }

  /**
   * StandardCost findUniqueOrThrow
   */
  export type StandardCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCost
     */
    select?: StandardCostSelect<ExtArgs> | null
    /**
     * Filter, which StandardCost to fetch.
     */
    where: StandardCostWhereUniqueInput
  }

  /**
   * StandardCost findFirst
   */
  export type StandardCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCost
     */
    select?: StandardCostSelect<ExtArgs> | null
    /**
     * Filter, which StandardCost to fetch.
     */
    where?: StandardCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCosts to fetch.
     */
    orderBy?: StandardCostOrderByWithRelationInput | StandardCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardCosts.
     */
    cursor?: StandardCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardCosts.
     */
    distinct?: StandardCostScalarFieldEnum | StandardCostScalarFieldEnum[]
  }

  /**
   * StandardCost findFirstOrThrow
   */
  export type StandardCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCost
     */
    select?: StandardCostSelect<ExtArgs> | null
    /**
     * Filter, which StandardCost to fetch.
     */
    where?: StandardCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCosts to fetch.
     */
    orderBy?: StandardCostOrderByWithRelationInput | StandardCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardCosts.
     */
    cursor?: StandardCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardCosts.
     */
    distinct?: StandardCostScalarFieldEnum | StandardCostScalarFieldEnum[]
  }

  /**
   * StandardCost findMany
   */
  export type StandardCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCost
     */
    select?: StandardCostSelect<ExtArgs> | null
    /**
     * Filter, which StandardCosts to fetch.
     */
    where?: StandardCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCosts to fetch.
     */
    orderBy?: StandardCostOrderByWithRelationInput | StandardCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StandardCosts.
     */
    cursor?: StandardCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCosts.
     */
    skip?: number
    distinct?: StandardCostScalarFieldEnum | StandardCostScalarFieldEnum[]
  }

  /**
   * StandardCost create
   */
  export type StandardCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCost
     */
    select?: StandardCostSelect<ExtArgs> | null
    /**
     * The data needed to create a StandardCost.
     */
    data: XOR<StandardCostCreateInput, StandardCostUncheckedCreateInput>
  }

  /**
   * StandardCost createMany
   */
  export type StandardCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StandardCosts.
     */
    data: StandardCostCreateManyInput | StandardCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StandardCost update
   */
  export type StandardCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCost
     */
    select?: StandardCostSelect<ExtArgs> | null
    /**
     * The data needed to update a StandardCost.
     */
    data: XOR<StandardCostUpdateInput, StandardCostUncheckedUpdateInput>
    /**
     * Choose, which StandardCost to update.
     */
    where: StandardCostWhereUniqueInput
  }

  /**
   * StandardCost updateMany
   */
  export type StandardCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StandardCosts.
     */
    data: XOR<StandardCostUpdateManyMutationInput, StandardCostUncheckedUpdateManyInput>
    /**
     * Filter which StandardCosts to update
     */
    where?: StandardCostWhereInput
  }

  /**
   * StandardCost upsert
   */
  export type StandardCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCost
     */
    select?: StandardCostSelect<ExtArgs> | null
    /**
     * The filter to search for the StandardCost to update in case it exists.
     */
    where: StandardCostWhereUniqueInput
    /**
     * In case the StandardCost found by the `where` argument doesn't exist, create a new StandardCost with this data.
     */
    create: XOR<StandardCostCreateInput, StandardCostUncheckedCreateInput>
    /**
     * In case the StandardCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandardCostUpdateInput, StandardCostUncheckedUpdateInput>
  }

  /**
   * StandardCost delete
   */
  export type StandardCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCost
     */
    select?: StandardCostSelect<ExtArgs> | null
    /**
     * Filter which StandardCost to delete.
     */
    where: StandardCostWhereUniqueInput
  }

  /**
   * StandardCost deleteMany
   */
  export type StandardCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardCosts to delete
     */
    where?: StandardCostWhereInput
  }

  /**
   * StandardCost without action
   */
  export type StandardCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCost
     */
    select?: StandardCostSelect<ExtArgs> | null
  }


  /**
   * Model OperationDefect
   */

  export type AggregateOperationDefect = {
    _count: OperationDefectCountAggregateOutputType | null
    _avg: OperationDefectAvgAggregateOutputType | null
    _sum: OperationDefectSumAggregateOutputType | null
    _min: OperationDefectMinAggregateOutputType | null
    _max: OperationDefectMaxAggregateOutputType | null
  }

  export type OperationDefectAvgAggregateOutputType = {
    id: number | null
    operationId: number | null
    defectId: number | null
    quantity: number | null
    quantityRework: number | null
    quantityNogood: number | null
    quantityReplacement: number | null
    recordedById: number | null
  }

  export type OperationDefectSumAggregateOutputType = {
    id: number | null
    operationId: number | null
    defectId: number | null
    quantity: number | null
    quantityRework: number | null
    quantityNogood: number | null
    quantityReplacement: number | null
    recordedById: number | null
  }

  export type OperationDefectMinAggregateOutputType = {
    id: number | null
    operationId: number | null
    defectId: number | null
    defectName: string | null
    defectCategory: string | null
    defectMachine: string | null
    defectReworkable: boolean | null
    quantity: number | null
    quantityRework: number | null
    quantityNogood: number | null
    quantityReplacement: number | null
    recordedAt: Date | null
    recordedById: number | null
  }

  export type OperationDefectMaxAggregateOutputType = {
    id: number | null
    operationId: number | null
    defectId: number | null
    defectName: string | null
    defectCategory: string | null
    defectMachine: string | null
    defectReworkable: boolean | null
    quantity: number | null
    quantityRework: number | null
    quantityNogood: number | null
    quantityReplacement: number | null
    recordedAt: Date | null
    recordedById: number | null
  }

  export type OperationDefectCountAggregateOutputType = {
    id: number
    operationId: number
    defectId: number
    defectName: number
    defectCategory: number
    defectMachine: number
    defectReworkable: number
    quantity: number
    quantityRework: number
    quantityNogood: number
    quantityReplacement: number
    recordedAt: number
    recordedById: number
    _all: number
  }


  export type OperationDefectAvgAggregateInputType = {
    id?: true
    operationId?: true
    defectId?: true
    quantity?: true
    quantityRework?: true
    quantityNogood?: true
    quantityReplacement?: true
    recordedById?: true
  }

  export type OperationDefectSumAggregateInputType = {
    id?: true
    operationId?: true
    defectId?: true
    quantity?: true
    quantityRework?: true
    quantityNogood?: true
    quantityReplacement?: true
    recordedById?: true
  }

  export type OperationDefectMinAggregateInputType = {
    id?: true
    operationId?: true
    defectId?: true
    defectName?: true
    defectCategory?: true
    defectMachine?: true
    defectReworkable?: true
    quantity?: true
    quantityRework?: true
    quantityNogood?: true
    quantityReplacement?: true
    recordedAt?: true
    recordedById?: true
  }

  export type OperationDefectMaxAggregateInputType = {
    id?: true
    operationId?: true
    defectId?: true
    defectName?: true
    defectCategory?: true
    defectMachine?: true
    defectReworkable?: true
    quantity?: true
    quantityRework?: true
    quantityNogood?: true
    quantityReplacement?: true
    recordedAt?: true
    recordedById?: true
  }

  export type OperationDefectCountAggregateInputType = {
    id?: true
    operationId?: true
    defectId?: true
    defectName?: true
    defectCategory?: true
    defectMachine?: true
    defectReworkable?: true
    quantity?: true
    quantityRework?: true
    quantityNogood?: true
    quantityReplacement?: true
    recordedAt?: true
    recordedById?: true
    _all?: true
  }

  export type OperationDefectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationDefect to aggregate.
     */
    where?: OperationDefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationDefects to fetch.
     */
    orderBy?: OperationDefectOrderByWithRelationInput | OperationDefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationDefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationDefects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationDefects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationDefects
    **/
    _count?: true | OperationDefectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationDefectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationDefectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationDefectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationDefectMaxAggregateInputType
  }

  export type GetOperationDefectAggregateType<T extends OperationDefectAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationDefect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationDefect[P]>
      : GetScalarType<T[P], AggregateOperationDefect[P]>
  }




  export type OperationDefectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationDefectWhereInput
    orderBy?: OperationDefectOrderByWithAggregationInput | OperationDefectOrderByWithAggregationInput[]
    by: OperationDefectScalarFieldEnum[] | OperationDefectScalarFieldEnum
    having?: OperationDefectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationDefectCountAggregateInputType | true
    _avg?: OperationDefectAvgAggregateInputType
    _sum?: OperationDefectSumAggregateInputType
    _min?: OperationDefectMinAggregateInputType
    _max?: OperationDefectMaxAggregateInputType
  }

  export type OperationDefectGroupByOutputType = {
    id: number
    operationId: number
    defectId: number | null
    defectName: string | null
    defectCategory: string
    defectMachine: string | null
    defectReworkable: boolean
    quantity: number
    quantityRework: number
    quantityNogood: number
    quantityReplacement: number
    recordedAt: Date
    recordedById: number
    _count: OperationDefectCountAggregateOutputType | null
    _avg: OperationDefectAvgAggregateOutputType | null
    _sum: OperationDefectSumAggregateOutputType | null
    _min: OperationDefectMinAggregateOutputType | null
    _max: OperationDefectMaxAggregateOutputType | null
  }

  type GetOperationDefectGroupByPayload<T extends OperationDefectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationDefectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationDefectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationDefectGroupByOutputType[P]>
            : GetScalarType<T[P], OperationDefectGroupByOutputType[P]>
        }
      >
    >


  export type OperationDefectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operationId?: boolean
    defectId?: boolean
    defectName?: boolean
    defectCategory?: boolean
    defectMachine?: boolean
    defectReworkable?: boolean
    quantity?: boolean
    quantityRework?: boolean
    quantityNogood?: boolean
    quantityReplacement?: boolean
    recordedAt?: boolean
    recordedById?: boolean
    editRequests?: boolean | OperationDefect$editRequestsArgs<ExtArgs>
    defect?: boolean | OperationDefect$defectArgs<ExtArgs>
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    recordedBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OperationDefectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationDefect"]>


  export type OperationDefectSelectScalar = {
    id?: boolean
    operationId?: boolean
    defectId?: boolean
    defectName?: boolean
    defectCategory?: boolean
    defectMachine?: boolean
    defectReworkable?: boolean
    quantity?: boolean
    quantityRework?: boolean
    quantityNogood?: boolean
    quantityReplacement?: boolean
    recordedAt?: boolean
    recordedById?: boolean
  }

  export type OperationDefectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    editRequests?: boolean | OperationDefect$editRequestsArgs<ExtArgs>
    defect?: boolean | OperationDefect$defectArgs<ExtArgs>
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    recordedBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OperationDefectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OperationDefectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationDefect"
    objects: {
      editRequests: Prisma.$OperationDefectEditRequestPayload<ExtArgs>[]
      defect: Prisma.$MasterDefectPayload<ExtArgs> | null
      operation: Prisma.$OperationPayload<ExtArgs>
      recordedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      operationId: number
      defectId: number | null
      defectName: string | null
      defectCategory: string
      defectMachine: string | null
      defectReworkable: boolean
      quantity: number
      quantityRework: number
      quantityNogood: number
      quantityReplacement: number
      recordedAt: Date
      recordedById: number
    }, ExtArgs["result"]["operationDefect"]>
    composites: {}
  }

  type OperationDefectGetPayload<S extends boolean | null | undefined | OperationDefectDefaultArgs> = $Result.GetResult<Prisma.$OperationDefectPayload, S>

  type OperationDefectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationDefectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationDefectCountAggregateInputType | true
    }

  export interface OperationDefectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationDefect'], meta: { name: 'OperationDefect' } }
    /**
     * Find zero or one OperationDefect that matches the filter.
     * @param {OperationDefectFindUniqueArgs} args - Arguments to find a OperationDefect
     * @example
     * // Get one OperationDefect
     * const operationDefect = await prisma.operationDefect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationDefectFindUniqueArgs>(args: SelectSubset<T, OperationDefectFindUniqueArgs<ExtArgs>>): Prisma__OperationDefectClient<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OperationDefect that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationDefectFindUniqueOrThrowArgs} args - Arguments to find a OperationDefect
     * @example
     * // Get one OperationDefect
     * const operationDefect = await prisma.operationDefect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationDefectFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationDefectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationDefectClient<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OperationDefect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectFindFirstArgs} args - Arguments to find a OperationDefect
     * @example
     * // Get one OperationDefect
     * const operationDefect = await prisma.operationDefect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationDefectFindFirstArgs>(args?: SelectSubset<T, OperationDefectFindFirstArgs<ExtArgs>>): Prisma__OperationDefectClient<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OperationDefect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectFindFirstOrThrowArgs} args - Arguments to find a OperationDefect
     * @example
     * // Get one OperationDefect
     * const operationDefect = await prisma.operationDefect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationDefectFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationDefectFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationDefectClient<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OperationDefects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationDefects
     * const operationDefects = await prisma.operationDefect.findMany()
     * 
     * // Get first 10 OperationDefects
     * const operationDefects = await prisma.operationDefect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationDefectWithIdOnly = await prisma.operationDefect.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperationDefectFindManyArgs>(args?: SelectSubset<T, OperationDefectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OperationDefect.
     * @param {OperationDefectCreateArgs} args - Arguments to create a OperationDefect.
     * @example
     * // Create one OperationDefect
     * const OperationDefect = await prisma.operationDefect.create({
     *   data: {
     *     // ... data to create a OperationDefect
     *   }
     * })
     * 
     */
    create<T extends OperationDefectCreateArgs>(args: SelectSubset<T, OperationDefectCreateArgs<ExtArgs>>): Prisma__OperationDefectClient<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OperationDefects.
     * @param {OperationDefectCreateManyArgs} args - Arguments to create many OperationDefects.
     * @example
     * // Create many OperationDefects
     * const operationDefect = await prisma.operationDefect.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationDefectCreateManyArgs>(args?: SelectSubset<T, OperationDefectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OperationDefect.
     * @param {OperationDefectDeleteArgs} args - Arguments to delete one OperationDefect.
     * @example
     * // Delete one OperationDefect
     * const OperationDefect = await prisma.operationDefect.delete({
     *   where: {
     *     // ... filter to delete one OperationDefect
     *   }
     * })
     * 
     */
    delete<T extends OperationDefectDeleteArgs>(args: SelectSubset<T, OperationDefectDeleteArgs<ExtArgs>>): Prisma__OperationDefectClient<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OperationDefect.
     * @param {OperationDefectUpdateArgs} args - Arguments to update one OperationDefect.
     * @example
     * // Update one OperationDefect
     * const operationDefect = await prisma.operationDefect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationDefectUpdateArgs>(args: SelectSubset<T, OperationDefectUpdateArgs<ExtArgs>>): Prisma__OperationDefectClient<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OperationDefects.
     * @param {OperationDefectDeleteManyArgs} args - Arguments to filter OperationDefects to delete.
     * @example
     * // Delete a few OperationDefects
     * const { count } = await prisma.operationDefect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationDefectDeleteManyArgs>(args?: SelectSubset<T, OperationDefectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationDefects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationDefects
     * const operationDefect = await prisma.operationDefect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationDefectUpdateManyArgs>(args: SelectSubset<T, OperationDefectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationDefect.
     * @param {OperationDefectUpsertArgs} args - Arguments to update or create a OperationDefect.
     * @example
     * // Update or create a OperationDefect
     * const operationDefect = await prisma.operationDefect.upsert({
     *   create: {
     *     // ... data to create a OperationDefect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationDefect we want to update
     *   }
     * })
     */
    upsert<T extends OperationDefectUpsertArgs>(args: SelectSubset<T, OperationDefectUpsertArgs<ExtArgs>>): Prisma__OperationDefectClient<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OperationDefects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectCountArgs} args - Arguments to filter OperationDefects to count.
     * @example
     * // Count the number of OperationDefects
     * const count = await prisma.operationDefect.count({
     *   where: {
     *     // ... the filter for the OperationDefects we want to count
     *   }
     * })
    **/
    count<T extends OperationDefectCountArgs>(
      args?: Subset<T, OperationDefectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationDefectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationDefect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationDefectAggregateArgs>(args: Subset<T, OperationDefectAggregateArgs>): Prisma.PrismaPromise<GetOperationDefectAggregateType<T>>

    /**
     * Group by OperationDefect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationDefectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationDefectGroupByArgs['orderBy'] }
        : { orderBy?: OperationDefectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationDefectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationDefectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationDefect model
   */
  readonly fields: OperationDefectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationDefect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationDefectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    editRequests<T extends OperationDefect$editRequestsArgs<ExtArgs> = {}>(args?: Subset<T, OperationDefect$editRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "findMany"> | Null>
    defect<T extends OperationDefect$defectArgs<ExtArgs> = {}>(args?: Subset<T, OperationDefect$defectArgs<ExtArgs>>): Prisma__MasterDefectClient<$Result.GetResult<Prisma.$MasterDefectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    operation<T extends OperationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperationDefaultArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    recordedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperationDefect model
   */ 
  interface OperationDefectFieldRefs {
    readonly id: FieldRef<"OperationDefect", 'Int'>
    readonly operationId: FieldRef<"OperationDefect", 'Int'>
    readonly defectId: FieldRef<"OperationDefect", 'Int'>
    readonly defectName: FieldRef<"OperationDefect", 'String'>
    readonly defectCategory: FieldRef<"OperationDefect", 'String'>
    readonly defectMachine: FieldRef<"OperationDefect", 'String'>
    readonly defectReworkable: FieldRef<"OperationDefect", 'Boolean'>
    readonly quantity: FieldRef<"OperationDefect", 'Int'>
    readonly quantityRework: FieldRef<"OperationDefect", 'Int'>
    readonly quantityNogood: FieldRef<"OperationDefect", 'Int'>
    readonly quantityReplacement: FieldRef<"OperationDefect", 'Int'>
    readonly recordedAt: FieldRef<"OperationDefect", 'DateTime'>
    readonly recordedById: FieldRef<"OperationDefect", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OperationDefect findUnique
   */
  export type OperationDefectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    /**
     * Filter, which OperationDefect to fetch.
     */
    where: OperationDefectWhereUniqueInput
  }

  /**
   * OperationDefect findUniqueOrThrow
   */
  export type OperationDefectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    /**
     * Filter, which OperationDefect to fetch.
     */
    where: OperationDefectWhereUniqueInput
  }

  /**
   * OperationDefect findFirst
   */
  export type OperationDefectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    /**
     * Filter, which OperationDefect to fetch.
     */
    where?: OperationDefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationDefects to fetch.
     */
    orderBy?: OperationDefectOrderByWithRelationInput | OperationDefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationDefects.
     */
    cursor?: OperationDefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationDefects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationDefects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationDefects.
     */
    distinct?: OperationDefectScalarFieldEnum | OperationDefectScalarFieldEnum[]
  }

  /**
   * OperationDefect findFirstOrThrow
   */
  export type OperationDefectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    /**
     * Filter, which OperationDefect to fetch.
     */
    where?: OperationDefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationDefects to fetch.
     */
    orderBy?: OperationDefectOrderByWithRelationInput | OperationDefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationDefects.
     */
    cursor?: OperationDefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationDefects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationDefects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationDefects.
     */
    distinct?: OperationDefectScalarFieldEnum | OperationDefectScalarFieldEnum[]
  }

  /**
   * OperationDefect findMany
   */
  export type OperationDefectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    /**
     * Filter, which OperationDefects to fetch.
     */
    where?: OperationDefectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationDefects to fetch.
     */
    orderBy?: OperationDefectOrderByWithRelationInput | OperationDefectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationDefects.
     */
    cursor?: OperationDefectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationDefects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationDefects.
     */
    skip?: number
    distinct?: OperationDefectScalarFieldEnum | OperationDefectScalarFieldEnum[]
  }

  /**
   * OperationDefect create
   */
  export type OperationDefectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    /**
     * The data needed to create a OperationDefect.
     */
    data: XOR<OperationDefectCreateInput, OperationDefectUncheckedCreateInput>
  }

  /**
   * OperationDefect createMany
   */
  export type OperationDefectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationDefects.
     */
    data: OperationDefectCreateManyInput | OperationDefectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationDefect update
   */
  export type OperationDefectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    /**
     * The data needed to update a OperationDefect.
     */
    data: XOR<OperationDefectUpdateInput, OperationDefectUncheckedUpdateInput>
    /**
     * Choose, which OperationDefect to update.
     */
    where: OperationDefectWhereUniqueInput
  }

  /**
   * OperationDefect updateMany
   */
  export type OperationDefectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationDefects.
     */
    data: XOR<OperationDefectUpdateManyMutationInput, OperationDefectUncheckedUpdateManyInput>
    /**
     * Filter which OperationDefects to update
     */
    where?: OperationDefectWhereInput
  }

  /**
   * OperationDefect upsert
   */
  export type OperationDefectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    /**
     * The filter to search for the OperationDefect to update in case it exists.
     */
    where: OperationDefectWhereUniqueInput
    /**
     * In case the OperationDefect found by the `where` argument doesn't exist, create a new OperationDefect with this data.
     */
    create: XOR<OperationDefectCreateInput, OperationDefectUncheckedCreateInput>
    /**
     * In case the OperationDefect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationDefectUpdateInput, OperationDefectUncheckedUpdateInput>
  }

  /**
   * OperationDefect delete
   */
  export type OperationDefectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    /**
     * Filter which OperationDefect to delete.
     */
    where: OperationDefectWhereUniqueInput
  }

  /**
   * OperationDefect deleteMany
   */
  export type OperationDefectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationDefects to delete
     */
    where?: OperationDefectWhereInput
  }

  /**
   * OperationDefect.editRequests
   */
  export type OperationDefect$editRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    where?: OperationDefectEditRequestWhereInput
    orderBy?: OperationDefectEditRequestOrderByWithRelationInput | OperationDefectEditRequestOrderByWithRelationInput[]
    cursor?: OperationDefectEditRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationDefectEditRequestScalarFieldEnum | OperationDefectEditRequestScalarFieldEnum[]
  }

  /**
   * OperationDefect.defect
   */
  export type OperationDefect$defectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterDefect
     */
    select?: MasterDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterDefectInclude<ExtArgs> | null
    where?: MasterDefectWhereInput
  }

  /**
   * OperationDefect without action
   */
  export type OperationDefectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
  }


  /**
   * Model OperationDefectEditRequest
   */

  export type AggregateOperationDefectEditRequest = {
    _count: OperationDefectEditRequestCountAggregateOutputType | null
    _avg: OperationDefectEditRequestAvgAggregateOutputType | null
    _sum: OperationDefectEditRequestSumAggregateOutputType | null
    _min: OperationDefectEditRequestMinAggregateOutputType | null
    _max: OperationDefectEditRequestMaxAggregateOutputType | null
  }

  export type OperationDefectEditRequestAvgAggregateOutputType = {
    id: number | null
    operationDefectId: number | null
    operationId: number | null
    productionOrderId: number | null
    requestedById: number | null
    defectId: number | null
    currentQty: number | null
    currentRw: number | null
    currentNg: number | null
    currentReplacement: number | null
    requestedQty: number | null
    requestedRw: number | null
    requestedNg: number | null
    requestedReplacement: number | null
    resolvedById: number | null
  }

  export type OperationDefectEditRequestSumAggregateOutputType = {
    id: number | null
    operationDefectId: number | null
    operationId: number | null
    productionOrderId: number | null
    requestedById: number | null
    defectId: number | null
    currentQty: number | null
    currentRw: number | null
    currentNg: number | null
    currentReplacement: number | null
    requestedQty: number | null
    requestedRw: number | null
    requestedNg: number | null
    requestedReplacement: number | null
    resolvedById: number | null
  }

  export type OperationDefectEditRequestMinAggregateOutputType = {
    id: number | null
    operationDefectId: number | null
    operationId: number | null
    productionOrderId: number | null
    requestedById: number | null
    requestType: string | null
    defectId: number | null
    defectName: string | null
    defectCategory: string | null
    defectReworkable: boolean | null
    defectMachine: string | null
    currentQty: number | null
    currentRw: number | null
    currentNg: number | null
    currentReplacement: number | null
    requestedQty: number | null
    requestedRw: number | null
    requestedNg: number | null
    requestedReplacement: number | null
    operationCode: string | null
    reason: string | null
    status: string | null
    resolvedById: number | null
    resolutionNote: string | null
    createdAt: Date | null
    resolvedAt: Date | null
  }

  export type OperationDefectEditRequestMaxAggregateOutputType = {
    id: number | null
    operationDefectId: number | null
    operationId: number | null
    productionOrderId: number | null
    requestedById: number | null
    requestType: string | null
    defectId: number | null
    defectName: string | null
    defectCategory: string | null
    defectReworkable: boolean | null
    defectMachine: string | null
    currentQty: number | null
    currentRw: number | null
    currentNg: number | null
    currentReplacement: number | null
    requestedQty: number | null
    requestedRw: number | null
    requestedNg: number | null
    requestedReplacement: number | null
    operationCode: string | null
    reason: string | null
    status: string | null
    resolvedById: number | null
    resolutionNote: string | null
    createdAt: Date | null
    resolvedAt: Date | null
  }

  export type OperationDefectEditRequestCountAggregateOutputType = {
    id: number
    operationDefectId: number
    operationId: number
    productionOrderId: number
    requestedById: number
    requestType: number
    defectId: number
    defectName: number
    defectCategory: number
    defectReworkable: number
    defectMachine: number
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement: number
    operationCode: number
    reason: number
    status: number
    resolvedById: number
    resolutionNote: number
    createdAt: number
    resolvedAt: number
    _all: number
  }


  export type OperationDefectEditRequestAvgAggregateInputType = {
    id?: true
    operationDefectId?: true
    operationId?: true
    productionOrderId?: true
    requestedById?: true
    defectId?: true
    currentQty?: true
    currentRw?: true
    currentNg?: true
    currentReplacement?: true
    requestedQty?: true
    requestedRw?: true
    requestedNg?: true
    requestedReplacement?: true
    resolvedById?: true
  }

  export type OperationDefectEditRequestSumAggregateInputType = {
    id?: true
    operationDefectId?: true
    operationId?: true
    productionOrderId?: true
    requestedById?: true
    defectId?: true
    currentQty?: true
    currentRw?: true
    currentNg?: true
    currentReplacement?: true
    requestedQty?: true
    requestedRw?: true
    requestedNg?: true
    requestedReplacement?: true
    resolvedById?: true
  }

  export type OperationDefectEditRequestMinAggregateInputType = {
    id?: true
    operationDefectId?: true
    operationId?: true
    productionOrderId?: true
    requestedById?: true
    requestType?: true
    defectId?: true
    defectName?: true
    defectCategory?: true
    defectReworkable?: true
    defectMachine?: true
    currentQty?: true
    currentRw?: true
    currentNg?: true
    currentReplacement?: true
    requestedQty?: true
    requestedRw?: true
    requestedNg?: true
    requestedReplacement?: true
    operationCode?: true
    reason?: true
    status?: true
    resolvedById?: true
    resolutionNote?: true
    createdAt?: true
    resolvedAt?: true
  }

  export type OperationDefectEditRequestMaxAggregateInputType = {
    id?: true
    operationDefectId?: true
    operationId?: true
    productionOrderId?: true
    requestedById?: true
    requestType?: true
    defectId?: true
    defectName?: true
    defectCategory?: true
    defectReworkable?: true
    defectMachine?: true
    currentQty?: true
    currentRw?: true
    currentNg?: true
    currentReplacement?: true
    requestedQty?: true
    requestedRw?: true
    requestedNg?: true
    requestedReplacement?: true
    operationCode?: true
    reason?: true
    status?: true
    resolvedById?: true
    resolutionNote?: true
    createdAt?: true
    resolvedAt?: true
  }

  export type OperationDefectEditRequestCountAggregateInputType = {
    id?: true
    operationDefectId?: true
    operationId?: true
    productionOrderId?: true
    requestedById?: true
    requestType?: true
    defectId?: true
    defectName?: true
    defectCategory?: true
    defectReworkable?: true
    defectMachine?: true
    currentQty?: true
    currentRw?: true
    currentNg?: true
    currentReplacement?: true
    requestedQty?: true
    requestedRw?: true
    requestedNg?: true
    requestedReplacement?: true
    operationCode?: true
    reason?: true
    status?: true
    resolvedById?: true
    resolutionNote?: true
    createdAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type OperationDefectEditRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationDefectEditRequest to aggregate.
     */
    where?: OperationDefectEditRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationDefectEditRequests to fetch.
     */
    orderBy?: OperationDefectEditRequestOrderByWithRelationInput | OperationDefectEditRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationDefectEditRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationDefectEditRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationDefectEditRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationDefectEditRequests
    **/
    _count?: true | OperationDefectEditRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationDefectEditRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationDefectEditRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationDefectEditRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationDefectEditRequestMaxAggregateInputType
  }

  export type GetOperationDefectEditRequestAggregateType<T extends OperationDefectEditRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationDefectEditRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationDefectEditRequest[P]>
      : GetScalarType<T[P], AggregateOperationDefectEditRequest[P]>
  }




  export type OperationDefectEditRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationDefectEditRequestWhereInput
    orderBy?: OperationDefectEditRequestOrderByWithAggregationInput | OperationDefectEditRequestOrderByWithAggregationInput[]
    by: OperationDefectEditRequestScalarFieldEnum[] | OperationDefectEditRequestScalarFieldEnum
    having?: OperationDefectEditRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationDefectEditRequestCountAggregateInputType | true
    _avg?: OperationDefectEditRequestAvgAggregateInputType
    _sum?: OperationDefectEditRequestSumAggregateInputType
    _min?: OperationDefectEditRequestMinAggregateInputType
    _max?: OperationDefectEditRequestMaxAggregateInputType
  }

  export type OperationDefectEditRequestGroupByOutputType = {
    id: number
    operationDefectId: number | null
    operationId: number
    productionOrderId: number
    requestedById: number
    requestType: string
    defectId: number | null
    defectName: string | null
    defectCategory: string | null
    defectReworkable: boolean | null
    defectMachine: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement: number
    operationCode: string | null
    reason: string
    status: string
    resolvedById: number | null
    resolutionNote: string | null
    createdAt: Date
    resolvedAt: Date | null
    _count: OperationDefectEditRequestCountAggregateOutputType | null
    _avg: OperationDefectEditRequestAvgAggregateOutputType | null
    _sum: OperationDefectEditRequestSumAggregateOutputType | null
    _min: OperationDefectEditRequestMinAggregateOutputType | null
    _max: OperationDefectEditRequestMaxAggregateOutputType | null
  }

  type GetOperationDefectEditRequestGroupByPayload<T extends OperationDefectEditRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationDefectEditRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationDefectEditRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationDefectEditRequestGroupByOutputType[P]>
            : GetScalarType<T[P], OperationDefectEditRequestGroupByOutputType[P]>
        }
      >
    >


  export type OperationDefectEditRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operationDefectId?: boolean
    operationId?: boolean
    productionOrderId?: boolean
    requestedById?: boolean
    requestType?: boolean
    defectId?: boolean
    defectName?: boolean
    defectCategory?: boolean
    defectReworkable?: boolean
    defectMachine?: boolean
    currentQty?: boolean
    currentRw?: boolean
    currentNg?: boolean
    currentReplacement?: boolean
    requestedQty?: boolean
    requestedRw?: boolean
    requestedNg?: boolean
    requestedReplacement?: boolean
    operationCode?: boolean
    reason?: boolean
    status?: boolean
    resolvedById?: boolean
    resolutionNote?: boolean
    createdAt?: boolean
    resolvedAt?: boolean
    operationDefect?: boolean | OperationDefectEditRequest$operationDefectArgs<ExtArgs>
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | OperationDefectEditRequest$resolvedByArgs<ExtArgs>
  }, ExtArgs["result"]["operationDefectEditRequest"]>


  export type OperationDefectEditRequestSelectScalar = {
    id?: boolean
    operationDefectId?: boolean
    operationId?: boolean
    productionOrderId?: boolean
    requestedById?: boolean
    requestType?: boolean
    defectId?: boolean
    defectName?: boolean
    defectCategory?: boolean
    defectReworkable?: boolean
    defectMachine?: boolean
    currentQty?: boolean
    currentRw?: boolean
    currentNg?: boolean
    currentReplacement?: boolean
    requestedQty?: boolean
    requestedRw?: boolean
    requestedNg?: boolean
    requestedReplacement?: boolean
    operationCode?: boolean
    reason?: boolean
    status?: boolean
    resolvedById?: boolean
    resolutionNote?: boolean
    createdAt?: boolean
    resolvedAt?: boolean
  }

  export type OperationDefectEditRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operationDefect?: boolean | OperationDefectEditRequest$operationDefectArgs<ExtArgs>
    operation?: boolean | OperationDefaultArgs<ExtArgs>
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
    requestedBy?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | OperationDefectEditRequest$resolvedByArgs<ExtArgs>
  }

  export type $OperationDefectEditRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationDefectEditRequest"
    objects: {
      operationDefect: Prisma.$OperationDefectPayload<ExtArgs> | null
      operation: Prisma.$OperationPayload<ExtArgs>
      productionOrder: Prisma.$ProductionOrderPayload<ExtArgs>
      requestedBy: Prisma.$UserPayload<ExtArgs>
      resolvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      operationDefectId: number | null
      operationId: number
      productionOrderId: number
      requestedById: number
      requestType: string
      defectId: number | null
      defectName: string | null
      defectCategory: string | null
      defectReworkable: boolean | null
      defectMachine: string | null
      currentQty: number
      currentRw: number
      currentNg: number
      currentReplacement: number
      requestedQty: number
      requestedRw: number
      requestedNg: number
      requestedReplacement: number
      operationCode: string | null
      reason: string
      status: string
      resolvedById: number | null
      resolutionNote: string | null
      createdAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["operationDefectEditRequest"]>
    composites: {}
  }

  type OperationDefectEditRequestGetPayload<S extends boolean | null | undefined | OperationDefectEditRequestDefaultArgs> = $Result.GetResult<Prisma.$OperationDefectEditRequestPayload, S>

  type OperationDefectEditRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationDefectEditRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationDefectEditRequestCountAggregateInputType | true
    }

  export interface OperationDefectEditRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationDefectEditRequest'], meta: { name: 'OperationDefectEditRequest' } }
    /**
     * Find zero or one OperationDefectEditRequest that matches the filter.
     * @param {OperationDefectEditRequestFindUniqueArgs} args - Arguments to find a OperationDefectEditRequest
     * @example
     * // Get one OperationDefectEditRequest
     * const operationDefectEditRequest = await prisma.operationDefectEditRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationDefectEditRequestFindUniqueArgs>(args: SelectSubset<T, OperationDefectEditRequestFindUniqueArgs<ExtArgs>>): Prisma__OperationDefectEditRequestClient<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OperationDefectEditRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationDefectEditRequestFindUniqueOrThrowArgs} args - Arguments to find a OperationDefectEditRequest
     * @example
     * // Get one OperationDefectEditRequest
     * const operationDefectEditRequest = await prisma.operationDefectEditRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationDefectEditRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationDefectEditRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationDefectEditRequestClient<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OperationDefectEditRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectEditRequestFindFirstArgs} args - Arguments to find a OperationDefectEditRequest
     * @example
     * // Get one OperationDefectEditRequest
     * const operationDefectEditRequest = await prisma.operationDefectEditRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationDefectEditRequestFindFirstArgs>(args?: SelectSubset<T, OperationDefectEditRequestFindFirstArgs<ExtArgs>>): Prisma__OperationDefectEditRequestClient<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OperationDefectEditRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectEditRequestFindFirstOrThrowArgs} args - Arguments to find a OperationDefectEditRequest
     * @example
     * // Get one OperationDefectEditRequest
     * const operationDefectEditRequest = await prisma.operationDefectEditRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationDefectEditRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationDefectEditRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationDefectEditRequestClient<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OperationDefectEditRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectEditRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationDefectEditRequests
     * const operationDefectEditRequests = await prisma.operationDefectEditRequest.findMany()
     * 
     * // Get first 10 OperationDefectEditRequests
     * const operationDefectEditRequests = await prisma.operationDefectEditRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationDefectEditRequestWithIdOnly = await prisma.operationDefectEditRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperationDefectEditRequestFindManyArgs>(args?: SelectSubset<T, OperationDefectEditRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OperationDefectEditRequest.
     * @param {OperationDefectEditRequestCreateArgs} args - Arguments to create a OperationDefectEditRequest.
     * @example
     * // Create one OperationDefectEditRequest
     * const OperationDefectEditRequest = await prisma.operationDefectEditRequest.create({
     *   data: {
     *     // ... data to create a OperationDefectEditRequest
     *   }
     * })
     * 
     */
    create<T extends OperationDefectEditRequestCreateArgs>(args: SelectSubset<T, OperationDefectEditRequestCreateArgs<ExtArgs>>): Prisma__OperationDefectEditRequestClient<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OperationDefectEditRequests.
     * @param {OperationDefectEditRequestCreateManyArgs} args - Arguments to create many OperationDefectEditRequests.
     * @example
     * // Create many OperationDefectEditRequests
     * const operationDefectEditRequest = await prisma.operationDefectEditRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationDefectEditRequestCreateManyArgs>(args?: SelectSubset<T, OperationDefectEditRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OperationDefectEditRequest.
     * @param {OperationDefectEditRequestDeleteArgs} args - Arguments to delete one OperationDefectEditRequest.
     * @example
     * // Delete one OperationDefectEditRequest
     * const OperationDefectEditRequest = await prisma.operationDefectEditRequest.delete({
     *   where: {
     *     // ... filter to delete one OperationDefectEditRequest
     *   }
     * })
     * 
     */
    delete<T extends OperationDefectEditRequestDeleteArgs>(args: SelectSubset<T, OperationDefectEditRequestDeleteArgs<ExtArgs>>): Prisma__OperationDefectEditRequestClient<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OperationDefectEditRequest.
     * @param {OperationDefectEditRequestUpdateArgs} args - Arguments to update one OperationDefectEditRequest.
     * @example
     * // Update one OperationDefectEditRequest
     * const operationDefectEditRequest = await prisma.operationDefectEditRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationDefectEditRequestUpdateArgs>(args: SelectSubset<T, OperationDefectEditRequestUpdateArgs<ExtArgs>>): Prisma__OperationDefectEditRequestClient<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OperationDefectEditRequests.
     * @param {OperationDefectEditRequestDeleteManyArgs} args - Arguments to filter OperationDefectEditRequests to delete.
     * @example
     * // Delete a few OperationDefectEditRequests
     * const { count } = await prisma.operationDefectEditRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationDefectEditRequestDeleteManyArgs>(args?: SelectSubset<T, OperationDefectEditRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationDefectEditRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectEditRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationDefectEditRequests
     * const operationDefectEditRequest = await prisma.operationDefectEditRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationDefectEditRequestUpdateManyArgs>(args: SelectSubset<T, OperationDefectEditRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationDefectEditRequest.
     * @param {OperationDefectEditRequestUpsertArgs} args - Arguments to update or create a OperationDefectEditRequest.
     * @example
     * // Update or create a OperationDefectEditRequest
     * const operationDefectEditRequest = await prisma.operationDefectEditRequest.upsert({
     *   create: {
     *     // ... data to create a OperationDefectEditRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationDefectEditRequest we want to update
     *   }
     * })
     */
    upsert<T extends OperationDefectEditRequestUpsertArgs>(args: SelectSubset<T, OperationDefectEditRequestUpsertArgs<ExtArgs>>): Prisma__OperationDefectEditRequestClient<$Result.GetResult<Prisma.$OperationDefectEditRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OperationDefectEditRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectEditRequestCountArgs} args - Arguments to filter OperationDefectEditRequests to count.
     * @example
     * // Count the number of OperationDefectEditRequests
     * const count = await prisma.operationDefectEditRequest.count({
     *   where: {
     *     // ... the filter for the OperationDefectEditRequests we want to count
     *   }
     * })
    **/
    count<T extends OperationDefectEditRequestCountArgs>(
      args?: Subset<T, OperationDefectEditRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationDefectEditRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationDefectEditRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectEditRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationDefectEditRequestAggregateArgs>(args: Subset<T, OperationDefectEditRequestAggregateArgs>): Prisma.PrismaPromise<GetOperationDefectEditRequestAggregateType<T>>

    /**
     * Group by OperationDefectEditRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationDefectEditRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationDefectEditRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationDefectEditRequestGroupByArgs['orderBy'] }
        : { orderBy?: OperationDefectEditRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationDefectEditRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationDefectEditRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationDefectEditRequest model
   */
  readonly fields: OperationDefectEditRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationDefectEditRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationDefectEditRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operationDefect<T extends OperationDefectEditRequest$operationDefectArgs<ExtArgs> = {}>(args?: Subset<T, OperationDefectEditRequest$operationDefectArgs<ExtArgs>>): Prisma__OperationDefectClient<$Result.GetResult<Prisma.$OperationDefectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    operation<T extends OperationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperationDefaultArgs<ExtArgs>>): Prisma__OperationClient<$Result.GetResult<Prisma.$OperationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    productionOrder<T extends ProductionOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionOrderDefaultArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    requestedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resolvedBy<T extends OperationDefectEditRequest$resolvedByArgs<ExtArgs> = {}>(args?: Subset<T, OperationDefectEditRequest$resolvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperationDefectEditRequest model
   */ 
  interface OperationDefectEditRequestFieldRefs {
    readonly id: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly operationDefectId: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly operationId: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly productionOrderId: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly requestedById: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly requestType: FieldRef<"OperationDefectEditRequest", 'String'>
    readonly defectId: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly defectName: FieldRef<"OperationDefectEditRequest", 'String'>
    readonly defectCategory: FieldRef<"OperationDefectEditRequest", 'String'>
    readonly defectReworkable: FieldRef<"OperationDefectEditRequest", 'Boolean'>
    readonly defectMachine: FieldRef<"OperationDefectEditRequest", 'String'>
    readonly currentQty: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly currentRw: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly currentNg: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly currentReplacement: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly requestedQty: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly requestedRw: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly requestedNg: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly requestedReplacement: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly operationCode: FieldRef<"OperationDefectEditRequest", 'String'>
    readonly reason: FieldRef<"OperationDefectEditRequest", 'String'>
    readonly status: FieldRef<"OperationDefectEditRequest", 'String'>
    readonly resolvedById: FieldRef<"OperationDefectEditRequest", 'Int'>
    readonly resolutionNote: FieldRef<"OperationDefectEditRequest", 'String'>
    readonly createdAt: FieldRef<"OperationDefectEditRequest", 'DateTime'>
    readonly resolvedAt: FieldRef<"OperationDefectEditRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperationDefectEditRequest findUnique
   */
  export type OperationDefectEditRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    /**
     * Filter, which OperationDefectEditRequest to fetch.
     */
    where: OperationDefectEditRequestWhereUniqueInput
  }

  /**
   * OperationDefectEditRequest findUniqueOrThrow
   */
  export type OperationDefectEditRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    /**
     * Filter, which OperationDefectEditRequest to fetch.
     */
    where: OperationDefectEditRequestWhereUniqueInput
  }

  /**
   * OperationDefectEditRequest findFirst
   */
  export type OperationDefectEditRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    /**
     * Filter, which OperationDefectEditRequest to fetch.
     */
    where?: OperationDefectEditRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationDefectEditRequests to fetch.
     */
    orderBy?: OperationDefectEditRequestOrderByWithRelationInput | OperationDefectEditRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationDefectEditRequests.
     */
    cursor?: OperationDefectEditRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationDefectEditRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationDefectEditRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationDefectEditRequests.
     */
    distinct?: OperationDefectEditRequestScalarFieldEnum | OperationDefectEditRequestScalarFieldEnum[]
  }

  /**
   * OperationDefectEditRequest findFirstOrThrow
   */
  export type OperationDefectEditRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    /**
     * Filter, which OperationDefectEditRequest to fetch.
     */
    where?: OperationDefectEditRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationDefectEditRequests to fetch.
     */
    orderBy?: OperationDefectEditRequestOrderByWithRelationInput | OperationDefectEditRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationDefectEditRequests.
     */
    cursor?: OperationDefectEditRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationDefectEditRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationDefectEditRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationDefectEditRequests.
     */
    distinct?: OperationDefectEditRequestScalarFieldEnum | OperationDefectEditRequestScalarFieldEnum[]
  }

  /**
   * OperationDefectEditRequest findMany
   */
  export type OperationDefectEditRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    /**
     * Filter, which OperationDefectEditRequests to fetch.
     */
    where?: OperationDefectEditRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationDefectEditRequests to fetch.
     */
    orderBy?: OperationDefectEditRequestOrderByWithRelationInput | OperationDefectEditRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationDefectEditRequests.
     */
    cursor?: OperationDefectEditRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationDefectEditRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationDefectEditRequests.
     */
    skip?: number
    distinct?: OperationDefectEditRequestScalarFieldEnum | OperationDefectEditRequestScalarFieldEnum[]
  }

  /**
   * OperationDefectEditRequest create
   */
  export type OperationDefectEditRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a OperationDefectEditRequest.
     */
    data: XOR<OperationDefectEditRequestCreateInput, OperationDefectEditRequestUncheckedCreateInput>
  }

  /**
   * OperationDefectEditRequest createMany
   */
  export type OperationDefectEditRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationDefectEditRequests.
     */
    data: OperationDefectEditRequestCreateManyInput | OperationDefectEditRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationDefectEditRequest update
   */
  export type OperationDefectEditRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a OperationDefectEditRequest.
     */
    data: XOR<OperationDefectEditRequestUpdateInput, OperationDefectEditRequestUncheckedUpdateInput>
    /**
     * Choose, which OperationDefectEditRequest to update.
     */
    where: OperationDefectEditRequestWhereUniqueInput
  }

  /**
   * OperationDefectEditRequest updateMany
   */
  export type OperationDefectEditRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationDefectEditRequests.
     */
    data: XOR<OperationDefectEditRequestUpdateManyMutationInput, OperationDefectEditRequestUncheckedUpdateManyInput>
    /**
     * Filter which OperationDefectEditRequests to update
     */
    where?: OperationDefectEditRequestWhereInput
  }

  /**
   * OperationDefectEditRequest upsert
   */
  export type OperationDefectEditRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the OperationDefectEditRequest to update in case it exists.
     */
    where: OperationDefectEditRequestWhereUniqueInput
    /**
     * In case the OperationDefectEditRequest found by the `where` argument doesn't exist, create a new OperationDefectEditRequest with this data.
     */
    create: XOR<OperationDefectEditRequestCreateInput, OperationDefectEditRequestUncheckedCreateInput>
    /**
     * In case the OperationDefectEditRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationDefectEditRequestUpdateInput, OperationDefectEditRequestUncheckedUpdateInput>
  }

  /**
   * OperationDefectEditRequest delete
   */
  export type OperationDefectEditRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
    /**
     * Filter which OperationDefectEditRequest to delete.
     */
    where: OperationDefectEditRequestWhereUniqueInput
  }

  /**
   * OperationDefectEditRequest deleteMany
   */
  export type OperationDefectEditRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationDefectEditRequests to delete
     */
    where?: OperationDefectEditRequestWhereInput
  }

  /**
   * OperationDefectEditRequest.operationDefect
   */
  export type OperationDefectEditRequest$operationDefectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefect
     */
    select?: OperationDefectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectInclude<ExtArgs> | null
    where?: OperationDefectWhereInput
  }

  /**
   * OperationDefectEditRequest.resolvedBy
   */
  export type OperationDefectEditRequest$resolvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * OperationDefectEditRequest without action
   */
  export type OperationDefectEditRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationDefectEditRequest
     */
    select?: OperationDefectEditRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationDefectEditRequestInclude<ExtArgs> | null
  }


  /**
   * Model OperationStep
   */

  export type AggregateOperationStep = {
    _count: OperationStepCountAggregateOutputType | null
    _avg: OperationStepAvgAggregateOutputType | null
    _sum: OperationStepSumAggregateOutputType | null
    _min: OperationStepMinAggregateOutputType | null
    _max: OperationStepMaxAggregateOutputType | null
  }

  export type OperationStepAvgAggregateOutputType = {
    id: number | null
    stepOrder: number | null
  }

  export type OperationStepSumAggregateOutputType = {
    id: number | null
    stepOrder: number | null
  }

  export type OperationStepMinAggregateOutputType = {
    id: number | null
    label: string | null
    operationNumber: string | null
    stepOrder: number | null
  }

  export type OperationStepMaxAggregateOutputType = {
    id: number | null
    label: string | null
    operationNumber: string | null
    stepOrder: number | null
  }

  export type OperationStepCountAggregateOutputType = {
    id: number
    label: number
    operationNumber: number
    stepOrder: number
    _all: number
  }


  export type OperationStepAvgAggregateInputType = {
    id?: true
    stepOrder?: true
  }

  export type OperationStepSumAggregateInputType = {
    id?: true
    stepOrder?: true
  }

  export type OperationStepMinAggregateInputType = {
    id?: true
    label?: true
    operationNumber?: true
    stepOrder?: true
  }

  export type OperationStepMaxAggregateInputType = {
    id?: true
    label?: true
    operationNumber?: true
    stepOrder?: true
  }

  export type OperationStepCountAggregateInputType = {
    id?: true
    label?: true
    operationNumber?: true
    stepOrder?: true
    _all?: true
  }

  export type OperationStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationStep to aggregate.
     */
    where?: OperationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSteps to fetch.
     */
    orderBy?: OperationStepOrderByWithRelationInput | OperationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationSteps
    **/
    _count?: true | OperationStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationStepMaxAggregateInputType
  }

  export type GetOperationStepAggregateType<T extends OperationStepAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationStep[P]>
      : GetScalarType<T[P], AggregateOperationStep[P]>
  }




  export type OperationStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationStepWhereInput
    orderBy?: OperationStepOrderByWithAggregationInput | OperationStepOrderByWithAggregationInput[]
    by: OperationStepScalarFieldEnum[] | OperationStepScalarFieldEnum
    having?: OperationStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationStepCountAggregateInputType | true
    _avg?: OperationStepAvgAggregateInputType
    _sum?: OperationStepSumAggregateInputType
    _min?: OperationStepMinAggregateInputType
    _max?: OperationStepMaxAggregateInputType
  }

  export type OperationStepGroupByOutputType = {
    id: number
    label: string
    operationNumber: string
    stepOrder: number
    _count: OperationStepCountAggregateOutputType | null
    _avg: OperationStepAvgAggregateOutputType | null
    _sum: OperationStepSumAggregateOutputType | null
    _min: OperationStepMinAggregateOutputType | null
    _max: OperationStepMaxAggregateOutputType | null
  }

  type GetOperationStepGroupByPayload<T extends OperationStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationStepGroupByOutputType[P]>
            : GetScalarType<T[P], OperationStepGroupByOutputType[P]>
        }
      >
    >


  export type OperationStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    operationNumber?: boolean
    stepOrder?: boolean
  }, ExtArgs["result"]["operationStep"]>


  export type OperationStepSelectScalar = {
    id?: boolean
    label?: boolean
    operationNumber?: boolean
    stepOrder?: boolean
  }


  export type $OperationStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationStep"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      operationNumber: string
      stepOrder: number
    }, ExtArgs["result"]["operationStep"]>
    composites: {}
  }

  type OperationStepGetPayload<S extends boolean | null | undefined | OperationStepDefaultArgs> = $Result.GetResult<Prisma.$OperationStepPayload, S>

  type OperationStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationStepCountAggregateInputType | true
    }

  export interface OperationStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationStep'], meta: { name: 'OperationStep' } }
    /**
     * Find zero or one OperationStep that matches the filter.
     * @param {OperationStepFindUniqueArgs} args - Arguments to find a OperationStep
     * @example
     * // Get one OperationStep
     * const operationStep = await prisma.operationStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationStepFindUniqueArgs>(args: SelectSubset<T, OperationStepFindUniqueArgs<ExtArgs>>): Prisma__OperationStepClient<$Result.GetResult<Prisma.$OperationStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OperationStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationStepFindUniqueOrThrowArgs} args - Arguments to find a OperationStep
     * @example
     * // Get one OperationStep
     * const operationStep = await prisma.operationStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationStepFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationStepClient<$Result.GetResult<Prisma.$OperationStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OperationStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationStepFindFirstArgs} args - Arguments to find a OperationStep
     * @example
     * // Get one OperationStep
     * const operationStep = await prisma.operationStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationStepFindFirstArgs>(args?: SelectSubset<T, OperationStepFindFirstArgs<ExtArgs>>): Prisma__OperationStepClient<$Result.GetResult<Prisma.$OperationStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OperationStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationStepFindFirstOrThrowArgs} args - Arguments to find a OperationStep
     * @example
     * // Get one OperationStep
     * const operationStep = await prisma.operationStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationStepFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationStepClient<$Result.GetResult<Prisma.$OperationStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OperationSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationSteps
     * const operationSteps = await prisma.operationStep.findMany()
     * 
     * // Get first 10 OperationSteps
     * const operationSteps = await prisma.operationStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationStepWithIdOnly = await prisma.operationStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperationStepFindManyArgs>(args?: SelectSubset<T, OperationStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OperationStep.
     * @param {OperationStepCreateArgs} args - Arguments to create a OperationStep.
     * @example
     * // Create one OperationStep
     * const OperationStep = await prisma.operationStep.create({
     *   data: {
     *     // ... data to create a OperationStep
     *   }
     * })
     * 
     */
    create<T extends OperationStepCreateArgs>(args: SelectSubset<T, OperationStepCreateArgs<ExtArgs>>): Prisma__OperationStepClient<$Result.GetResult<Prisma.$OperationStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OperationSteps.
     * @param {OperationStepCreateManyArgs} args - Arguments to create many OperationSteps.
     * @example
     * // Create many OperationSteps
     * const operationStep = await prisma.operationStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationStepCreateManyArgs>(args?: SelectSubset<T, OperationStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OperationStep.
     * @param {OperationStepDeleteArgs} args - Arguments to delete one OperationStep.
     * @example
     * // Delete one OperationStep
     * const OperationStep = await prisma.operationStep.delete({
     *   where: {
     *     // ... filter to delete one OperationStep
     *   }
     * })
     * 
     */
    delete<T extends OperationStepDeleteArgs>(args: SelectSubset<T, OperationStepDeleteArgs<ExtArgs>>): Prisma__OperationStepClient<$Result.GetResult<Prisma.$OperationStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OperationStep.
     * @param {OperationStepUpdateArgs} args - Arguments to update one OperationStep.
     * @example
     * // Update one OperationStep
     * const operationStep = await prisma.operationStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationStepUpdateArgs>(args: SelectSubset<T, OperationStepUpdateArgs<ExtArgs>>): Prisma__OperationStepClient<$Result.GetResult<Prisma.$OperationStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OperationSteps.
     * @param {OperationStepDeleteManyArgs} args - Arguments to filter OperationSteps to delete.
     * @example
     * // Delete a few OperationSteps
     * const { count } = await prisma.operationStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationStepDeleteManyArgs>(args?: SelectSubset<T, OperationStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationSteps
     * const operationStep = await prisma.operationStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationStepUpdateManyArgs>(args: SelectSubset<T, OperationStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationStep.
     * @param {OperationStepUpsertArgs} args - Arguments to update or create a OperationStep.
     * @example
     * // Update or create a OperationStep
     * const operationStep = await prisma.operationStep.upsert({
     *   create: {
     *     // ... data to create a OperationStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationStep we want to update
     *   }
     * })
     */
    upsert<T extends OperationStepUpsertArgs>(args: SelectSubset<T, OperationStepUpsertArgs<ExtArgs>>): Prisma__OperationStepClient<$Result.GetResult<Prisma.$OperationStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OperationSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationStepCountArgs} args - Arguments to filter OperationSteps to count.
     * @example
     * // Count the number of OperationSteps
     * const count = await prisma.operationStep.count({
     *   where: {
     *     // ... the filter for the OperationSteps we want to count
     *   }
     * })
    **/
    count<T extends OperationStepCountArgs>(
      args?: Subset<T, OperationStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationStepAggregateArgs>(args: Subset<T, OperationStepAggregateArgs>): Prisma.PrismaPromise<GetOperationStepAggregateType<T>>

    /**
     * Group by OperationStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationStepGroupByArgs['orderBy'] }
        : { orderBy?: OperationStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationStep model
   */
  readonly fields: OperationStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperationStep model
   */ 
  interface OperationStepFieldRefs {
    readonly id: FieldRef<"OperationStep", 'Int'>
    readonly label: FieldRef<"OperationStep", 'String'>
    readonly operationNumber: FieldRef<"OperationStep", 'String'>
    readonly stepOrder: FieldRef<"OperationStep", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OperationStep findUnique
   */
  export type OperationStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationStep
     */
    select?: OperationStepSelect<ExtArgs> | null
    /**
     * Filter, which OperationStep to fetch.
     */
    where: OperationStepWhereUniqueInput
  }

  /**
   * OperationStep findUniqueOrThrow
   */
  export type OperationStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationStep
     */
    select?: OperationStepSelect<ExtArgs> | null
    /**
     * Filter, which OperationStep to fetch.
     */
    where: OperationStepWhereUniqueInput
  }

  /**
   * OperationStep findFirst
   */
  export type OperationStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationStep
     */
    select?: OperationStepSelect<ExtArgs> | null
    /**
     * Filter, which OperationStep to fetch.
     */
    where?: OperationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSteps to fetch.
     */
    orderBy?: OperationStepOrderByWithRelationInput | OperationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationSteps.
     */
    cursor?: OperationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationSteps.
     */
    distinct?: OperationStepScalarFieldEnum | OperationStepScalarFieldEnum[]
  }

  /**
   * OperationStep findFirstOrThrow
   */
  export type OperationStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationStep
     */
    select?: OperationStepSelect<ExtArgs> | null
    /**
     * Filter, which OperationStep to fetch.
     */
    where?: OperationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSteps to fetch.
     */
    orderBy?: OperationStepOrderByWithRelationInput | OperationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationSteps.
     */
    cursor?: OperationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationSteps.
     */
    distinct?: OperationStepScalarFieldEnum | OperationStepScalarFieldEnum[]
  }

  /**
   * OperationStep findMany
   */
  export type OperationStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationStep
     */
    select?: OperationStepSelect<ExtArgs> | null
    /**
     * Filter, which OperationSteps to fetch.
     */
    where?: OperationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSteps to fetch.
     */
    orderBy?: OperationStepOrderByWithRelationInput | OperationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationSteps.
     */
    cursor?: OperationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSteps.
     */
    skip?: number
    distinct?: OperationStepScalarFieldEnum | OperationStepScalarFieldEnum[]
  }

  /**
   * OperationStep create
   */
  export type OperationStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationStep
     */
    select?: OperationStepSelect<ExtArgs> | null
    /**
     * The data needed to create a OperationStep.
     */
    data: XOR<OperationStepCreateInput, OperationStepUncheckedCreateInput>
  }

  /**
   * OperationStep createMany
   */
  export type OperationStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationSteps.
     */
    data: OperationStepCreateManyInput | OperationStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationStep update
   */
  export type OperationStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationStep
     */
    select?: OperationStepSelect<ExtArgs> | null
    /**
     * The data needed to update a OperationStep.
     */
    data: XOR<OperationStepUpdateInput, OperationStepUncheckedUpdateInput>
    /**
     * Choose, which OperationStep to update.
     */
    where: OperationStepWhereUniqueInput
  }

  /**
   * OperationStep updateMany
   */
  export type OperationStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationSteps.
     */
    data: XOR<OperationStepUpdateManyMutationInput, OperationStepUncheckedUpdateManyInput>
    /**
     * Filter which OperationSteps to update
     */
    where?: OperationStepWhereInput
  }

  /**
   * OperationStep upsert
   */
  export type OperationStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationStep
     */
    select?: OperationStepSelect<ExtArgs> | null
    /**
     * The filter to search for the OperationStep to update in case it exists.
     */
    where: OperationStepWhereUniqueInput
    /**
     * In case the OperationStep found by the `where` argument doesn't exist, create a new OperationStep with this data.
     */
    create: XOR<OperationStepCreateInput, OperationStepUncheckedCreateInput>
    /**
     * In case the OperationStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationStepUpdateInput, OperationStepUncheckedUpdateInput>
  }

  /**
   * OperationStep delete
   */
  export type OperationStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationStep
     */
    select?: OperationStepSelect<ExtArgs> | null
    /**
     * Filter which OperationStep to delete.
     */
    where: OperationStepWhereUniqueInput
  }

  /**
   * OperationStep deleteMany
   */
  export type OperationStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationSteps to delete
     */
    where?: OperationStepWhereInput
  }

  /**
   * OperationStep without action
   */
  export type OperationStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationStep
     */
    select?: OperationStepSelect<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    tableName: string | null
    recordId: string | null
    action: string | null
    oldValues: string | null
    newValues: string | null
    userId: number | null
    timestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    tableName: string | null
    recordId: string | null
    action: string | null
    oldValues: string | null
    newValues: string | null
    userId: number | null
    timestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tableName: number
    recordId: number
    action: number
    oldValues: number
    newValues: number
    userId: number
    timestamp: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    oldValues?: true
    newValues?: true
    userId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    oldValues?: true
    newValues?: true
    userId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    oldValues?: true
    newValues?: true
    userId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    tableName: string
    recordId: string
    action: string
    oldValues: string | null
    newValues: string | null
    userId: number
    timestamp: Date
    ipAddress: string | null
    userAgent: string | null
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>


  export type AuditLogSelectScalar = {
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tableName: string
      recordId: string
      action: string
      oldValues: string | null
      newValues: string | null
      userId: number
      timestamp: Date
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly tableName: FieldRef<"AuditLog", 'String'>
    readonly recordId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'String'>
    readonly newValues: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    expiresAt: Date | null
    lastActivity: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    expiresAt: Date | null
    lastActivity: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    ipAddress: number
    userAgent: number
    createdAt: number
    expiresAt: number
    lastActivity: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
    lastActivity?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
    lastActivity?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
    lastActivity?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    userId: number
    token: string
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    expiresAt: Date
    lastActivity: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>


  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      expiresAt: Date
      lastActivity: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly token: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly lastActivity: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    linkUrl: string | null
    userId: number | null
    sourceId: string | null
    sourceType: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    linkUrl: string | null
    userId: number | null
    sourceId: string | null
    sourceType: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    message: number
    isRead: number
    createdAt: number
    updatedAt: number
    linkUrl: number
    userId: number
    sourceId: number
    sourceType: number
    metadata: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    linkUrl?: true
    userId?: true
    sourceId?: true
    sourceType?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    linkUrl?: true
    userId?: true
    sourceId?: true
    sourceType?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    linkUrl?: true
    userId?: true
    sourceId?: true
    sourceType?: true
    metadata?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: string
    title: string
    message: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    linkUrl: string | null
    userId: number
    sourceId: string | null
    sourceType: string | null
    metadata: JsonValue | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    linkUrl?: boolean
    userId?: boolean
    sourceId?: boolean
    sourceType?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>


  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    linkUrl?: boolean
    userId?: boolean
    sourceId?: boolean
    sourceType?: boolean
    metadata?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string
      message: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
      linkUrl: string | null
      userId: number
      sourceId: string | null
      sourceType: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
    readonly linkUrl: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly sourceId: FieldRef<"Notification", 'String'>
    readonly sourceType: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model OperationLine
   */

  export type AggregateOperationLine = {
    _count: OperationLineCountAggregateOutputType | null
    _avg: OperationLineAvgAggregateOutputType | null
    _sum: OperationLineSumAggregateOutputType | null
    _min: OperationLineMinAggregateOutputType | null
    _max: OperationLineMaxAggregateOutputType | null
  }

  export type OperationLineAvgAggregateOutputType = {
    id: number | null
  }

  export type OperationLineSumAggregateOutputType = {
    id: number | null
  }

  export type OperationLineMinAggregateOutputType = {
    id: number | null
    operationNumber: string | null
    lineNumber: string | null
  }

  export type OperationLineMaxAggregateOutputType = {
    id: number | null
    operationNumber: string | null
    lineNumber: string | null
  }

  export type OperationLineCountAggregateOutputType = {
    id: number
    operationNumber: number
    lineNumber: number
    _all: number
  }


  export type OperationLineAvgAggregateInputType = {
    id?: true
  }

  export type OperationLineSumAggregateInputType = {
    id?: true
  }

  export type OperationLineMinAggregateInputType = {
    id?: true
    operationNumber?: true
    lineNumber?: true
  }

  export type OperationLineMaxAggregateInputType = {
    id?: true
    operationNumber?: true
    lineNumber?: true
  }

  export type OperationLineCountAggregateInputType = {
    id?: true
    operationNumber?: true
    lineNumber?: true
    _all?: true
  }

  export type OperationLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationLine to aggregate.
     */
    where?: OperationLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationLines to fetch.
     */
    orderBy?: OperationLineOrderByWithRelationInput | OperationLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationLines
    **/
    _count?: true | OperationLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationLineMaxAggregateInputType
  }

  export type GetOperationLineAggregateType<T extends OperationLineAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationLine[P]>
      : GetScalarType<T[P], AggregateOperationLine[P]>
  }




  export type OperationLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationLineWhereInput
    orderBy?: OperationLineOrderByWithAggregationInput | OperationLineOrderByWithAggregationInput[]
    by: OperationLineScalarFieldEnum[] | OperationLineScalarFieldEnum
    having?: OperationLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationLineCountAggregateInputType | true
    _avg?: OperationLineAvgAggregateInputType
    _sum?: OperationLineSumAggregateInputType
    _min?: OperationLineMinAggregateInputType
    _max?: OperationLineMaxAggregateInputType
  }

  export type OperationLineGroupByOutputType = {
    id: number
    operationNumber: string
    lineNumber: string
    _count: OperationLineCountAggregateOutputType | null
    _avg: OperationLineAvgAggregateOutputType | null
    _sum: OperationLineSumAggregateOutputType | null
    _min: OperationLineMinAggregateOutputType | null
    _max: OperationLineMaxAggregateOutputType | null
  }

  type GetOperationLineGroupByPayload<T extends OperationLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationLineGroupByOutputType[P]>
            : GetScalarType<T[P], OperationLineGroupByOutputType[P]>
        }
      >
    >


  export type OperationLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operationNumber?: boolean
    lineNumber?: boolean
  }, ExtArgs["result"]["operationLine"]>


  export type OperationLineSelectScalar = {
    id?: boolean
    operationNumber?: boolean
    lineNumber?: boolean
  }


  export type $OperationLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationLine"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      operationNumber: string
      lineNumber: string
    }, ExtArgs["result"]["operationLine"]>
    composites: {}
  }

  type OperationLineGetPayload<S extends boolean | null | undefined | OperationLineDefaultArgs> = $Result.GetResult<Prisma.$OperationLinePayload, S>

  type OperationLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationLineCountAggregateInputType | true
    }

  export interface OperationLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationLine'], meta: { name: 'OperationLine' } }
    /**
     * Find zero or one OperationLine that matches the filter.
     * @param {OperationLineFindUniqueArgs} args - Arguments to find a OperationLine
     * @example
     * // Get one OperationLine
     * const operationLine = await prisma.operationLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationLineFindUniqueArgs>(args: SelectSubset<T, OperationLineFindUniqueArgs<ExtArgs>>): Prisma__OperationLineClient<$Result.GetResult<Prisma.$OperationLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OperationLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationLineFindUniqueOrThrowArgs} args - Arguments to find a OperationLine
     * @example
     * // Get one OperationLine
     * const operationLine = await prisma.operationLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationLineFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationLineClient<$Result.GetResult<Prisma.$OperationLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OperationLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLineFindFirstArgs} args - Arguments to find a OperationLine
     * @example
     * // Get one OperationLine
     * const operationLine = await prisma.operationLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationLineFindFirstArgs>(args?: SelectSubset<T, OperationLineFindFirstArgs<ExtArgs>>): Prisma__OperationLineClient<$Result.GetResult<Prisma.$OperationLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OperationLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLineFindFirstOrThrowArgs} args - Arguments to find a OperationLine
     * @example
     * // Get one OperationLine
     * const operationLine = await prisma.operationLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationLineFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationLineClient<$Result.GetResult<Prisma.$OperationLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OperationLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationLines
     * const operationLines = await prisma.operationLine.findMany()
     * 
     * // Get first 10 OperationLines
     * const operationLines = await prisma.operationLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationLineWithIdOnly = await prisma.operationLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperationLineFindManyArgs>(args?: SelectSubset<T, OperationLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OperationLine.
     * @param {OperationLineCreateArgs} args - Arguments to create a OperationLine.
     * @example
     * // Create one OperationLine
     * const OperationLine = await prisma.operationLine.create({
     *   data: {
     *     // ... data to create a OperationLine
     *   }
     * })
     * 
     */
    create<T extends OperationLineCreateArgs>(args: SelectSubset<T, OperationLineCreateArgs<ExtArgs>>): Prisma__OperationLineClient<$Result.GetResult<Prisma.$OperationLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OperationLines.
     * @param {OperationLineCreateManyArgs} args - Arguments to create many OperationLines.
     * @example
     * // Create many OperationLines
     * const operationLine = await prisma.operationLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationLineCreateManyArgs>(args?: SelectSubset<T, OperationLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OperationLine.
     * @param {OperationLineDeleteArgs} args - Arguments to delete one OperationLine.
     * @example
     * // Delete one OperationLine
     * const OperationLine = await prisma.operationLine.delete({
     *   where: {
     *     // ... filter to delete one OperationLine
     *   }
     * })
     * 
     */
    delete<T extends OperationLineDeleteArgs>(args: SelectSubset<T, OperationLineDeleteArgs<ExtArgs>>): Prisma__OperationLineClient<$Result.GetResult<Prisma.$OperationLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OperationLine.
     * @param {OperationLineUpdateArgs} args - Arguments to update one OperationLine.
     * @example
     * // Update one OperationLine
     * const operationLine = await prisma.operationLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationLineUpdateArgs>(args: SelectSubset<T, OperationLineUpdateArgs<ExtArgs>>): Prisma__OperationLineClient<$Result.GetResult<Prisma.$OperationLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OperationLines.
     * @param {OperationLineDeleteManyArgs} args - Arguments to filter OperationLines to delete.
     * @example
     * // Delete a few OperationLines
     * const { count } = await prisma.operationLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationLineDeleteManyArgs>(args?: SelectSubset<T, OperationLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationLines
     * const operationLine = await prisma.operationLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationLineUpdateManyArgs>(args: SelectSubset<T, OperationLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationLine.
     * @param {OperationLineUpsertArgs} args - Arguments to update or create a OperationLine.
     * @example
     * // Update or create a OperationLine
     * const operationLine = await prisma.operationLine.upsert({
     *   create: {
     *     // ... data to create a OperationLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationLine we want to update
     *   }
     * })
     */
    upsert<T extends OperationLineUpsertArgs>(args: SelectSubset<T, OperationLineUpsertArgs<ExtArgs>>): Prisma__OperationLineClient<$Result.GetResult<Prisma.$OperationLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OperationLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLineCountArgs} args - Arguments to filter OperationLines to count.
     * @example
     * // Count the number of OperationLines
     * const count = await prisma.operationLine.count({
     *   where: {
     *     // ... the filter for the OperationLines we want to count
     *   }
     * })
    **/
    count<T extends OperationLineCountArgs>(
      args?: Subset<T, OperationLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationLineAggregateArgs>(args: Subset<T, OperationLineAggregateArgs>): Prisma.PrismaPromise<GetOperationLineAggregateType<T>>

    /**
     * Group by OperationLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationLineGroupByArgs['orderBy'] }
        : { orderBy?: OperationLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationLine model
   */
  readonly fields: OperationLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperationLine model
   */ 
  interface OperationLineFieldRefs {
    readonly id: FieldRef<"OperationLine", 'Int'>
    readonly operationNumber: FieldRef<"OperationLine", 'String'>
    readonly lineNumber: FieldRef<"OperationLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OperationLine findUnique
   */
  export type OperationLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLine
     */
    select?: OperationLineSelect<ExtArgs> | null
    /**
     * Filter, which OperationLine to fetch.
     */
    where: OperationLineWhereUniqueInput
  }

  /**
   * OperationLine findUniqueOrThrow
   */
  export type OperationLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLine
     */
    select?: OperationLineSelect<ExtArgs> | null
    /**
     * Filter, which OperationLine to fetch.
     */
    where: OperationLineWhereUniqueInput
  }

  /**
   * OperationLine findFirst
   */
  export type OperationLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLine
     */
    select?: OperationLineSelect<ExtArgs> | null
    /**
     * Filter, which OperationLine to fetch.
     */
    where?: OperationLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationLines to fetch.
     */
    orderBy?: OperationLineOrderByWithRelationInput | OperationLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationLines.
     */
    cursor?: OperationLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationLines.
     */
    distinct?: OperationLineScalarFieldEnum | OperationLineScalarFieldEnum[]
  }

  /**
   * OperationLine findFirstOrThrow
   */
  export type OperationLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLine
     */
    select?: OperationLineSelect<ExtArgs> | null
    /**
     * Filter, which OperationLine to fetch.
     */
    where?: OperationLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationLines to fetch.
     */
    orderBy?: OperationLineOrderByWithRelationInput | OperationLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationLines.
     */
    cursor?: OperationLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationLines.
     */
    distinct?: OperationLineScalarFieldEnum | OperationLineScalarFieldEnum[]
  }

  /**
   * OperationLine findMany
   */
  export type OperationLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLine
     */
    select?: OperationLineSelect<ExtArgs> | null
    /**
     * Filter, which OperationLines to fetch.
     */
    where?: OperationLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationLines to fetch.
     */
    orderBy?: OperationLineOrderByWithRelationInput | OperationLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationLines.
     */
    cursor?: OperationLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationLines.
     */
    skip?: number
    distinct?: OperationLineScalarFieldEnum | OperationLineScalarFieldEnum[]
  }

  /**
   * OperationLine create
   */
  export type OperationLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLine
     */
    select?: OperationLineSelect<ExtArgs> | null
    /**
     * The data needed to create a OperationLine.
     */
    data: XOR<OperationLineCreateInput, OperationLineUncheckedCreateInput>
  }

  /**
   * OperationLine createMany
   */
  export type OperationLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationLines.
     */
    data: OperationLineCreateManyInput | OperationLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationLine update
   */
  export type OperationLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLine
     */
    select?: OperationLineSelect<ExtArgs> | null
    /**
     * The data needed to update a OperationLine.
     */
    data: XOR<OperationLineUpdateInput, OperationLineUncheckedUpdateInput>
    /**
     * Choose, which OperationLine to update.
     */
    where: OperationLineWhereUniqueInput
  }

  /**
   * OperationLine updateMany
   */
  export type OperationLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationLines.
     */
    data: XOR<OperationLineUpdateManyMutationInput, OperationLineUncheckedUpdateManyInput>
    /**
     * Filter which OperationLines to update
     */
    where?: OperationLineWhereInput
  }

  /**
   * OperationLine upsert
   */
  export type OperationLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLine
     */
    select?: OperationLineSelect<ExtArgs> | null
    /**
     * The filter to search for the OperationLine to update in case it exists.
     */
    where: OperationLineWhereUniqueInput
    /**
     * In case the OperationLine found by the `where` argument doesn't exist, create a new OperationLine with this data.
     */
    create: XOR<OperationLineCreateInput, OperationLineUncheckedCreateInput>
    /**
     * In case the OperationLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationLineUpdateInput, OperationLineUncheckedUpdateInput>
  }

  /**
   * OperationLine delete
   */
  export type OperationLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLine
     */
    select?: OperationLineSelect<ExtArgs> | null
    /**
     * Filter which OperationLine to delete.
     */
    where: OperationLineWhereUniqueInput
  }

  /**
   * OperationLine deleteMany
   */
  export type OperationLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationLines to delete
     */
    where?: OperationLineWhereInput
  }

  /**
   * OperationLine without action
   */
  export type OperationLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLine
     */
    select?: OperationLineSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    name: 'name',
    email: 'email',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    lastLogin: 'lastLogin',
    department: 'department'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProductionOrderScalarFieldEnum: {
    id: 'id',
    poNumber: 'poNumber',
    lotNumber: 'lotNumber',
    poQuantity: 'poQuantity',
    itemName: 'itemName',
    status: 'status',
    currentOperation: 'currentOperation',
    currentOperationStartTime: 'currentOperationStartTime',
    currentOperationEndTime: 'currentOperationEndTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    editingUserId: 'editingUserId',
    editingUserName: 'editingUserName',
    lockedAt: 'lockedAt',
    costPerUnit: 'costPerUnit',
    totalDefectCost: 'totalDefectCost',
    lastCostUpdate: 'lastCostUpdate'
  };

  export type ProductionOrderScalarFieldEnum = (typeof ProductionOrderScalarFieldEnum)[keyof typeof ProductionOrderScalarFieldEnum]


  export const OperationScalarFieldEnum: {
    id: 'id',
    productionOrderId: 'productionOrderId',
    operation: 'operation',
    operatorId: 'operatorId',
    startTime: 'startTime',
    endTime: 'endTime',
    inputQuantity: 'inputQuantity',
    outputQuantity: 'outputQuantity',
    productionHours: 'productionHours',
    accumulatedManHours: 'accumulatedManHours',
    rf: 'rf',
    lineNo: 'lineNo',
    shift: 'shift',
    encodedById: 'encodedById',
    encodedTime: 'encodedTime',
    defectCost: 'defectCost'
  };

  export type OperationScalarFieldEnum = (typeof OperationScalarFieldEnum)[keyof typeof OperationScalarFieldEnum]


  export const MasterDefectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    applicableOperation: 'applicableOperation',
    reworkable: 'reworkable',
    machine: 'machine',
    isActive: 'isActive',
    deactivatedAt: 'deactivatedAt',
    deactivatedById: 'deactivatedById'
  };

  export type MasterDefectScalarFieldEnum = (typeof MasterDefectScalarFieldEnum)[keyof typeof MasterDefectScalarFieldEnum]


  export const StandardCostScalarFieldEnum: {
    id: 'id',
    itemName: 'itemName',
    description: 'description',
    costPerUnit: 'costPerUnit',
    currency: 'currency',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type StandardCostScalarFieldEnum = (typeof StandardCostScalarFieldEnum)[keyof typeof StandardCostScalarFieldEnum]


  export const OperationDefectScalarFieldEnum: {
    id: 'id',
    operationId: 'operationId',
    defectId: 'defectId',
    defectName: 'defectName',
    defectCategory: 'defectCategory',
    defectMachine: 'defectMachine',
    defectReworkable: 'defectReworkable',
    quantity: 'quantity',
    quantityRework: 'quantityRework',
    quantityNogood: 'quantityNogood',
    quantityReplacement: 'quantityReplacement',
    recordedAt: 'recordedAt',
    recordedById: 'recordedById'
  };

  export type OperationDefectScalarFieldEnum = (typeof OperationDefectScalarFieldEnum)[keyof typeof OperationDefectScalarFieldEnum]


  export const OperationDefectEditRequestScalarFieldEnum: {
    id: 'id',
    operationDefectId: 'operationDefectId',
    operationId: 'operationId',
    productionOrderId: 'productionOrderId',
    requestedById: 'requestedById',
    requestType: 'requestType',
    defectId: 'defectId',
    defectName: 'defectName',
    defectCategory: 'defectCategory',
    defectReworkable: 'defectReworkable',
    defectMachine: 'defectMachine',
    currentQty: 'currentQty',
    currentRw: 'currentRw',
    currentNg: 'currentNg',
    currentReplacement: 'currentReplacement',
    requestedQty: 'requestedQty',
    requestedRw: 'requestedRw',
    requestedNg: 'requestedNg',
    requestedReplacement: 'requestedReplacement',
    operationCode: 'operationCode',
    reason: 'reason',
    status: 'status',
    resolvedById: 'resolvedById',
    resolutionNote: 'resolutionNote',
    createdAt: 'createdAt',
    resolvedAt: 'resolvedAt'
  };

  export type OperationDefectEditRequestScalarFieldEnum = (typeof OperationDefectEditRequestScalarFieldEnum)[keyof typeof OperationDefectEditRequestScalarFieldEnum]


  export const OperationStepScalarFieldEnum: {
    id: 'id',
    label: 'label',
    operationNumber: 'operationNumber',
    stepOrder: 'stepOrder'
  };

  export type OperationStepScalarFieldEnum = (typeof OperationStepScalarFieldEnum)[keyof typeof OperationStepScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    recordId: 'recordId',
    action: 'action',
    oldValues: 'oldValues',
    newValues: 'newValues',
    userId: 'userId',
    timestamp: 'timestamp',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    lastActivity: 'lastActivity'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    linkUrl: 'linkUrl',
    userId: 'userId',
    sourceId: 'sourceId',
    sourceType: 'sourceType',
    metadata: 'metadata'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const OperationLineScalarFieldEnum: {
    id: 'id',
    operationNumber: 'operationNumber',
    lineNumber: 'lineNumber'
  };

  export type OperationLineScalarFieldEnum = (typeof OperationLineScalarFieldEnum)[keyof typeof OperationLineScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    department?: StringNullableFilter<"User"> | string | null
    auditLogs?: AuditLogListRelationFilter
    deactivatedDefects?: MasterDefectListRelationFilter
    requestedEditRequests?: OperationDefectEditRequestListRelationFilter
    resolvedEditRequests?: OperationDefectEditRequestListRelationFilter
    recordedDefects?: OperationDefectListRelationFilter
    encodedOperations?: OperationListRelationFilter
    operations?: OperationListRelationFilter
    sessions?: SessionListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
    deactivatedDefects?: MasterDefectOrderByRelationAggregateInput
    requestedEditRequests?: OperationDefectEditRequestOrderByRelationAggregateInput
    resolvedEditRequests?: OperationDefectEditRequestOrderByRelationAggregateInput
    recordedDefects?: OperationDefectOrderByRelationAggregateInput
    encodedOperations?: OperationOrderByRelationAggregateInput
    operations?: OperationOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    department?: StringNullableFilter<"User"> | string | null
    auditLogs?: AuditLogListRelationFilter
    deactivatedDefects?: MasterDefectListRelationFilter
    requestedEditRequests?: OperationDefectEditRequestListRelationFilter
    resolvedEditRequests?: OperationDefectEditRequestListRelationFilter
    recordedDefects?: OperationDefectListRelationFilter
    encodedOperations?: OperationListRelationFilter
    operations?: OperationListRelationFilter
    sessions?: SessionListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ProductionOrderWhereInput = {
    AND?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    OR?: ProductionOrderWhereInput[]
    NOT?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    id?: IntFilter<"ProductionOrder"> | number
    poNumber?: StringFilter<"ProductionOrder"> | string
    lotNumber?: StringNullableFilter<"ProductionOrder"> | string | null
    poQuantity?: IntFilter<"ProductionOrder"> | number
    itemName?: StringNullableFilter<"ProductionOrder"> | string | null
    status?: StringFilter<"ProductionOrder"> | string
    currentOperation?: StringNullableFilter<"ProductionOrder"> | string | null
    currentOperationStartTime?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    currentOperationEndTime?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductionOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionOrder"> | Date | string
    editingUserId?: IntNullableFilter<"ProductionOrder"> | number | null
    editingUserName?: StringNullableFilter<"ProductionOrder"> | string | null
    lockedAt?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    costPerUnit?: DecimalNullableFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: DecimalNullableFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    editRequests?: OperationDefectEditRequestListRelationFilter
    operations?: OperationListRelationFilter
  }

  export type ProductionOrderOrderByWithRelationInput = {
    id?: SortOrder
    poNumber?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    poQuantity?: SortOrder
    itemName?: SortOrderInput | SortOrder
    status?: SortOrder
    currentOperation?: SortOrderInput | SortOrder
    currentOperationStartTime?: SortOrderInput | SortOrder
    currentOperationEndTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    editingUserId?: SortOrderInput | SortOrder
    editingUserName?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    costPerUnit?: SortOrderInput | SortOrder
    totalDefectCost?: SortOrderInput | SortOrder
    lastCostUpdate?: SortOrderInput | SortOrder
    editRequests?: OperationDefectEditRequestOrderByRelationAggregateInput
    operations?: OperationOrderByRelationAggregateInput
  }

  export type ProductionOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    poNumber?: string
    AND?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    OR?: ProductionOrderWhereInput[]
    NOT?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    lotNumber?: StringNullableFilter<"ProductionOrder"> | string | null
    poQuantity?: IntFilter<"ProductionOrder"> | number
    itemName?: StringNullableFilter<"ProductionOrder"> | string | null
    status?: StringFilter<"ProductionOrder"> | string
    currentOperation?: StringNullableFilter<"ProductionOrder"> | string | null
    currentOperationStartTime?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    currentOperationEndTime?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductionOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionOrder"> | Date | string
    editingUserId?: IntNullableFilter<"ProductionOrder"> | number | null
    editingUserName?: StringNullableFilter<"ProductionOrder"> | string | null
    lockedAt?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    costPerUnit?: DecimalNullableFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: DecimalNullableFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    editRequests?: OperationDefectEditRequestListRelationFilter
    operations?: OperationListRelationFilter
  }, "id" | "poNumber">

  export type ProductionOrderOrderByWithAggregationInput = {
    id?: SortOrder
    poNumber?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    poQuantity?: SortOrder
    itemName?: SortOrderInput | SortOrder
    status?: SortOrder
    currentOperation?: SortOrderInput | SortOrder
    currentOperationStartTime?: SortOrderInput | SortOrder
    currentOperationEndTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    editingUserId?: SortOrderInput | SortOrder
    editingUserName?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    costPerUnit?: SortOrderInput | SortOrder
    totalDefectCost?: SortOrderInput | SortOrder
    lastCostUpdate?: SortOrderInput | SortOrder
    _count?: ProductionOrderCountOrderByAggregateInput
    _avg?: ProductionOrderAvgOrderByAggregateInput
    _max?: ProductionOrderMaxOrderByAggregateInput
    _min?: ProductionOrderMinOrderByAggregateInput
    _sum?: ProductionOrderSumOrderByAggregateInput
  }

  export type ProductionOrderScalarWhereWithAggregatesInput = {
    AND?: ProductionOrderScalarWhereWithAggregatesInput | ProductionOrderScalarWhereWithAggregatesInput[]
    OR?: ProductionOrderScalarWhereWithAggregatesInput[]
    NOT?: ProductionOrderScalarWhereWithAggregatesInput | ProductionOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductionOrder"> | number
    poNumber?: StringWithAggregatesFilter<"ProductionOrder"> | string
    lotNumber?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    poQuantity?: IntWithAggregatesFilter<"ProductionOrder"> | number
    itemName?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    status?: StringWithAggregatesFilter<"ProductionOrder"> | string
    currentOperation?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    currentOperationStartTime?: DateTimeNullableWithAggregatesFilter<"ProductionOrder"> | Date | string | null
    currentOperationEndTime?: DateTimeNullableWithAggregatesFilter<"ProductionOrder"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductionOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionOrder"> | Date | string
    editingUserId?: IntNullableWithAggregatesFilter<"ProductionOrder"> | number | null
    editingUserName?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"ProductionOrder"> | Date | string | null
    costPerUnit?: DecimalNullableWithAggregatesFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: DecimalNullableWithAggregatesFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: DateTimeNullableWithAggregatesFilter<"ProductionOrder"> | Date | string | null
  }

  export type OperationWhereInput = {
    AND?: OperationWhereInput | OperationWhereInput[]
    OR?: OperationWhereInput[]
    NOT?: OperationWhereInput | OperationWhereInput[]
    id?: IntFilter<"Operation"> | number
    productionOrderId?: IntFilter<"Operation"> | number
    operation?: StringFilter<"Operation"> | string
    operatorId?: IntFilter<"Operation"> | number
    startTime?: DateTimeNullableFilter<"Operation"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Operation"> | Date | string | null
    inputQuantity?: IntFilter<"Operation"> | number
    outputQuantity?: IntNullableFilter<"Operation"> | number | null
    productionHours?: FloatNullableFilter<"Operation"> | number | null
    accumulatedManHours?: FloatNullableFilter<"Operation"> | number | null
    rf?: IntNullableFilter<"Operation"> | number | null
    lineNo?: StringNullableFilter<"Operation"> | string | null
    shift?: StringNullableFilter<"Operation"> | string | null
    encodedById?: IntFilter<"Operation"> | number
    encodedTime?: DateTimeFilter<"Operation"> | Date | string
    defectCost?: DecimalNullableFilter<"Operation"> | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestListRelationFilter
    operationDefects?: OperationDefectListRelationFilter
    encodedBy?: XOR<UserRelationFilter, UserWhereInput>
    operator?: XOR<UserRelationFilter, UserWhereInput>
    productionOrder?: XOR<ProductionOrderRelationFilter, ProductionOrderWhereInput>
  }

  export type OperationOrderByWithRelationInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    operation?: SortOrder
    operatorId?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    inputQuantity?: SortOrder
    outputQuantity?: SortOrderInput | SortOrder
    productionHours?: SortOrderInput | SortOrder
    accumulatedManHours?: SortOrderInput | SortOrder
    rf?: SortOrderInput | SortOrder
    lineNo?: SortOrderInput | SortOrder
    shift?: SortOrderInput | SortOrder
    encodedById?: SortOrder
    encodedTime?: SortOrder
    defectCost?: SortOrderInput | SortOrder
    editRequests?: OperationDefectEditRequestOrderByRelationAggregateInput
    operationDefects?: OperationDefectOrderByRelationAggregateInput
    encodedBy?: UserOrderByWithRelationInput
    operator?: UserOrderByWithRelationInput
    productionOrder?: ProductionOrderOrderByWithRelationInput
  }

  export type OperationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OperationWhereInput | OperationWhereInput[]
    OR?: OperationWhereInput[]
    NOT?: OperationWhereInput | OperationWhereInput[]
    productionOrderId?: IntFilter<"Operation"> | number
    operation?: StringFilter<"Operation"> | string
    operatorId?: IntFilter<"Operation"> | number
    startTime?: DateTimeNullableFilter<"Operation"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Operation"> | Date | string | null
    inputQuantity?: IntFilter<"Operation"> | number
    outputQuantity?: IntNullableFilter<"Operation"> | number | null
    productionHours?: FloatNullableFilter<"Operation"> | number | null
    accumulatedManHours?: FloatNullableFilter<"Operation"> | number | null
    rf?: IntNullableFilter<"Operation"> | number | null
    lineNo?: StringNullableFilter<"Operation"> | string | null
    shift?: StringNullableFilter<"Operation"> | string | null
    encodedById?: IntFilter<"Operation"> | number
    encodedTime?: DateTimeFilter<"Operation"> | Date | string
    defectCost?: DecimalNullableFilter<"Operation"> | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestListRelationFilter
    operationDefects?: OperationDefectListRelationFilter
    encodedBy?: XOR<UserRelationFilter, UserWhereInput>
    operator?: XOR<UserRelationFilter, UserWhereInput>
    productionOrder?: XOR<ProductionOrderRelationFilter, ProductionOrderWhereInput>
  }, "id">

  export type OperationOrderByWithAggregationInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    operation?: SortOrder
    operatorId?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    inputQuantity?: SortOrder
    outputQuantity?: SortOrderInput | SortOrder
    productionHours?: SortOrderInput | SortOrder
    accumulatedManHours?: SortOrderInput | SortOrder
    rf?: SortOrderInput | SortOrder
    lineNo?: SortOrderInput | SortOrder
    shift?: SortOrderInput | SortOrder
    encodedById?: SortOrder
    encodedTime?: SortOrder
    defectCost?: SortOrderInput | SortOrder
    _count?: OperationCountOrderByAggregateInput
    _avg?: OperationAvgOrderByAggregateInput
    _max?: OperationMaxOrderByAggregateInput
    _min?: OperationMinOrderByAggregateInput
    _sum?: OperationSumOrderByAggregateInput
  }

  export type OperationScalarWhereWithAggregatesInput = {
    AND?: OperationScalarWhereWithAggregatesInput | OperationScalarWhereWithAggregatesInput[]
    OR?: OperationScalarWhereWithAggregatesInput[]
    NOT?: OperationScalarWhereWithAggregatesInput | OperationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Operation"> | number
    productionOrderId?: IntWithAggregatesFilter<"Operation"> | number
    operation?: StringWithAggregatesFilter<"Operation"> | string
    operatorId?: IntWithAggregatesFilter<"Operation"> | number
    startTime?: DateTimeNullableWithAggregatesFilter<"Operation"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"Operation"> | Date | string | null
    inputQuantity?: IntWithAggregatesFilter<"Operation"> | number
    outputQuantity?: IntNullableWithAggregatesFilter<"Operation"> | number | null
    productionHours?: FloatNullableWithAggregatesFilter<"Operation"> | number | null
    accumulatedManHours?: FloatNullableWithAggregatesFilter<"Operation"> | number | null
    rf?: IntNullableWithAggregatesFilter<"Operation"> | number | null
    lineNo?: StringNullableWithAggregatesFilter<"Operation"> | string | null
    shift?: StringNullableWithAggregatesFilter<"Operation"> | string | null
    encodedById?: IntWithAggregatesFilter<"Operation"> | number
    encodedTime?: DateTimeWithAggregatesFilter<"Operation"> | Date | string
    defectCost?: DecimalNullableWithAggregatesFilter<"Operation"> | Decimal | DecimalJsLike | number | string | null
  }

  export type MasterDefectWhereInput = {
    AND?: MasterDefectWhereInput | MasterDefectWhereInput[]
    OR?: MasterDefectWhereInput[]
    NOT?: MasterDefectWhereInput | MasterDefectWhereInput[]
    id?: IntFilter<"MasterDefect"> | number
    name?: StringFilter<"MasterDefect"> | string
    description?: StringNullableFilter<"MasterDefect"> | string | null
    category?: StringNullableFilter<"MasterDefect"> | string | null
    applicableOperation?: StringNullableFilter<"MasterDefect"> | string | null
    reworkable?: BoolFilter<"MasterDefect"> | boolean
    machine?: StringNullableFilter<"MasterDefect"> | string | null
    isActive?: BoolFilter<"MasterDefect"> | boolean
    deactivatedAt?: DateTimeNullableFilter<"MasterDefect"> | Date | string | null
    deactivatedById?: IntNullableFilter<"MasterDefect"> | number | null
    deactivatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    operationDefects?: OperationDefectListRelationFilter
  }

  export type MasterDefectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    applicableOperation?: SortOrderInput | SortOrder
    reworkable?: SortOrder
    machine?: SortOrderInput | SortOrder
    isActive?: SortOrder
    deactivatedAt?: SortOrderInput | SortOrder
    deactivatedById?: SortOrderInput | SortOrder
    deactivatedBy?: UserOrderByWithRelationInput
    operationDefects?: OperationDefectOrderByRelationAggregateInput
  }

  export type MasterDefectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_applicableOperation?: MasterDefectNameApplicableOperationCompoundUniqueInput
    AND?: MasterDefectWhereInput | MasterDefectWhereInput[]
    OR?: MasterDefectWhereInput[]
    NOT?: MasterDefectWhereInput | MasterDefectWhereInput[]
    name?: StringFilter<"MasterDefect"> | string
    description?: StringNullableFilter<"MasterDefect"> | string | null
    category?: StringNullableFilter<"MasterDefect"> | string | null
    applicableOperation?: StringNullableFilter<"MasterDefect"> | string | null
    reworkable?: BoolFilter<"MasterDefect"> | boolean
    machine?: StringNullableFilter<"MasterDefect"> | string | null
    isActive?: BoolFilter<"MasterDefect"> | boolean
    deactivatedAt?: DateTimeNullableFilter<"MasterDefect"> | Date | string | null
    deactivatedById?: IntNullableFilter<"MasterDefect"> | number | null
    deactivatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    operationDefects?: OperationDefectListRelationFilter
  }, "id" | "name_applicableOperation">

  export type MasterDefectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    applicableOperation?: SortOrderInput | SortOrder
    reworkable?: SortOrder
    machine?: SortOrderInput | SortOrder
    isActive?: SortOrder
    deactivatedAt?: SortOrderInput | SortOrder
    deactivatedById?: SortOrderInput | SortOrder
    _count?: MasterDefectCountOrderByAggregateInput
    _avg?: MasterDefectAvgOrderByAggregateInput
    _max?: MasterDefectMaxOrderByAggregateInput
    _min?: MasterDefectMinOrderByAggregateInput
    _sum?: MasterDefectSumOrderByAggregateInput
  }

  export type MasterDefectScalarWhereWithAggregatesInput = {
    AND?: MasterDefectScalarWhereWithAggregatesInput | MasterDefectScalarWhereWithAggregatesInput[]
    OR?: MasterDefectScalarWhereWithAggregatesInput[]
    NOT?: MasterDefectScalarWhereWithAggregatesInput | MasterDefectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MasterDefect"> | number
    name?: StringWithAggregatesFilter<"MasterDefect"> | string
    description?: StringNullableWithAggregatesFilter<"MasterDefect"> | string | null
    category?: StringNullableWithAggregatesFilter<"MasterDefect"> | string | null
    applicableOperation?: StringNullableWithAggregatesFilter<"MasterDefect"> | string | null
    reworkable?: BoolWithAggregatesFilter<"MasterDefect"> | boolean
    machine?: StringNullableWithAggregatesFilter<"MasterDefect"> | string | null
    isActive?: BoolWithAggregatesFilter<"MasterDefect"> | boolean
    deactivatedAt?: DateTimeNullableWithAggregatesFilter<"MasterDefect"> | Date | string | null
    deactivatedById?: IntNullableWithAggregatesFilter<"MasterDefect"> | number | null
  }

  export type StandardCostWhereInput = {
    AND?: StandardCostWhereInput | StandardCostWhereInput[]
    OR?: StandardCostWhereInput[]
    NOT?: StandardCostWhereInput | StandardCostWhereInput[]
    id?: IntFilter<"StandardCost"> | number
    itemName?: StringFilter<"StandardCost"> | string
    description?: StringNullableFilter<"StandardCost"> | string | null
    costPerUnit?: DecimalFilter<"StandardCost"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"StandardCost"> | string
    isActive?: BoolFilter<"StandardCost"> | boolean
    createdAt?: DateTimeFilter<"StandardCost"> | Date | string
    updatedAt?: DateTimeFilter<"StandardCost"> | Date | string
    createdById?: IntNullableFilter<"StandardCost"> | number | null
    updatedById?: IntNullableFilter<"StandardCost"> | number | null
  }

  export type StandardCostOrderByWithRelationInput = {
    id?: SortOrder
    itemName?: SortOrder
    description?: SortOrderInput | SortOrder
    costPerUnit?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
  }

  export type StandardCostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    itemName?: string
    AND?: StandardCostWhereInput | StandardCostWhereInput[]
    OR?: StandardCostWhereInput[]
    NOT?: StandardCostWhereInput | StandardCostWhereInput[]
    description?: StringNullableFilter<"StandardCost"> | string | null
    costPerUnit?: DecimalFilter<"StandardCost"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"StandardCost"> | string
    isActive?: BoolFilter<"StandardCost"> | boolean
    createdAt?: DateTimeFilter<"StandardCost"> | Date | string
    updatedAt?: DateTimeFilter<"StandardCost"> | Date | string
    createdById?: IntNullableFilter<"StandardCost"> | number | null
    updatedById?: IntNullableFilter<"StandardCost"> | number | null
  }, "id" | "itemName">

  export type StandardCostOrderByWithAggregationInput = {
    id?: SortOrder
    itemName?: SortOrder
    description?: SortOrderInput | SortOrder
    costPerUnit?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: StandardCostCountOrderByAggregateInput
    _avg?: StandardCostAvgOrderByAggregateInput
    _max?: StandardCostMaxOrderByAggregateInput
    _min?: StandardCostMinOrderByAggregateInput
    _sum?: StandardCostSumOrderByAggregateInput
  }

  export type StandardCostScalarWhereWithAggregatesInput = {
    AND?: StandardCostScalarWhereWithAggregatesInput | StandardCostScalarWhereWithAggregatesInput[]
    OR?: StandardCostScalarWhereWithAggregatesInput[]
    NOT?: StandardCostScalarWhereWithAggregatesInput | StandardCostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StandardCost"> | number
    itemName?: StringWithAggregatesFilter<"StandardCost"> | string
    description?: StringNullableWithAggregatesFilter<"StandardCost"> | string | null
    costPerUnit?: DecimalWithAggregatesFilter<"StandardCost"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"StandardCost"> | string
    isActive?: BoolWithAggregatesFilter<"StandardCost"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StandardCost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StandardCost"> | Date | string
    createdById?: IntNullableWithAggregatesFilter<"StandardCost"> | number | null
    updatedById?: IntNullableWithAggregatesFilter<"StandardCost"> | number | null
  }

  export type OperationDefectWhereInput = {
    AND?: OperationDefectWhereInput | OperationDefectWhereInput[]
    OR?: OperationDefectWhereInput[]
    NOT?: OperationDefectWhereInput | OperationDefectWhereInput[]
    id?: IntFilter<"OperationDefect"> | number
    operationId?: IntFilter<"OperationDefect"> | number
    defectId?: IntNullableFilter<"OperationDefect"> | number | null
    defectName?: StringNullableFilter<"OperationDefect"> | string | null
    defectCategory?: StringFilter<"OperationDefect"> | string
    defectMachine?: StringNullableFilter<"OperationDefect"> | string | null
    defectReworkable?: BoolFilter<"OperationDefect"> | boolean
    quantity?: IntFilter<"OperationDefect"> | number
    quantityRework?: IntFilter<"OperationDefect"> | number
    quantityNogood?: IntFilter<"OperationDefect"> | number
    quantityReplacement?: IntFilter<"OperationDefect"> | number
    recordedAt?: DateTimeFilter<"OperationDefect"> | Date | string
    recordedById?: IntFilter<"OperationDefect"> | number
    editRequests?: OperationDefectEditRequestListRelationFilter
    defect?: XOR<MasterDefectNullableRelationFilter, MasterDefectWhereInput> | null
    operation?: XOR<OperationRelationFilter, OperationWhereInput>
    recordedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OperationDefectOrderByWithRelationInput = {
    id?: SortOrder
    operationId?: SortOrder
    defectId?: SortOrderInput | SortOrder
    defectName?: SortOrderInput | SortOrder
    defectCategory?: SortOrder
    defectMachine?: SortOrderInput | SortOrder
    defectReworkable?: SortOrder
    quantity?: SortOrder
    quantityRework?: SortOrder
    quantityNogood?: SortOrder
    quantityReplacement?: SortOrder
    recordedAt?: SortOrder
    recordedById?: SortOrder
    editRequests?: OperationDefectEditRequestOrderByRelationAggregateInput
    defect?: MasterDefectOrderByWithRelationInput
    operation?: OperationOrderByWithRelationInput
    recordedBy?: UserOrderByWithRelationInput
  }

  export type OperationDefectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    operationId_defectId_recordedAt?: OperationDefectOperationIdDefectIdRecordedAtCompoundUniqueInput
    AND?: OperationDefectWhereInput | OperationDefectWhereInput[]
    OR?: OperationDefectWhereInput[]
    NOT?: OperationDefectWhereInput | OperationDefectWhereInput[]
    operationId?: IntFilter<"OperationDefect"> | number
    defectId?: IntNullableFilter<"OperationDefect"> | number | null
    defectName?: StringNullableFilter<"OperationDefect"> | string | null
    defectCategory?: StringFilter<"OperationDefect"> | string
    defectMachine?: StringNullableFilter<"OperationDefect"> | string | null
    defectReworkable?: BoolFilter<"OperationDefect"> | boolean
    quantity?: IntFilter<"OperationDefect"> | number
    quantityRework?: IntFilter<"OperationDefect"> | number
    quantityNogood?: IntFilter<"OperationDefect"> | number
    quantityReplacement?: IntFilter<"OperationDefect"> | number
    recordedAt?: DateTimeFilter<"OperationDefect"> | Date | string
    recordedById?: IntFilter<"OperationDefect"> | number
    editRequests?: OperationDefectEditRequestListRelationFilter
    defect?: XOR<MasterDefectNullableRelationFilter, MasterDefectWhereInput> | null
    operation?: XOR<OperationRelationFilter, OperationWhereInput>
    recordedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "operationId_defectId_recordedAt">

  export type OperationDefectOrderByWithAggregationInput = {
    id?: SortOrder
    operationId?: SortOrder
    defectId?: SortOrderInput | SortOrder
    defectName?: SortOrderInput | SortOrder
    defectCategory?: SortOrder
    defectMachine?: SortOrderInput | SortOrder
    defectReworkable?: SortOrder
    quantity?: SortOrder
    quantityRework?: SortOrder
    quantityNogood?: SortOrder
    quantityReplacement?: SortOrder
    recordedAt?: SortOrder
    recordedById?: SortOrder
    _count?: OperationDefectCountOrderByAggregateInput
    _avg?: OperationDefectAvgOrderByAggregateInput
    _max?: OperationDefectMaxOrderByAggregateInput
    _min?: OperationDefectMinOrderByAggregateInput
    _sum?: OperationDefectSumOrderByAggregateInput
  }

  export type OperationDefectScalarWhereWithAggregatesInput = {
    AND?: OperationDefectScalarWhereWithAggregatesInput | OperationDefectScalarWhereWithAggregatesInput[]
    OR?: OperationDefectScalarWhereWithAggregatesInput[]
    NOT?: OperationDefectScalarWhereWithAggregatesInput | OperationDefectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OperationDefect"> | number
    operationId?: IntWithAggregatesFilter<"OperationDefect"> | number
    defectId?: IntNullableWithAggregatesFilter<"OperationDefect"> | number | null
    defectName?: StringNullableWithAggregatesFilter<"OperationDefect"> | string | null
    defectCategory?: StringWithAggregatesFilter<"OperationDefect"> | string
    defectMachine?: StringNullableWithAggregatesFilter<"OperationDefect"> | string | null
    defectReworkable?: BoolWithAggregatesFilter<"OperationDefect"> | boolean
    quantity?: IntWithAggregatesFilter<"OperationDefect"> | number
    quantityRework?: IntWithAggregatesFilter<"OperationDefect"> | number
    quantityNogood?: IntWithAggregatesFilter<"OperationDefect"> | number
    quantityReplacement?: IntWithAggregatesFilter<"OperationDefect"> | number
    recordedAt?: DateTimeWithAggregatesFilter<"OperationDefect"> | Date | string
    recordedById?: IntWithAggregatesFilter<"OperationDefect"> | number
  }

  export type OperationDefectEditRequestWhereInput = {
    AND?: OperationDefectEditRequestWhereInput | OperationDefectEditRequestWhereInput[]
    OR?: OperationDefectEditRequestWhereInput[]
    NOT?: OperationDefectEditRequestWhereInput | OperationDefectEditRequestWhereInput[]
    id?: IntFilter<"OperationDefectEditRequest"> | number
    operationDefectId?: IntNullableFilter<"OperationDefectEditRequest"> | number | null
    operationId?: IntFilter<"OperationDefectEditRequest"> | number
    productionOrderId?: IntFilter<"OperationDefectEditRequest"> | number
    requestedById?: IntFilter<"OperationDefectEditRequest"> | number
    requestType?: StringFilter<"OperationDefectEditRequest"> | string
    defectId?: IntNullableFilter<"OperationDefectEditRequest"> | number | null
    defectName?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    defectCategory?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    defectReworkable?: BoolNullableFilter<"OperationDefectEditRequest"> | boolean | null
    defectMachine?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    currentQty?: IntFilter<"OperationDefectEditRequest"> | number
    currentRw?: IntFilter<"OperationDefectEditRequest"> | number
    currentNg?: IntFilter<"OperationDefectEditRequest"> | number
    currentReplacement?: IntFilter<"OperationDefectEditRequest"> | number
    requestedQty?: IntFilter<"OperationDefectEditRequest"> | number
    requestedRw?: IntFilter<"OperationDefectEditRequest"> | number
    requestedNg?: IntFilter<"OperationDefectEditRequest"> | number
    requestedReplacement?: IntFilter<"OperationDefectEditRequest"> | number
    operationCode?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    reason?: StringFilter<"OperationDefectEditRequest"> | string
    status?: StringFilter<"OperationDefectEditRequest"> | string
    resolvedById?: IntNullableFilter<"OperationDefectEditRequest"> | number | null
    resolutionNote?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    createdAt?: DateTimeFilter<"OperationDefectEditRequest"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"OperationDefectEditRequest"> | Date | string | null
    operationDefect?: XOR<OperationDefectNullableRelationFilter, OperationDefectWhereInput> | null
    operation?: XOR<OperationRelationFilter, OperationWhereInput>
    productionOrder?: XOR<ProductionOrderRelationFilter, ProductionOrderWhereInput>
    requestedBy?: XOR<UserRelationFilter, UserWhereInput>
    resolvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type OperationDefectEditRequestOrderByWithRelationInput = {
    id?: SortOrder
    operationDefectId?: SortOrderInput | SortOrder
    operationId?: SortOrder
    productionOrderId?: SortOrder
    requestedById?: SortOrder
    requestType?: SortOrder
    defectId?: SortOrderInput | SortOrder
    defectName?: SortOrderInput | SortOrder
    defectCategory?: SortOrderInput | SortOrder
    defectReworkable?: SortOrderInput | SortOrder
    defectMachine?: SortOrderInput | SortOrder
    currentQty?: SortOrder
    currentRw?: SortOrder
    currentNg?: SortOrder
    currentReplacement?: SortOrder
    requestedQty?: SortOrder
    requestedRw?: SortOrder
    requestedNg?: SortOrder
    requestedReplacement?: SortOrder
    operationCode?: SortOrderInput | SortOrder
    reason?: SortOrder
    status?: SortOrder
    resolvedById?: SortOrderInput | SortOrder
    resolutionNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    operationDefect?: OperationDefectOrderByWithRelationInput
    operation?: OperationOrderByWithRelationInput
    productionOrder?: ProductionOrderOrderByWithRelationInput
    requestedBy?: UserOrderByWithRelationInput
    resolvedBy?: UserOrderByWithRelationInput
  }

  export type OperationDefectEditRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OperationDefectEditRequestWhereInput | OperationDefectEditRequestWhereInput[]
    OR?: OperationDefectEditRequestWhereInput[]
    NOT?: OperationDefectEditRequestWhereInput | OperationDefectEditRequestWhereInput[]
    operationDefectId?: IntNullableFilter<"OperationDefectEditRequest"> | number | null
    operationId?: IntFilter<"OperationDefectEditRequest"> | number
    productionOrderId?: IntFilter<"OperationDefectEditRequest"> | number
    requestedById?: IntFilter<"OperationDefectEditRequest"> | number
    requestType?: StringFilter<"OperationDefectEditRequest"> | string
    defectId?: IntNullableFilter<"OperationDefectEditRequest"> | number | null
    defectName?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    defectCategory?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    defectReworkable?: BoolNullableFilter<"OperationDefectEditRequest"> | boolean | null
    defectMachine?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    currentQty?: IntFilter<"OperationDefectEditRequest"> | number
    currentRw?: IntFilter<"OperationDefectEditRequest"> | number
    currentNg?: IntFilter<"OperationDefectEditRequest"> | number
    currentReplacement?: IntFilter<"OperationDefectEditRequest"> | number
    requestedQty?: IntFilter<"OperationDefectEditRequest"> | number
    requestedRw?: IntFilter<"OperationDefectEditRequest"> | number
    requestedNg?: IntFilter<"OperationDefectEditRequest"> | number
    requestedReplacement?: IntFilter<"OperationDefectEditRequest"> | number
    operationCode?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    reason?: StringFilter<"OperationDefectEditRequest"> | string
    status?: StringFilter<"OperationDefectEditRequest"> | string
    resolvedById?: IntNullableFilter<"OperationDefectEditRequest"> | number | null
    resolutionNote?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    createdAt?: DateTimeFilter<"OperationDefectEditRequest"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"OperationDefectEditRequest"> | Date | string | null
    operationDefect?: XOR<OperationDefectNullableRelationFilter, OperationDefectWhereInput> | null
    operation?: XOR<OperationRelationFilter, OperationWhereInput>
    productionOrder?: XOR<ProductionOrderRelationFilter, ProductionOrderWhereInput>
    requestedBy?: XOR<UserRelationFilter, UserWhereInput>
    resolvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type OperationDefectEditRequestOrderByWithAggregationInput = {
    id?: SortOrder
    operationDefectId?: SortOrderInput | SortOrder
    operationId?: SortOrder
    productionOrderId?: SortOrder
    requestedById?: SortOrder
    requestType?: SortOrder
    defectId?: SortOrderInput | SortOrder
    defectName?: SortOrderInput | SortOrder
    defectCategory?: SortOrderInput | SortOrder
    defectReworkable?: SortOrderInput | SortOrder
    defectMachine?: SortOrderInput | SortOrder
    currentQty?: SortOrder
    currentRw?: SortOrder
    currentNg?: SortOrder
    currentReplacement?: SortOrder
    requestedQty?: SortOrder
    requestedRw?: SortOrder
    requestedNg?: SortOrder
    requestedReplacement?: SortOrder
    operationCode?: SortOrderInput | SortOrder
    reason?: SortOrder
    status?: SortOrder
    resolvedById?: SortOrderInput | SortOrder
    resolutionNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: OperationDefectEditRequestCountOrderByAggregateInput
    _avg?: OperationDefectEditRequestAvgOrderByAggregateInput
    _max?: OperationDefectEditRequestMaxOrderByAggregateInput
    _min?: OperationDefectEditRequestMinOrderByAggregateInput
    _sum?: OperationDefectEditRequestSumOrderByAggregateInput
  }

  export type OperationDefectEditRequestScalarWhereWithAggregatesInput = {
    AND?: OperationDefectEditRequestScalarWhereWithAggregatesInput | OperationDefectEditRequestScalarWhereWithAggregatesInput[]
    OR?: OperationDefectEditRequestScalarWhereWithAggregatesInput[]
    NOT?: OperationDefectEditRequestScalarWhereWithAggregatesInput | OperationDefectEditRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    operationDefectId?: IntNullableWithAggregatesFilter<"OperationDefectEditRequest"> | number | null
    operationId?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    productionOrderId?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    requestedById?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    requestType?: StringWithAggregatesFilter<"OperationDefectEditRequest"> | string
    defectId?: IntNullableWithAggregatesFilter<"OperationDefectEditRequest"> | number | null
    defectName?: StringNullableWithAggregatesFilter<"OperationDefectEditRequest"> | string | null
    defectCategory?: StringNullableWithAggregatesFilter<"OperationDefectEditRequest"> | string | null
    defectReworkable?: BoolNullableWithAggregatesFilter<"OperationDefectEditRequest"> | boolean | null
    defectMachine?: StringNullableWithAggregatesFilter<"OperationDefectEditRequest"> | string | null
    currentQty?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    currentRw?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    currentNg?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    currentReplacement?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    requestedQty?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    requestedRw?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    requestedNg?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    requestedReplacement?: IntWithAggregatesFilter<"OperationDefectEditRequest"> | number
    operationCode?: StringNullableWithAggregatesFilter<"OperationDefectEditRequest"> | string | null
    reason?: StringWithAggregatesFilter<"OperationDefectEditRequest"> | string
    status?: StringWithAggregatesFilter<"OperationDefectEditRequest"> | string
    resolvedById?: IntNullableWithAggregatesFilter<"OperationDefectEditRequest"> | number | null
    resolutionNote?: StringNullableWithAggregatesFilter<"OperationDefectEditRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OperationDefectEditRequest"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"OperationDefectEditRequest"> | Date | string | null
  }

  export type OperationStepWhereInput = {
    AND?: OperationStepWhereInput | OperationStepWhereInput[]
    OR?: OperationStepWhereInput[]
    NOT?: OperationStepWhereInput | OperationStepWhereInput[]
    id?: IntFilter<"OperationStep"> | number
    label?: StringFilter<"OperationStep"> | string
    operationNumber?: StringFilter<"OperationStep"> | string
    stepOrder?: IntFilter<"OperationStep"> | number
  }

  export type OperationStepOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    operationNumber?: SortOrder
    stepOrder?: SortOrder
  }

  export type OperationStepWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    operationNumber?: string
    AND?: OperationStepWhereInput | OperationStepWhereInput[]
    OR?: OperationStepWhereInput[]
    NOT?: OperationStepWhereInput | OperationStepWhereInput[]
    label?: StringFilter<"OperationStep"> | string
    stepOrder?: IntFilter<"OperationStep"> | number
  }, "id" | "operationNumber">

  export type OperationStepOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    operationNumber?: SortOrder
    stepOrder?: SortOrder
    _count?: OperationStepCountOrderByAggregateInput
    _avg?: OperationStepAvgOrderByAggregateInput
    _max?: OperationStepMaxOrderByAggregateInput
    _min?: OperationStepMinOrderByAggregateInput
    _sum?: OperationStepSumOrderByAggregateInput
  }

  export type OperationStepScalarWhereWithAggregatesInput = {
    AND?: OperationStepScalarWhereWithAggregatesInput | OperationStepScalarWhereWithAggregatesInput[]
    OR?: OperationStepScalarWhereWithAggregatesInput[]
    NOT?: OperationStepScalarWhereWithAggregatesInput | OperationStepScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OperationStep"> | number
    label?: StringWithAggregatesFilter<"OperationStep"> | string
    operationNumber?: StringWithAggregatesFilter<"OperationStep"> | string
    stepOrder?: IntWithAggregatesFilter<"OperationStep"> | number
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    oldValues?: StringNullableFilter<"AuditLog"> | string | null
    newValues?: StringNullableFilter<"AuditLog"> | string | null
    userId?: IntFilter<"AuditLog"> | number
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    oldValues?: StringNullableFilter<"AuditLog"> | string | null
    newValues?: StringNullableFilter<"AuditLog"> | string | null
    userId?: IntFilter<"AuditLog"> | number
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    tableName?: StringWithAggregatesFilter<"AuditLog"> | string
    recordId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValues?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    newValues?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: IntWithAggregatesFilter<"AuditLog"> | number
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    lastActivity?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    lastActivity?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    userId?: IntWithAggregatesFilter<"Session"> | number
    token?: StringWithAggregatesFilter<"Session"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    lastActivity?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    linkUrl?: StringNullableFilter<"Notification"> | string | null
    userId?: IntFilter<"Notification"> | number
    sourceId?: StringNullableFilter<"Notification"> | string | null
    sourceType?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    linkUrl?: SortOrderInput | SortOrder
    userId?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    sourceType?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    linkUrl?: StringNullableFilter<"Notification"> | string | null
    userId?: IntFilter<"Notification"> | number
    sourceId?: StringNullableFilter<"Notification"> | string | null
    sourceType?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    linkUrl?: SortOrderInput | SortOrder
    userId?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    sourceType?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    linkUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    userId?: IntWithAggregatesFilter<"Notification"> | number
    sourceId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    sourceType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
  }

  export type OperationLineWhereInput = {
    AND?: OperationLineWhereInput | OperationLineWhereInput[]
    OR?: OperationLineWhereInput[]
    NOT?: OperationLineWhereInput | OperationLineWhereInput[]
    id?: IntFilter<"OperationLine"> | number
    operationNumber?: StringFilter<"OperationLine"> | string
    lineNumber?: StringFilter<"OperationLine"> | string
  }

  export type OperationLineOrderByWithRelationInput = {
    id?: SortOrder
    operationNumber?: SortOrder
    lineNumber?: SortOrder
  }

  export type OperationLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    operationNumber_lineNumber?: OperationLineOperationNumberLineNumberCompoundUniqueInput
    AND?: OperationLineWhereInput | OperationLineWhereInput[]
    OR?: OperationLineWhereInput[]
    NOT?: OperationLineWhereInput | OperationLineWhereInput[]
    operationNumber?: StringFilter<"OperationLine"> | string
    lineNumber?: StringFilter<"OperationLine"> | string
  }, "id" | "operationNumber_lineNumber">

  export type OperationLineOrderByWithAggregationInput = {
    id?: SortOrder
    operationNumber?: SortOrder
    lineNumber?: SortOrder
    _count?: OperationLineCountOrderByAggregateInput
    _avg?: OperationLineAvgOrderByAggregateInput
    _max?: OperationLineMaxOrderByAggregateInput
    _min?: OperationLineMinOrderByAggregateInput
    _sum?: OperationLineSumOrderByAggregateInput
  }

  export type OperationLineScalarWhereWithAggregatesInput = {
    AND?: OperationLineScalarWhereWithAggregatesInput | OperationLineScalarWhereWithAggregatesInput[]
    OR?: OperationLineScalarWhereWithAggregatesInput[]
    NOT?: OperationLineScalarWhereWithAggregatesInput | OperationLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OperationLine"> | number
    operationNumber?: StringWithAggregatesFilter<"OperationLine"> | string
    lineNumber?: StringWithAggregatesFilter<"OperationLine"> | string
  }

  export type UserCreateInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationCreateNestedManyWithoutEncodedByInput
    operations?: OperationCreateNestedManyWithoutOperatorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectUncheckedCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectUncheckedCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationUncheckedCreateNestedManyWithoutEncodedByInput
    operations?: OperationUncheckedCreateNestedManyWithoutOperatorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUncheckedUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUncheckedUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUncheckedUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUncheckedUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionOrderCreateInput = {
    poNumber: string
    lotNumber?: string | null
    poQuantity: number
    itemName?: string | null
    status: string
    currentOperation?: string | null
    currentOperationStartTime?: Date | string | null
    currentOperationEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    editingUserId?: number | null
    editingUserName?: string | null
    lockedAt?: Date | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: Date | string | null
    editRequests?: OperationDefectEditRequestCreateNestedManyWithoutProductionOrderInput
    operations?: OperationCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderUncheckedCreateInput = {
    id?: number
    poNumber: string
    lotNumber?: string | null
    poQuantity: number
    itemName?: string | null
    status: string
    currentOperation?: string | null
    currentOperationStartTime?: Date | string | null
    currentOperationEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    editingUserId?: number | null
    editingUserName?: string | null
    lockedAt?: Date | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: Date | string | null
    editRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutProductionOrderInput
    operations?: OperationUncheckedCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderUpdateInput = {
    poNumber?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    poQuantity?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentOperation?: NullableStringFieldUpdateOperationsInput | string | null
    currentOperationStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentOperationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editingUserId?: NullableIntFieldUpdateOperationsInput | number | null
    editingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editRequests?: OperationDefectEditRequestUpdateManyWithoutProductionOrderNestedInput
    operations?: OperationUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    poNumber?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    poQuantity?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentOperation?: NullableStringFieldUpdateOperationsInput | string | null
    currentOperationStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentOperationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editingUserId?: NullableIntFieldUpdateOperationsInput | number | null
    editingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutProductionOrderNestedInput
    operations?: OperationUncheckedUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderCreateManyInput = {
    id?: number
    poNumber: string
    lotNumber?: string | null
    poQuantity: number
    itemName?: string | null
    status: string
    currentOperation?: string | null
    currentOperationStartTime?: Date | string | null
    currentOperationEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    editingUserId?: number | null
    editingUserName?: string | null
    lockedAt?: Date | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: Date | string | null
  }

  export type ProductionOrderUpdateManyMutationInput = {
    poNumber?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    poQuantity?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentOperation?: NullableStringFieldUpdateOperationsInput | string | null
    currentOperationStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentOperationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editingUserId?: NullableIntFieldUpdateOperationsInput | number | null
    editingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductionOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    poNumber?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    poQuantity?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentOperation?: NullableStringFieldUpdateOperationsInput | string | null
    currentOperationStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentOperationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editingUserId?: NullableIntFieldUpdateOperationsInput | number | null
    editingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationCreateInput = {
    operation: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestCreateNestedManyWithoutOperationInput
    operationDefects?: OperationDefectCreateNestedManyWithoutOperationInput
    encodedBy: UserCreateNestedOneWithoutEncodedOperationsInput
    operator: UserCreateNestedOneWithoutOperationsInput
    productionOrder: ProductionOrderCreateNestedOneWithoutOperationsInput
  }

  export type OperationUncheckedCreateInput = {
    id?: number
    productionOrderId: number
    operation: string
    operatorId: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedById: number
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutOperationInput
    operationDefects?: OperationDefectUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationUpdateInput = {
    operation?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUpdateManyWithoutOperationNestedInput
    operationDefects?: OperationDefectUpdateManyWithoutOperationNestedInput
    encodedBy?: UserUpdateOneRequiredWithoutEncodedOperationsNestedInput
    operator?: UserUpdateOneRequiredWithoutOperationsNestedInput
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type OperationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    operation?: StringFieldUpdateOperationsInput | string
    operatorId?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedById?: IntFieldUpdateOperationsInput | number
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutOperationNestedInput
    operationDefects?: OperationDefectUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type OperationCreateManyInput = {
    id?: number
    productionOrderId: number
    operation: string
    operatorId: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedById: number
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type OperationUpdateManyMutationInput = {
    operation?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type OperationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    operation?: StringFieldUpdateOperationsInput | string
    operatorId?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedById?: IntFieldUpdateOperationsInput | number
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type MasterDefectCreateInput = {
    name: string
    description?: string | null
    category?: string | null
    applicableOperation?: string | null
    reworkable?: boolean
    machine?: string | null
    isActive?: boolean
    deactivatedAt?: Date | string | null
    deactivatedBy?: UserCreateNestedOneWithoutDeactivatedDefectsInput
    operationDefects?: OperationDefectCreateNestedManyWithoutDefectInput
  }

  export type MasterDefectUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    applicableOperation?: string | null
    reworkable?: boolean
    machine?: string | null
    isActive?: boolean
    deactivatedAt?: Date | string | null
    deactivatedById?: number | null
    operationDefects?: OperationDefectUncheckedCreateNestedManyWithoutDefectInput
  }

  export type MasterDefectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    applicableOperation?: NullableStringFieldUpdateOperationsInput | string | null
    reworkable?: BoolFieldUpdateOperationsInput | boolean
    machine?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: UserUpdateOneWithoutDeactivatedDefectsNestedInput
    operationDefects?: OperationDefectUpdateManyWithoutDefectNestedInput
  }

  export type MasterDefectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    applicableOperation?: NullableStringFieldUpdateOperationsInput | string | null
    reworkable?: BoolFieldUpdateOperationsInput | boolean
    machine?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedById?: NullableIntFieldUpdateOperationsInput | number | null
    operationDefects?: OperationDefectUncheckedUpdateManyWithoutDefectNestedInput
  }

  export type MasterDefectCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    applicableOperation?: string | null
    reworkable?: boolean
    machine?: string | null
    isActive?: boolean
    deactivatedAt?: Date | string | null
    deactivatedById?: number | null
  }

  export type MasterDefectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    applicableOperation?: NullableStringFieldUpdateOperationsInput | string | null
    reworkable?: BoolFieldUpdateOperationsInput | boolean
    machine?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MasterDefectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    applicableOperation?: NullableStringFieldUpdateOperationsInput | string | null
    reworkable?: BoolFieldUpdateOperationsInput | boolean
    machine?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StandardCostCreateInput = {
    itemName: string
    description?: string | null
    costPerUnit: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type StandardCostUncheckedCreateInput = {
    id?: number
    itemName: string
    description?: string | null
    costPerUnit: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type StandardCostUpdateInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StandardCostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StandardCostCreateManyInput = {
    id?: number
    itemName: string
    description?: string | null
    costPerUnit: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type StandardCostUpdateManyMutationInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StandardCostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPerUnit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperationDefectCreateInput = {
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    editRequests?: OperationDefectEditRequestCreateNestedManyWithoutOperationDefectInput
    defect?: MasterDefectCreateNestedOneWithoutOperationDefectsInput
    operation: OperationCreateNestedOneWithoutOperationDefectsInput
    recordedBy: UserCreateNestedOneWithoutRecordedDefectsInput
  }

  export type OperationDefectUncheckedCreateInput = {
    id?: number
    operationId: number
    defectId?: number | null
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    recordedById: number
    editRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutOperationDefectInput
  }

  export type OperationDefectUpdateInput = {
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editRequests?: OperationDefectEditRequestUpdateManyWithoutOperationDefectNestedInput
    defect?: MasterDefectUpdateOneWithoutOperationDefectsNestedInput
    operation?: OperationUpdateOneRequiredWithoutOperationDefectsNestedInput
    recordedBy?: UserUpdateOneRequiredWithoutRecordedDefectsNestedInput
  }

  export type OperationDefectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationId?: IntFieldUpdateOperationsInput | number
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: IntFieldUpdateOperationsInput | number
    editRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutOperationDefectNestedInput
  }

  export type OperationDefectCreateManyInput = {
    id?: number
    operationId: number
    defectId?: number | null
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    recordedById: number
  }

  export type OperationDefectUpdateManyMutationInput = {
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationDefectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationId?: IntFieldUpdateOperationsInput | number
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: IntFieldUpdateOperationsInput | number
  }

  export type OperationDefectEditRequestCreateInput = {
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    operationDefect?: OperationDefectCreateNestedOneWithoutEditRequestsInput
    operation: OperationCreateNestedOneWithoutEditRequestsInput
    productionOrder: ProductionOrderCreateNestedOneWithoutEditRequestsInput
    requestedBy: UserCreateNestedOneWithoutRequestedEditRequestsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedEditRequestsInput
  }

  export type OperationDefectEditRequestUncheckedCreateInput = {
    id?: number
    operationDefectId?: number | null
    operationId: number
    productionOrderId: number
    requestedById: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolvedById?: number | null
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationDefectEditRequestUpdateInput = {
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDefect?: OperationDefectUpdateOneWithoutEditRequestsNestedInput
    operation?: OperationUpdateOneRequiredWithoutEditRequestsNestedInput
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutEditRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRequestedEditRequestsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedEditRequestsNestedInput
  }

  export type OperationDefectEditRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationDefectId?: NullableIntFieldUpdateOperationsInput | number | null
    operationId?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationDefectEditRequestCreateManyInput = {
    id?: number
    operationDefectId?: number | null
    operationId: number
    productionOrderId: number
    requestedById: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolvedById?: number | null
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationDefectEditRequestUpdateManyMutationInput = {
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationDefectEditRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationDefectId?: NullableIntFieldUpdateOperationsInput | number | null
    operationId?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationStepCreateInput = {
    label: string
    operationNumber: string
    stepOrder: number
  }

  export type OperationStepUncheckedCreateInput = {
    id?: number
    label: string
    operationNumber: string
    stepOrder: number
  }

  export type OperationStepUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    operationNumber?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
  }

  export type OperationStepUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    operationNumber?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
  }

  export type OperationStepCreateManyInput = {
    id?: number
    label: string
    operationNumber: string
    stepOrder: number
  }

  export type OperationStepUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    operationNumber?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
  }

  export type OperationStepUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    operationNumber?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
  }

  export type AuditLogCreateInput = {
    tableName: string
    recordId: string
    action: string
    oldValues?: string | null
    newValues?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    tableName: string
    recordId: string
    action: string
    oldValues?: string | null
    newValues?: string | null
    userId: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditLogUpdateInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateManyInput = {
    id?: number
    tableName: string
    recordId: string
    action: string
    oldValues?: string | null
    newValues?: string | null
    userId: number
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditLogUpdateManyMutationInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivity?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivity?: Date | string
  }

  export type SessionUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: number
    userId: number
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivity?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    linkUrl?: string | null
    sourceId?: string | null
    sourceType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    linkUrl?: string | null
    userId: number
    sourceId?: string | null
    sourceType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    linkUrl?: string | null
    userId: number
    sourceId?: string | null
    sourceType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OperationLineCreateInput = {
    operationNumber: string
    lineNumber: string
  }

  export type OperationLineUncheckedCreateInput = {
    id?: number
    operationNumber: string
    lineNumber: string
  }

  export type OperationLineUpdateInput = {
    operationNumber?: StringFieldUpdateOperationsInput | string
    lineNumber?: StringFieldUpdateOperationsInput | string
  }

  export type OperationLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationNumber?: StringFieldUpdateOperationsInput | string
    lineNumber?: StringFieldUpdateOperationsInput | string
  }

  export type OperationLineCreateManyInput = {
    id?: number
    operationNumber: string
    lineNumber: string
  }

  export type OperationLineUpdateManyMutationInput = {
    operationNumber?: StringFieldUpdateOperationsInput | string
    lineNumber?: StringFieldUpdateOperationsInput | string
  }

  export type OperationLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationNumber?: StringFieldUpdateOperationsInput | string
    lineNumber?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type MasterDefectListRelationFilter = {
    every?: MasterDefectWhereInput
    some?: MasterDefectWhereInput
    none?: MasterDefectWhereInput
  }

  export type OperationDefectEditRequestListRelationFilter = {
    every?: OperationDefectEditRequestWhereInput
    some?: OperationDefectEditRequestWhereInput
    none?: OperationDefectEditRequestWhereInput
  }

  export type OperationDefectListRelationFilter = {
    every?: OperationDefectWhereInput
    some?: OperationDefectWhereInput
    none?: OperationDefectWhereInput
  }

  export type OperationListRelationFilter = {
    every?: OperationWhereInput
    some?: OperationWhereInput
    none?: OperationWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MasterDefectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationDefectEditRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationDefectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrder
    department?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrder
    department?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    lastLogin?: SortOrder
    department?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductionOrderCountOrderByAggregateInput = {
    id?: SortOrder
    poNumber?: SortOrder
    lotNumber?: SortOrder
    poQuantity?: SortOrder
    itemName?: SortOrder
    status?: SortOrder
    currentOperation?: SortOrder
    currentOperationStartTime?: SortOrder
    currentOperationEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    editingUserId?: SortOrder
    editingUserName?: SortOrder
    lockedAt?: SortOrder
    costPerUnit?: SortOrder
    totalDefectCost?: SortOrder
    lastCostUpdate?: SortOrder
  }

  export type ProductionOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    poQuantity?: SortOrder
    editingUserId?: SortOrder
    costPerUnit?: SortOrder
    totalDefectCost?: SortOrder
  }

  export type ProductionOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    poNumber?: SortOrder
    lotNumber?: SortOrder
    poQuantity?: SortOrder
    itemName?: SortOrder
    status?: SortOrder
    currentOperation?: SortOrder
    currentOperationStartTime?: SortOrder
    currentOperationEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    editingUserId?: SortOrder
    editingUserName?: SortOrder
    lockedAt?: SortOrder
    costPerUnit?: SortOrder
    totalDefectCost?: SortOrder
    lastCostUpdate?: SortOrder
  }

  export type ProductionOrderMinOrderByAggregateInput = {
    id?: SortOrder
    poNumber?: SortOrder
    lotNumber?: SortOrder
    poQuantity?: SortOrder
    itemName?: SortOrder
    status?: SortOrder
    currentOperation?: SortOrder
    currentOperationStartTime?: SortOrder
    currentOperationEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    editingUserId?: SortOrder
    editingUserName?: SortOrder
    lockedAt?: SortOrder
    costPerUnit?: SortOrder
    totalDefectCost?: SortOrder
    lastCostUpdate?: SortOrder
  }

  export type ProductionOrderSumOrderByAggregateInput = {
    id?: SortOrder
    poQuantity?: SortOrder
    editingUserId?: SortOrder
    costPerUnit?: SortOrder
    totalDefectCost?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProductionOrderRelationFilter = {
    is?: ProductionOrderWhereInput
    isNot?: ProductionOrderWhereInput
  }

  export type OperationCountOrderByAggregateInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    operation?: SortOrder
    operatorId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    inputQuantity?: SortOrder
    outputQuantity?: SortOrder
    productionHours?: SortOrder
    accumulatedManHours?: SortOrder
    rf?: SortOrder
    lineNo?: SortOrder
    shift?: SortOrder
    encodedById?: SortOrder
    encodedTime?: SortOrder
    defectCost?: SortOrder
  }

  export type OperationAvgOrderByAggregateInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    operatorId?: SortOrder
    inputQuantity?: SortOrder
    outputQuantity?: SortOrder
    productionHours?: SortOrder
    accumulatedManHours?: SortOrder
    rf?: SortOrder
    encodedById?: SortOrder
    defectCost?: SortOrder
  }

  export type OperationMaxOrderByAggregateInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    operation?: SortOrder
    operatorId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    inputQuantity?: SortOrder
    outputQuantity?: SortOrder
    productionHours?: SortOrder
    accumulatedManHours?: SortOrder
    rf?: SortOrder
    lineNo?: SortOrder
    shift?: SortOrder
    encodedById?: SortOrder
    encodedTime?: SortOrder
    defectCost?: SortOrder
  }

  export type OperationMinOrderByAggregateInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    operation?: SortOrder
    operatorId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    inputQuantity?: SortOrder
    outputQuantity?: SortOrder
    productionHours?: SortOrder
    accumulatedManHours?: SortOrder
    rf?: SortOrder
    lineNo?: SortOrder
    shift?: SortOrder
    encodedById?: SortOrder
    encodedTime?: SortOrder
    defectCost?: SortOrder
  }

  export type OperationSumOrderByAggregateInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    operatorId?: SortOrder
    inputQuantity?: SortOrder
    outputQuantity?: SortOrder
    productionHours?: SortOrder
    accumulatedManHours?: SortOrder
    rf?: SortOrder
    encodedById?: SortOrder
    defectCost?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MasterDefectNameApplicableOperationCompoundUniqueInput = {
    name: string
    applicableOperation: string
  }

  export type MasterDefectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    applicableOperation?: SortOrder
    reworkable?: SortOrder
    machine?: SortOrder
    isActive?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedById?: SortOrder
  }

  export type MasterDefectAvgOrderByAggregateInput = {
    id?: SortOrder
    deactivatedById?: SortOrder
  }

  export type MasterDefectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    applicableOperation?: SortOrder
    reworkable?: SortOrder
    machine?: SortOrder
    isActive?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedById?: SortOrder
  }

  export type MasterDefectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    applicableOperation?: SortOrder
    reworkable?: SortOrder
    machine?: SortOrder
    isActive?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedById?: SortOrder
  }

  export type MasterDefectSumOrderByAggregateInput = {
    id?: SortOrder
    deactivatedById?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type StandardCostCountOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    description?: SortOrder
    costPerUnit?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type StandardCostAvgOrderByAggregateInput = {
    id?: SortOrder
    costPerUnit?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type StandardCostMaxOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    description?: SortOrder
    costPerUnit?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type StandardCostMinOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    description?: SortOrder
    costPerUnit?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type StandardCostSumOrderByAggregateInput = {
    id?: SortOrder
    costPerUnit?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type MasterDefectNullableRelationFilter = {
    is?: MasterDefectWhereInput | null
    isNot?: MasterDefectWhereInput | null
  }

  export type OperationRelationFilter = {
    is?: OperationWhereInput
    isNot?: OperationWhereInput
  }

  export type OperationDefectOperationIdDefectIdRecordedAtCompoundUniqueInput = {
    operationId: number
    defectId: number
    recordedAt: Date | string
  }

  export type OperationDefectCountOrderByAggregateInput = {
    id?: SortOrder
    operationId?: SortOrder
    defectId?: SortOrder
    defectName?: SortOrder
    defectCategory?: SortOrder
    defectMachine?: SortOrder
    defectReworkable?: SortOrder
    quantity?: SortOrder
    quantityRework?: SortOrder
    quantityNogood?: SortOrder
    quantityReplacement?: SortOrder
    recordedAt?: SortOrder
    recordedById?: SortOrder
  }

  export type OperationDefectAvgOrderByAggregateInput = {
    id?: SortOrder
    operationId?: SortOrder
    defectId?: SortOrder
    quantity?: SortOrder
    quantityRework?: SortOrder
    quantityNogood?: SortOrder
    quantityReplacement?: SortOrder
    recordedById?: SortOrder
  }

  export type OperationDefectMaxOrderByAggregateInput = {
    id?: SortOrder
    operationId?: SortOrder
    defectId?: SortOrder
    defectName?: SortOrder
    defectCategory?: SortOrder
    defectMachine?: SortOrder
    defectReworkable?: SortOrder
    quantity?: SortOrder
    quantityRework?: SortOrder
    quantityNogood?: SortOrder
    quantityReplacement?: SortOrder
    recordedAt?: SortOrder
    recordedById?: SortOrder
  }

  export type OperationDefectMinOrderByAggregateInput = {
    id?: SortOrder
    operationId?: SortOrder
    defectId?: SortOrder
    defectName?: SortOrder
    defectCategory?: SortOrder
    defectMachine?: SortOrder
    defectReworkable?: SortOrder
    quantity?: SortOrder
    quantityRework?: SortOrder
    quantityNogood?: SortOrder
    quantityReplacement?: SortOrder
    recordedAt?: SortOrder
    recordedById?: SortOrder
  }

  export type OperationDefectSumOrderByAggregateInput = {
    id?: SortOrder
    operationId?: SortOrder
    defectId?: SortOrder
    quantity?: SortOrder
    quantityRework?: SortOrder
    quantityNogood?: SortOrder
    quantityReplacement?: SortOrder
    recordedById?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type OperationDefectNullableRelationFilter = {
    is?: OperationDefectWhereInput | null
    isNot?: OperationDefectWhereInput | null
  }

  export type OperationDefectEditRequestCountOrderByAggregateInput = {
    id?: SortOrder
    operationDefectId?: SortOrder
    operationId?: SortOrder
    productionOrderId?: SortOrder
    requestedById?: SortOrder
    requestType?: SortOrder
    defectId?: SortOrder
    defectName?: SortOrder
    defectCategory?: SortOrder
    defectReworkable?: SortOrder
    defectMachine?: SortOrder
    currentQty?: SortOrder
    currentRw?: SortOrder
    currentNg?: SortOrder
    currentReplacement?: SortOrder
    requestedQty?: SortOrder
    requestedRw?: SortOrder
    requestedNg?: SortOrder
    requestedReplacement?: SortOrder
    operationCode?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    resolvedById?: SortOrder
    resolutionNote?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type OperationDefectEditRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    operationDefectId?: SortOrder
    operationId?: SortOrder
    productionOrderId?: SortOrder
    requestedById?: SortOrder
    defectId?: SortOrder
    currentQty?: SortOrder
    currentRw?: SortOrder
    currentNg?: SortOrder
    currentReplacement?: SortOrder
    requestedQty?: SortOrder
    requestedRw?: SortOrder
    requestedNg?: SortOrder
    requestedReplacement?: SortOrder
    resolvedById?: SortOrder
  }

  export type OperationDefectEditRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    operationDefectId?: SortOrder
    operationId?: SortOrder
    productionOrderId?: SortOrder
    requestedById?: SortOrder
    requestType?: SortOrder
    defectId?: SortOrder
    defectName?: SortOrder
    defectCategory?: SortOrder
    defectReworkable?: SortOrder
    defectMachine?: SortOrder
    currentQty?: SortOrder
    currentRw?: SortOrder
    currentNg?: SortOrder
    currentReplacement?: SortOrder
    requestedQty?: SortOrder
    requestedRw?: SortOrder
    requestedNg?: SortOrder
    requestedReplacement?: SortOrder
    operationCode?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    resolvedById?: SortOrder
    resolutionNote?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type OperationDefectEditRequestMinOrderByAggregateInput = {
    id?: SortOrder
    operationDefectId?: SortOrder
    operationId?: SortOrder
    productionOrderId?: SortOrder
    requestedById?: SortOrder
    requestType?: SortOrder
    defectId?: SortOrder
    defectName?: SortOrder
    defectCategory?: SortOrder
    defectReworkable?: SortOrder
    defectMachine?: SortOrder
    currentQty?: SortOrder
    currentRw?: SortOrder
    currentNg?: SortOrder
    currentReplacement?: SortOrder
    requestedQty?: SortOrder
    requestedRw?: SortOrder
    requestedNg?: SortOrder
    requestedReplacement?: SortOrder
    operationCode?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    resolvedById?: SortOrder
    resolutionNote?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type OperationDefectEditRequestSumOrderByAggregateInput = {
    id?: SortOrder
    operationDefectId?: SortOrder
    operationId?: SortOrder
    productionOrderId?: SortOrder
    requestedById?: SortOrder
    defectId?: SortOrder
    currentQty?: SortOrder
    currentRw?: SortOrder
    currentNg?: SortOrder
    currentReplacement?: SortOrder
    requestedQty?: SortOrder
    requestedRw?: SortOrder
    requestedNg?: SortOrder
    requestedReplacement?: SortOrder
    resolvedById?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type OperationStepCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    operationNumber?: SortOrder
    stepOrder?: SortOrder
  }

  export type OperationStepAvgOrderByAggregateInput = {
    id?: SortOrder
    stepOrder?: SortOrder
  }

  export type OperationStepMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    operationNumber?: SortOrder
    stepOrder?: SortOrder
  }

  export type OperationStepMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    operationNumber?: SortOrder
    stepOrder?: SortOrder
  }

  export type OperationStepSumOrderByAggregateInput = {
    id?: SortOrder
    stepOrder?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    linkUrl?: SortOrder
    userId?: SortOrder
    sourceId?: SortOrder
    sourceType?: SortOrder
    metadata?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    linkUrl?: SortOrder
    userId?: SortOrder
    sourceId?: SortOrder
    sourceType?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    linkUrl?: SortOrder
    userId?: SortOrder
    sourceId?: SortOrder
    sourceType?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    userId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type OperationLineOperationNumberLineNumberCompoundUniqueInput = {
    operationNumber: string
    lineNumber: string
  }

  export type OperationLineCountOrderByAggregateInput = {
    id?: SortOrder
    operationNumber?: SortOrder
    lineNumber?: SortOrder
  }

  export type OperationLineAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OperationLineMaxOrderByAggregateInput = {
    id?: SortOrder
    operationNumber?: SortOrder
    lineNumber?: SortOrder
  }

  export type OperationLineMinOrderByAggregateInput = {
    id?: SortOrder
    operationNumber?: SortOrder
    lineNumber?: SortOrder
  }

  export type OperationLineSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type MasterDefectCreateNestedManyWithoutDeactivatedByInput = {
    create?: XOR<MasterDefectCreateWithoutDeactivatedByInput, MasterDefectUncheckedCreateWithoutDeactivatedByInput> | MasterDefectCreateWithoutDeactivatedByInput[] | MasterDefectUncheckedCreateWithoutDeactivatedByInput[]
    connectOrCreate?: MasterDefectCreateOrConnectWithoutDeactivatedByInput | MasterDefectCreateOrConnectWithoutDeactivatedByInput[]
    createMany?: MasterDefectCreateManyDeactivatedByInputEnvelope
    connect?: MasterDefectWhereUniqueInput | MasterDefectWhereUniqueInput[]
  }

  export type OperationDefectEditRequestCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutRequestedByInput, OperationDefectEditRequestUncheckedCreateWithoutRequestedByInput> | OperationDefectEditRequestCreateWithoutRequestedByInput[] | OperationDefectEditRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutRequestedByInput | OperationDefectEditRequestCreateOrConnectWithoutRequestedByInput[]
    createMany?: OperationDefectEditRequestCreateManyRequestedByInputEnvelope
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
  }

  export type OperationDefectEditRequestCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutResolvedByInput, OperationDefectEditRequestUncheckedCreateWithoutResolvedByInput> | OperationDefectEditRequestCreateWithoutResolvedByInput[] | OperationDefectEditRequestUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutResolvedByInput | OperationDefectEditRequestCreateOrConnectWithoutResolvedByInput[]
    createMany?: OperationDefectEditRequestCreateManyResolvedByInputEnvelope
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
  }

  export type OperationDefectCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<OperationDefectCreateWithoutRecordedByInput, OperationDefectUncheckedCreateWithoutRecordedByInput> | OperationDefectCreateWithoutRecordedByInput[] | OperationDefectUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutRecordedByInput | OperationDefectCreateOrConnectWithoutRecordedByInput[]
    createMany?: OperationDefectCreateManyRecordedByInputEnvelope
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
  }

  export type OperationCreateNestedManyWithoutEncodedByInput = {
    create?: XOR<OperationCreateWithoutEncodedByInput, OperationUncheckedCreateWithoutEncodedByInput> | OperationCreateWithoutEncodedByInput[] | OperationUncheckedCreateWithoutEncodedByInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutEncodedByInput | OperationCreateOrConnectWithoutEncodedByInput[]
    createMany?: OperationCreateManyEncodedByInputEnvelope
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
  }

  export type OperationCreateNestedManyWithoutOperatorInput = {
    create?: XOR<OperationCreateWithoutOperatorInput, OperationUncheckedCreateWithoutOperatorInput> | OperationCreateWithoutOperatorInput[] | OperationUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutOperatorInput | OperationCreateOrConnectWithoutOperatorInput[]
    createMany?: OperationCreateManyOperatorInputEnvelope
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type MasterDefectUncheckedCreateNestedManyWithoutDeactivatedByInput = {
    create?: XOR<MasterDefectCreateWithoutDeactivatedByInput, MasterDefectUncheckedCreateWithoutDeactivatedByInput> | MasterDefectCreateWithoutDeactivatedByInput[] | MasterDefectUncheckedCreateWithoutDeactivatedByInput[]
    connectOrCreate?: MasterDefectCreateOrConnectWithoutDeactivatedByInput | MasterDefectCreateOrConnectWithoutDeactivatedByInput[]
    createMany?: MasterDefectCreateManyDeactivatedByInputEnvelope
    connect?: MasterDefectWhereUniqueInput | MasterDefectWhereUniqueInput[]
  }

  export type OperationDefectEditRequestUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutRequestedByInput, OperationDefectEditRequestUncheckedCreateWithoutRequestedByInput> | OperationDefectEditRequestCreateWithoutRequestedByInput[] | OperationDefectEditRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutRequestedByInput | OperationDefectEditRequestCreateOrConnectWithoutRequestedByInput[]
    createMany?: OperationDefectEditRequestCreateManyRequestedByInputEnvelope
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
  }

  export type OperationDefectEditRequestUncheckedCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutResolvedByInput, OperationDefectEditRequestUncheckedCreateWithoutResolvedByInput> | OperationDefectEditRequestCreateWithoutResolvedByInput[] | OperationDefectEditRequestUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutResolvedByInput | OperationDefectEditRequestCreateOrConnectWithoutResolvedByInput[]
    createMany?: OperationDefectEditRequestCreateManyResolvedByInputEnvelope
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
  }

  export type OperationDefectUncheckedCreateNestedManyWithoutRecordedByInput = {
    create?: XOR<OperationDefectCreateWithoutRecordedByInput, OperationDefectUncheckedCreateWithoutRecordedByInput> | OperationDefectCreateWithoutRecordedByInput[] | OperationDefectUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutRecordedByInput | OperationDefectCreateOrConnectWithoutRecordedByInput[]
    createMany?: OperationDefectCreateManyRecordedByInputEnvelope
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
  }

  export type OperationUncheckedCreateNestedManyWithoutEncodedByInput = {
    create?: XOR<OperationCreateWithoutEncodedByInput, OperationUncheckedCreateWithoutEncodedByInput> | OperationCreateWithoutEncodedByInput[] | OperationUncheckedCreateWithoutEncodedByInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutEncodedByInput | OperationCreateOrConnectWithoutEncodedByInput[]
    createMany?: OperationCreateManyEncodedByInputEnvelope
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
  }

  export type OperationUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<OperationCreateWithoutOperatorInput, OperationUncheckedCreateWithoutOperatorInput> | OperationCreateWithoutOperatorInput[] | OperationUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutOperatorInput | OperationCreateOrConnectWithoutOperatorInput[]
    createMany?: OperationCreateManyOperatorInputEnvelope
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type MasterDefectUpdateManyWithoutDeactivatedByNestedInput = {
    create?: XOR<MasterDefectCreateWithoutDeactivatedByInput, MasterDefectUncheckedCreateWithoutDeactivatedByInput> | MasterDefectCreateWithoutDeactivatedByInput[] | MasterDefectUncheckedCreateWithoutDeactivatedByInput[]
    connectOrCreate?: MasterDefectCreateOrConnectWithoutDeactivatedByInput | MasterDefectCreateOrConnectWithoutDeactivatedByInput[]
    upsert?: MasterDefectUpsertWithWhereUniqueWithoutDeactivatedByInput | MasterDefectUpsertWithWhereUniqueWithoutDeactivatedByInput[]
    createMany?: MasterDefectCreateManyDeactivatedByInputEnvelope
    set?: MasterDefectWhereUniqueInput | MasterDefectWhereUniqueInput[]
    disconnect?: MasterDefectWhereUniqueInput | MasterDefectWhereUniqueInput[]
    delete?: MasterDefectWhereUniqueInput | MasterDefectWhereUniqueInput[]
    connect?: MasterDefectWhereUniqueInput | MasterDefectWhereUniqueInput[]
    update?: MasterDefectUpdateWithWhereUniqueWithoutDeactivatedByInput | MasterDefectUpdateWithWhereUniqueWithoutDeactivatedByInput[]
    updateMany?: MasterDefectUpdateManyWithWhereWithoutDeactivatedByInput | MasterDefectUpdateManyWithWhereWithoutDeactivatedByInput[]
    deleteMany?: MasterDefectScalarWhereInput | MasterDefectScalarWhereInput[]
  }

  export type OperationDefectEditRequestUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutRequestedByInput, OperationDefectEditRequestUncheckedCreateWithoutRequestedByInput> | OperationDefectEditRequestCreateWithoutRequestedByInput[] | OperationDefectEditRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutRequestedByInput | OperationDefectEditRequestCreateOrConnectWithoutRequestedByInput[]
    upsert?: OperationDefectEditRequestUpsertWithWhereUniqueWithoutRequestedByInput | OperationDefectEditRequestUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: OperationDefectEditRequestCreateManyRequestedByInputEnvelope
    set?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    disconnect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    delete?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    update?: OperationDefectEditRequestUpdateWithWhereUniqueWithoutRequestedByInput | OperationDefectEditRequestUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: OperationDefectEditRequestUpdateManyWithWhereWithoutRequestedByInput | OperationDefectEditRequestUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
  }

  export type OperationDefectEditRequestUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutResolvedByInput, OperationDefectEditRequestUncheckedCreateWithoutResolvedByInput> | OperationDefectEditRequestCreateWithoutResolvedByInput[] | OperationDefectEditRequestUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutResolvedByInput | OperationDefectEditRequestCreateOrConnectWithoutResolvedByInput[]
    upsert?: OperationDefectEditRequestUpsertWithWhereUniqueWithoutResolvedByInput | OperationDefectEditRequestUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: OperationDefectEditRequestCreateManyResolvedByInputEnvelope
    set?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    disconnect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    delete?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    update?: OperationDefectEditRequestUpdateWithWhereUniqueWithoutResolvedByInput | OperationDefectEditRequestUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: OperationDefectEditRequestUpdateManyWithWhereWithoutResolvedByInput | OperationDefectEditRequestUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
  }

  export type OperationDefectUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<OperationDefectCreateWithoutRecordedByInput, OperationDefectUncheckedCreateWithoutRecordedByInput> | OperationDefectCreateWithoutRecordedByInput[] | OperationDefectUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutRecordedByInput | OperationDefectCreateOrConnectWithoutRecordedByInput[]
    upsert?: OperationDefectUpsertWithWhereUniqueWithoutRecordedByInput | OperationDefectUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: OperationDefectCreateManyRecordedByInputEnvelope
    set?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    disconnect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    delete?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    update?: OperationDefectUpdateWithWhereUniqueWithoutRecordedByInput | OperationDefectUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: OperationDefectUpdateManyWithWhereWithoutRecordedByInput | OperationDefectUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: OperationDefectScalarWhereInput | OperationDefectScalarWhereInput[]
  }

  export type OperationUpdateManyWithoutEncodedByNestedInput = {
    create?: XOR<OperationCreateWithoutEncodedByInput, OperationUncheckedCreateWithoutEncodedByInput> | OperationCreateWithoutEncodedByInput[] | OperationUncheckedCreateWithoutEncodedByInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutEncodedByInput | OperationCreateOrConnectWithoutEncodedByInput[]
    upsert?: OperationUpsertWithWhereUniqueWithoutEncodedByInput | OperationUpsertWithWhereUniqueWithoutEncodedByInput[]
    createMany?: OperationCreateManyEncodedByInputEnvelope
    set?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    disconnect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    delete?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    update?: OperationUpdateWithWhereUniqueWithoutEncodedByInput | OperationUpdateWithWhereUniqueWithoutEncodedByInput[]
    updateMany?: OperationUpdateManyWithWhereWithoutEncodedByInput | OperationUpdateManyWithWhereWithoutEncodedByInput[]
    deleteMany?: OperationScalarWhereInput | OperationScalarWhereInput[]
  }

  export type OperationUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<OperationCreateWithoutOperatorInput, OperationUncheckedCreateWithoutOperatorInput> | OperationCreateWithoutOperatorInput[] | OperationUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutOperatorInput | OperationCreateOrConnectWithoutOperatorInput[]
    upsert?: OperationUpsertWithWhereUniqueWithoutOperatorInput | OperationUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: OperationCreateManyOperatorInputEnvelope
    set?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    disconnect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    delete?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    update?: OperationUpdateWithWhereUniqueWithoutOperatorInput | OperationUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: OperationUpdateManyWithWhereWithoutOperatorInput | OperationUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: OperationScalarWhereInput | OperationScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type MasterDefectUncheckedUpdateManyWithoutDeactivatedByNestedInput = {
    create?: XOR<MasterDefectCreateWithoutDeactivatedByInput, MasterDefectUncheckedCreateWithoutDeactivatedByInput> | MasterDefectCreateWithoutDeactivatedByInput[] | MasterDefectUncheckedCreateWithoutDeactivatedByInput[]
    connectOrCreate?: MasterDefectCreateOrConnectWithoutDeactivatedByInput | MasterDefectCreateOrConnectWithoutDeactivatedByInput[]
    upsert?: MasterDefectUpsertWithWhereUniqueWithoutDeactivatedByInput | MasterDefectUpsertWithWhereUniqueWithoutDeactivatedByInput[]
    createMany?: MasterDefectCreateManyDeactivatedByInputEnvelope
    set?: MasterDefectWhereUniqueInput | MasterDefectWhereUniqueInput[]
    disconnect?: MasterDefectWhereUniqueInput | MasterDefectWhereUniqueInput[]
    delete?: MasterDefectWhereUniqueInput | MasterDefectWhereUniqueInput[]
    connect?: MasterDefectWhereUniqueInput | MasterDefectWhereUniqueInput[]
    update?: MasterDefectUpdateWithWhereUniqueWithoutDeactivatedByInput | MasterDefectUpdateWithWhereUniqueWithoutDeactivatedByInput[]
    updateMany?: MasterDefectUpdateManyWithWhereWithoutDeactivatedByInput | MasterDefectUpdateManyWithWhereWithoutDeactivatedByInput[]
    deleteMany?: MasterDefectScalarWhereInput | MasterDefectScalarWhereInput[]
  }

  export type OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutRequestedByInput, OperationDefectEditRequestUncheckedCreateWithoutRequestedByInput> | OperationDefectEditRequestCreateWithoutRequestedByInput[] | OperationDefectEditRequestUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutRequestedByInput | OperationDefectEditRequestCreateOrConnectWithoutRequestedByInput[]
    upsert?: OperationDefectEditRequestUpsertWithWhereUniqueWithoutRequestedByInput | OperationDefectEditRequestUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: OperationDefectEditRequestCreateManyRequestedByInputEnvelope
    set?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    disconnect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    delete?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    update?: OperationDefectEditRequestUpdateWithWhereUniqueWithoutRequestedByInput | OperationDefectEditRequestUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: OperationDefectEditRequestUpdateManyWithWhereWithoutRequestedByInput | OperationDefectEditRequestUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
  }

  export type OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutResolvedByInput, OperationDefectEditRequestUncheckedCreateWithoutResolvedByInput> | OperationDefectEditRequestCreateWithoutResolvedByInput[] | OperationDefectEditRequestUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutResolvedByInput | OperationDefectEditRequestCreateOrConnectWithoutResolvedByInput[]
    upsert?: OperationDefectEditRequestUpsertWithWhereUniqueWithoutResolvedByInput | OperationDefectEditRequestUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: OperationDefectEditRequestCreateManyResolvedByInputEnvelope
    set?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    disconnect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    delete?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    update?: OperationDefectEditRequestUpdateWithWhereUniqueWithoutResolvedByInput | OperationDefectEditRequestUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: OperationDefectEditRequestUpdateManyWithWhereWithoutResolvedByInput | OperationDefectEditRequestUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
  }

  export type OperationDefectUncheckedUpdateManyWithoutRecordedByNestedInput = {
    create?: XOR<OperationDefectCreateWithoutRecordedByInput, OperationDefectUncheckedCreateWithoutRecordedByInput> | OperationDefectCreateWithoutRecordedByInput[] | OperationDefectUncheckedCreateWithoutRecordedByInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutRecordedByInput | OperationDefectCreateOrConnectWithoutRecordedByInput[]
    upsert?: OperationDefectUpsertWithWhereUniqueWithoutRecordedByInput | OperationDefectUpsertWithWhereUniqueWithoutRecordedByInput[]
    createMany?: OperationDefectCreateManyRecordedByInputEnvelope
    set?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    disconnect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    delete?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    update?: OperationDefectUpdateWithWhereUniqueWithoutRecordedByInput | OperationDefectUpdateWithWhereUniqueWithoutRecordedByInput[]
    updateMany?: OperationDefectUpdateManyWithWhereWithoutRecordedByInput | OperationDefectUpdateManyWithWhereWithoutRecordedByInput[]
    deleteMany?: OperationDefectScalarWhereInput | OperationDefectScalarWhereInput[]
  }

  export type OperationUncheckedUpdateManyWithoutEncodedByNestedInput = {
    create?: XOR<OperationCreateWithoutEncodedByInput, OperationUncheckedCreateWithoutEncodedByInput> | OperationCreateWithoutEncodedByInput[] | OperationUncheckedCreateWithoutEncodedByInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutEncodedByInput | OperationCreateOrConnectWithoutEncodedByInput[]
    upsert?: OperationUpsertWithWhereUniqueWithoutEncodedByInput | OperationUpsertWithWhereUniqueWithoutEncodedByInput[]
    createMany?: OperationCreateManyEncodedByInputEnvelope
    set?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    disconnect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    delete?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    update?: OperationUpdateWithWhereUniqueWithoutEncodedByInput | OperationUpdateWithWhereUniqueWithoutEncodedByInput[]
    updateMany?: OperationUpdateManyWithWhereWithoutEncodedByInput | OperationUpdateManyWithWhereWithoutEncodedByInput[]
    deleteMany?: OperationScalarWhereInput | OperationScalarWhereInput[]
  }

  export type OperationUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<OperationCreateWithoutOperatorInput, OperationUncheckedCreateWithoutOperatorInput> | OperationCreateWithoutOperatorInput[] | OperationUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutOperatorInput | OperationCreateOrConnectWithoutOperatorInput[]
    upsert?: OperationUpsertWithWhereUniqueWithoutOperatorInput | OperationUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: OperationCreateManyOperatorInputEnvelope
    set?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    disconnect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    delete?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    update?: OperationUpdateWithWhereUniqueWithoutOperatorInput | OperationUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: OperationUpdateManyWithWhereWithoutOperatorInput | OperationUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: OperationScalarWhereInput | OperationScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OperationDefectEditRequestCreateNestedManyWithoutProductionOrderInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutProductionOrderInput, OperationDefectEditRequestUncheckedCreateWithoutProductionOrderInput> | OperationDefectEditRequestCreateWithoutProductionOrderInput[] | OperationDefectEditRequestUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutProductionOrderInput | OperationDefectEditRequestCreateOrConnectWithoutProductionOrderInput[]
    createMany?: OperationDefectEditRequestCreateManyProductionOrderInputEnvelope
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
  }

  export type OperationCreateNestedManyWithoutProductionOrderInput = {
    create?: XOR<OperationCreateWithoutProductionOrderInput, OperationUncheckedCreateWithoutProductionOrderInput> | OperationCreateWithoutProductionOrderInput[] | OperationUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutProductionOrderInput | OperationCreateOrConnectWithoutProductionOrderInput[]
    createMany?: OperationCreateManyProductionOrderInputEnvelope
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
  }

  export type OperationDefectEditRequestUncheckedCreateNestedManyWithoutProductionOrderInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutProductionOrderInput, OperationDefectEditRequestUncheckedCreateWithoutProductionOrderInput> | OperationDefectEditRequestCreateWithoutProductionOrderInput[] | OperationDefectEditRequestUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutProductionOrderInput | OperationDefectEditRequestCreateOrConnectWithoutProductionOrderInput[]
    createMany?: OperationDefectEditRequestCreateManyProductionOrderInputEnvelope
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
  }

  export type OperationUncheckedCreateNestedManyWithoutProductionOrderInput = {
    create?: XOR<OperationCreateWithoutProductionOrderInput, OperationUncheckedCreateWithoutProductionOrderInput> | OperationCreateWithoutProductionOrderInput[] | OperationUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutProductionOrderInput | OperationCreateOrConnectWithoutProductionOrderInput[]
    createMany?: OperationCreateManyProductionOrderInputEnvelope
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type OperationDefectEditRequestUpdateManyWithoutProductionOrderNestedInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutProductionOrderInput, OperationDefectEditRequestUncheckedCreateWithoutProductionOrderInput> | OperationDefectEditRequestCreateWithoutProductionOrderInput[] | OperationDefectEditRequestUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutProductionOrderInput | OperationDefectEditRequestCreateOrConnectWithoutProductionOrderInput[]
    upsert?: OperationDefectEditRequestUpsertWithWhereUniqueWithoutProductionOrderInput | OperationDefectEditRequestUpsertWithWhereUniqueWithoutProductionOrderInput[]
    createMany?: OperationDefectEditRequestCreateManyProductionOrderInputEnvelope
    set?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    disconnect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    delete?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    update?: OperationDefectEditRequestUpdateWithWhereUniqueWithoutProductionOrderInput | OperationDefectEditRequestUpdateWithWhereUniqueWithoutProductionOrderInput[]
    updateMany?: OperationDefectEditRequestUpdateManyWithWhereWithoutProductionOrderInput | OperationDefectEditRequestUpdateManyWithWhereWithoutProductionOrderInput[]
    deleteMany?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
  }

  export type OperationUpdateManyWithoutProductionOrderNestedInput = {
    create?: XOR<OperationCreateWithoutProductionOrderInput, OperationUncheckedCreateWithoutProductionOrderInput> | OperationCreateWithoutProductionOrderInput[] | OperationUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutProductionOrderInput | OperationCreateOrConnectWithoutProductionOrderInput[]
    upsert?: OperationUpsertWithWhereUniqueWithoutProductionOrderInput | OperationUpsertWithWhereUniqueWithoutProductionOrderInput[]
    createMany?: OperationCreateManyProductionOrderInputEnvelope
    set?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    disconnect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    delete?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    update?: OperationUpdateWithWhereUniqueWithoutProductionOrderInput | OperationUpdateWithWhereUniqueWithoutProductionOrderInput[]
    updateMany?: OperationUpdateManyWithWhereWithoutProductionOrderInput | OperationUpdateManyWithWhereWithoutProductionOrderInput[]
    deleteMany?: OperationScalarWhereInput | OperationScalarWhereInput[]
  }

  export type OperationDefectEditRequestUncheckedUpdateManyWithoutProductionOrderNestedInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutProductionOrderInput, OperationDefectEditRequestUncheckedCreateWithoutProductionOrderInput> | OperationDefectEditRequestCreateWithoutProductionOrderInput[] | OperationDefectEditRequestUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutProductionOrderInput | OperationDefectEditRequestCreateOrConnectWithoutProductionOrderInput[]
    upsert?: OperationDefectEditRequestUpsertWithWhereUniqueWithoutProductionOrderInput | OperationDefectEditRequestUpsertWithWhereUniqueWithoutProductionOrderInput[]
    createMany?: OperationDefectEditRequestCreateManyProductionOrderInputEnvelope
    set?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    disconnect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    delete?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    update?: OperationDefectEditRequestUpdateWithWhereUniqueWithoutProductionOrderInput | OperationDefectEditRequestUpdateWithWhereUniqueWithoutProductionOrderInput[]
    updateMany?: OperationDefectEditRequestUpdateManyWithWhereWithoutProductionOrderInput | OperationDefectEditRequestUpdateManyWithWhereWithoutProductionOrderInput[]
    deleteMany?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
  }

  export type OperationUncheckedUpdateManyWithoutProductionOrderNestedInput = {
    create?: XOR<OperationCreateWithoutProductionOrderInput, OperationUncheckedCreateWithoutProductionOrderInput> | OperationCreateWithoutProductionOrderInput[] | OperationUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: OperationCreateOrConnectWithoutProductionOrderInput | OperationCreateOrConnectWithoutProductionOrderInput[]
    upsert?: OperationUpsertWithWhereUniqueWithoutProductionOrderInput | OperationUpsertWithWhereUniqueWithoutProductionOrderInput[]
    createMany?: OperationCreateManyProductionOrderInputEnvelope
    set?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    disconnect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    delete?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    connect?: OperationWhereUniqueInput | OperationWhereUniqueInput[]
    update?: OperationUpdateWithWhereUniqueWithoutProductionOrderInput | OperationUpdateWithWhereUniqueWithoutProductionOrderInput[]
    updateMany?: OperationUpdateManyWithWhereWithoutProductionOrderInput | OperationUpdateManyWithWhereWithoutProductionOrderInput[]
    deleteMany?: OperationScalarWhereInput | OperationScalarWhereInput[]
  }

  export type OperationDefectEditRequestCreateNestedManyWithoutOperationInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutOperationInput, OperationDefectEditRequestUncheckedCreateWithoutOperationInput> | OperationDefectEditRequestCreateWithoutOperationInput[] | OperationDefectEditRequestUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutOperationInput | OperationDefectEditRequestCreateOrConnectWithoutOperationInput[]
    createMany?: OperationDefectEditRequestCreateManyOperationInputEnvelope
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
  }

  export type OperationDefectCreateNestedManyWithoutOperationInput = {
    create?: XOR<OperationDefectCreateWithoutOperationInput, OperationDefectUncheckedCreateWithoutOperationInput> | OperationDefectCreateWithoutOperationInput[] | OperationDefectUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutOperationInput | OperationDefectCreateOrConnectWithoutOperationInput[]
    createMany?: OperationDefectCreateManyOperationInputEnvelope
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutEncodedOperationsInput = {
    create?: XOR<UserCreateWithoutEncodedOperationsInput, UserUncheckedCreateWithoutEncodedOperationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEncodedOperationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOperationsInput = {
    create?: XOR<UserCreateWithoutOperationsInput, UserUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOperationsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductionOrderCreateNestedOneWithoutOperationsInput = {
    create?: XOR<ProductionOrderCreateWithoutOperationsInput, ProductionOrderUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutOperationsInput
    connect?: ProductionOrderWhereUniqueInput
  }

  export type OperationDefectEditRequestUncheckedCreateNestedManyWithoutOperationInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutOperationInput, OperationDefectEditRequestUncheckedCreateWithoutOperationInput> | OperationDefectEditRequestCreateWithoutOperationInput[] | OperationDefectEditRequestUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutOperationInput | OperationDefectEditRequestCreateOrConnectWithoutOperationInput[]
    createMany?: OperationDefectEditRequestCreateManyOperationInputEnvelope
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
  }

  export type OperationDefectUncheckedCreateNestedManyWithoutOperationInput = {
    create?: XOR<OperationDefectCreateWithoutOperationInput, OperationDefectUncheckedCreateWithoutOperationInput> | OperationDefectCreateWithoutOperationInput[] | OperationDefectUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutOperationInput | OperationDefectCreateOrConnectWithoutOperationInput[]
    createMany?: OperationDefectCreateManyOperationInputEnvelope
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OperationDefectEditRequestUpdateManyWithoutOperationNestedInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutOperationInput, OperationDefectEditRequestUncheckedCreateWithoutOperationInput> | OperationDefectEditRequestCreateWithoutOperationInput[] | OperationDefectEditRequestUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutOperationInput | OperationDefectEditRequestCreateOrConnectWithoutOperationInput[]
    upsert?: OperationDefectEditRequestUpsertWithWhereUniqueWithoutOperationInput | OperationDefectEditRequestUpsertWithWhereUniqueWithoutOperationInput[]
    createMany?: OperationDefectEditRequestCreateManyOperationInputEnvelope
    set?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    disconnect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    delete?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    update?: OperationDefectEditRequestUpdateWithWhereUniqueWithoutOperationInput | OperationDefectEditRequestUpdateWithWhereUniqueWithoutOperationInput[]
    updateMany?: OperationDefectEditRequestUpdateManyWithWhereWithoutOperationInput | OperationDefectEditRequestUpdateManyWithWhereWithoutOperationInput[]
    deleteMany?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
  }

  export type OperationDefectUpdateManyWithoutOperationNestedInput = {
    create?: XOR<OperationDefectCreateWithoutOperationInput, OperationDefectUncheckedCreateWithoutOperationInput> | OperationDefectCreateWithoutOperationInput[] | OperationDefectUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutOperationInput | OperationDefectCreateOrConnectWithoutOperationInput[]
    upsert?: OperationDefectUpsertWithWhereUniqueWithoutOperationInput | OperationDefectUpsertWithWhereUniqueWithoutOperationInput[]
    createMany?: OperationDefectCreateManyOperationInputEnvelope
    set?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    disconnect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    delete?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    update?: OperationDefectUpdateWithWhereUniqueWithoutOperationInput | OperationDefectUpdateWithWhereUniqueWithoutOperationInput[]
    updateMany?: OperationDefectUpdateManyWithWhereWithoutOperationInput | OperationDefectUpdateManyWithWhereWithoutOperationInput[]
    deleteMany?: OperationDefectScalarWhereInput | OperationDefectScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutEncodedOperationsNestedInput = {
    create?: XOR<UserCreateWithoutEncodedOperationsInput, UserUncheckedCreateWithoutEncodedOperationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEncodedOperationsInput
    upsert?: UserUpsertWithoutEncodedOperationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEncodedOperationsInput, UserUpdateWithoutEncodedOperationsInput>, UserUncheckedUpdateWithoutEncodedOperationsInput>
  }

  export type UserUpdateOneRequiredWithoutOperationsNestedInput = {
    create?: XOR<UserCreateWithoutOperationsInput, UserUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOperationsInput
    upsert?: UserUpsertWithoutOperationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOperationsInput, UserUpdateWithoutOperationsInput>, UserUncheckedUpdateWithoutOperationsInput>
  }

  export type ProductionOrderUpdateOneRequiredWithoutOperationsNestedInput = {
    create?: XOR<ProductionOrderCreateWithoutOperationsInput, ProductionOrderUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutOperationsInput
    upsert?: ProductionOrderUpsertWithoutOperationsInput
    connect?: ProductionOrderWhereUniqueInput
    update?: XOR<XOR<ProductionOrderUpdateToOneWithWhereWithoutOperationsInput, ProductionOrderUpdateWithoutOperationsInput>, ProductionOrderUncheckedUpdateWithoutOperationsInput>
  }

  export type OperationDefectEditRequestUncheckedUpdateManyWithoutOperationNestedInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutOperationInput, OperationDefectEditRequestUncheckedCreateWithoutOperationInput> | OperationDefectEditRequestCreateWithoutOperationInput[] | OperationDefectEditRequestUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutOperationInput | OperationDefectEditRequestCreateOrConnectWithoutOperationInput[]
    upsert?: OperationDefectEditRequestUpsertWithWhereUniqueWithoutOperationInput | OperationDefectEditRequestUpsertWithWhereUniqueWithoutOperationInput[]
    createMany?: OperationDefectEditRequestCreateManyOperationInputEnvelope
    set?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    disconnect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    delete?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    update?: OperationDefectEditRequestUpdateWithWhereUniqueWithoutOperationInput | OperationDefectEditRequestUpdateWithWhereUniqueWithoutOperationInput[]
    updateMany?: OperationDefectEditRequestUpdateManyWithWhereWithoutOperationInput | OperationDefectEditRequestUpdateManyWithWhereWithoutOperationInput[]
    deleteMany?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
  }

  export type OperationDefectUncheckedUpdateManyWithoutOperationNestedInput = {
    create?: XOR<OperationDefectCreateWithoutOperationInput, OperationDefectUncheckedCreateWithoutOperationInput> | OperationDefectCreateWithoutOperationInput[] | OperationDefectUncheckedCreateWithoutOperationInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutOperationInput | OperationDefectCreateOrConnectWithoutOperationInput[]
    upsert?: OperationDefectUpsertWithWhereUniqueWithoutOperationInput | OperationDefectUpsertWithWhereUniqueWithoutOperationInput[]
    createMany?: OperationDefectCreateManyOperationInputEnvelope
    set?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    disconnect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    delete?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    update?: OperationDefectUpdateWithWhereUniqueWithoutOperationInput | OperationDefectUpdateWithWhereUniqueWithoutOperationInput[]
    updateMany?: OperationDefectUpdateManyWithWhereWithoutOperationInput | OperationDefectUpdateManyWithWhereWithoutOperationInput[]
    deleteMany?: OperationDefectScalarWhereInput | OperationDefectScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDeactivatedDefectsInput = {
    create?: XOR<UserCreateWithoutDeactivatedDefectsInput, UserUncheckedCreateWithoutDeactivatedDefectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeactivatedDefectsInput
    connect?: UserWhereUniqueInput
  }

  export type OperationDefectCreateNestedManyWithoutDefectInput = {
    create?: XOR<OperationDefectCreateWithoutDefectInput, OperationDefectUncheckedCreateWithoutDefectInput> | OperationDefectCreateWithoutDefectInput[] | OperationDefectUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutDefectInput | OperationDefectCreateOrConnectWithoutDefectInput[]
    createMany?: OperationDefectCreateManyDefectInputEnvelope
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
  }

  export type OperationDefectUncheckedCreateNestedManyWithoutDefectInput = {
    create?: XOR<OperationDefectCreateWithoutDefectInput, OperationDefectUncheckedCreateWithoutDefectInput> | OperationDefectCreateWithoutDefectInput[] | OperationDefectUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutDefectInput | OperationDefectCreateOrConnectWithoutDefectInput[]
    createMany?: OperationDefectCreateManyDefectInputEnvelope
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutDeactivatedDefectsNestedInput = {
    create?: XOR<UserCreateWithoutDeactivatedDefectsInput, UserUncheckedCreateWithoutDeactivatedDefectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeactivatedDefectsInput
    upsert?: UserUpsertWithoutDeactivatedDefectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeactivatedDefectsInput, UserUpdateWithoutDeactivatedDefectsInput>, UserUncheckedUpdateWithoutDeactivatedDefectsInput>
  }

  export type OperationDefectUpdateManyWithoutDefectNestedInput = {
    create?: XOR<OperationDefectCreateWithoutDefectInput, OperationDefectUncheckedCreateWithoutDefectInput> | OperationDefectCreateWithoutDefectInput[] | OperationDefectUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutDefectInput | OperationDefectCreateOrConnectWithoutDefectInput[]
    upsert?: OperationDefectUpsertWithWhereUniqueWithoutDefectInput | OperationDefectUpsertWithWhereUniqueWithoutDefectInput[]
    createMany?: OperationDefectCreateManyDefectInputEnvelope
    set?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    disconnect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    delete?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    update?: OperationDefectUpdateWithWhereUniqueWithoutDefectInput | OperationDefectUpdateWithWhereUniqueWithoutDefectInput[]
    updateMany?: OperationDefectUpdateManyWithWhereWithoutDefectInput | OperationDefectUpdateManyWithWhereWithoutDefectInput[]
    deleteMany?: OperationDefectScalarWhereInput | OperationDefectScalarWhereInput[]
  }

  export type OperationDefectUncheckedUpdateManyWithoutDefectNestedInput = {
    create?: XOR<OperationDefectCreateWithoutDefectInput, OperationDefectUncheckedCreateWithoutDefectInput> | OperationDefectCreateWithoutDefectInput[] | OperationDefectUncheckedCreateWithoutDefectInput[]
    connectOrCreate?: OperationDefectCreateOrConnectWithoutDefectInput | OperationDefectCreateOrConnectWithoutDefectInput[]
    upsert?: OperationDefectUpsertWithWhereUniqueWithoutDefectInput | OperationDefectUpsertWithWhereUniqueWithoutDefectInput[]
    createMany?: OperationDefectCreateManyDefectInputEnvelope
    set?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    disconnect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    delete?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    connect?: OperationDefectWhereUniqueInput | OperationDefectWhereUniqueInput[]
    update?: OperationDefectUpdateWithWhereUniqueWithoutDefectInput | OperationDefectUpdateWithWhereUniqueWithoutDefectInput[]
    updateMany?: OperationDefectUpdateManyWithWhereWithoutDefectInput | OperationDefectUpdateManyWithWhereWithoutDefectInput[]
    deleteMany?: OperationDefectScalarWhereInput | OperationDefectScalarWhereInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type OperationDefectEditRequestCreateNestedManyWithoutOperationDefectInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutOperationDefectInput, OperationDefectEditRequestUncheckedCreateWithoutOperationDefectInput> | OperationDefectEditRequestCreateWithoutOperationDefectInput[] | OperationDefectEditRequestUncheckedCreateWithoutOperationDefectInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutOperationDefectInput | OperationDefectEditRequestCreateOrConnectWithoutOperationDefectInput[]
    createMany?: OperationDefectEditRequestCreateManyOperationDefectInputEnvelope
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
  }

  export type MasterDefectCreateNestedOneWithoutOperationDefectsInput = {
    create?: XOR<MasterDefectCreateWithoutOperationDefectsInput, MasterDefectUncheckedCreateWithoutOperationDefectsInput>
    connectOrCreate?: MasterDefectCreateOrConnectWithoutOperationDefectsInput
    connect?: MasterDefectWhereUniqueInput
  }

  export type OperationCreateNestedOneWithoutOperationDefectsInput = {
    create?: XOR<OperationCreateWithoutOperationDefectsInput, OperationUncheckedCreateWithoutOperationDefectsInput>
    connectOrCreate?: OperationCreateOrConnectWithoutOperationDefectsInput
    connect?: OperationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecordedDefectsInput = {
    create?: XOR<UserCreateWithoutRecordedDefectsInput, UserUncheckedCreateWithoutRecordedDefectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecordedDefectsInput
    connect?: UserWhereUniqueInput
  }

  export type OperationDefectEditRequestUncheckedCreateNestedManyWithoutOperationDefectInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutOperationDefectInput, OperationDefectEditRequestUncheckedCreateWithoutOperationDefectInput> | OperationDefectEditRequestCreateWithoutOperationDefectInput[] | OperationDefectEditRequestUncheckedCreateWithoutOperationDefectInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutOperationDefectInput | OperationDefectEditRequestCreateOrConnectWithoutOperationDefectInput[]
    createMany?: OperationDefectEditRequestCreateManyOperationDefectInputEnvelope
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
  }

  export type OperationDefectEditRequestUpdateManyWithoutOperationDefectNestedInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutOperationDefectInput, OperationDefectEditRequestUncheckedCreateWithoutOperationDefectInput> | OperationDefectEditRequestCreateWithoutOperationDefectInput[] | OperationDefectEditRequestUncheckedCreateWithoutOperationDefectInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutOperationDefectInput | OperationDefectEditRequestCreateOrConnectWithoutOperationDefectInput[]
    upsert?: OperationDefectEditRequestUpsertWithWhereUniqueWithoutOperationDefectInput | OperationDefectEditRequestUpsertWithWhereUniqueWithoutOperationDefectInput[]
    createMany?: OperationDefectEditRequestCreateManyOperationDefectInputEnvelope
    set?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    disconnect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    delete?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    update?: OperationDefectEditRequestUpdateWithWhereUniqueWithoutOperationDefectInput | OperationDefectEditRequestUpdateWithWhereUniqueWithoutOperationDefectInput[]
    updateMany?: OperationDefectEditRequestUpdateManyWithWhereWithoutOperationDefectInput | OperationDefectEditRequestUpdateManyWithWhereWithoutOperationDefectInput[]
    deleteMany?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
  }

  export type MasterDefectUpdateOneWithoutOperationDefectsNestedInput = {
    create?: XOR<MasterDefectCreateWithoutOperationDefectsInput, MasterDefectUncheckedCreateWithoutOperationDefectsInput>
    connectOrCreate?: MasterDefectCreateOrConnectWithoutOperationDefectsInput
    upsert?: MasterDefectUpsertWithoutOperationDefectsInput
    disconnect?: MasterDefectWhereInput | boolean
    delete?: MasterDefectWhereInput | boolean
    connect?: MasterDefectWhereUniqueInput
    update?: XOR<XOR<MasterDefectUpdateToOneWithWhereWithoutOperationDefectsInput, MasterDefectUpdateWithoutOperationDefectsInput>, MasterDefectUncheckedUpdateWithoutOperationDefectsInput>
  }

  export type OperationUpdateOneRequiredWithoutOperationDefectsNestedInput = {
    create?: XOR<OperationCreateWithoutOperationDefectsInput, OperationUncheckedCreateWithoutOperationDefectsInput>
    connectOrCreate?: OperationCreateOrConnectWithoutOperationDefectsInput
    upsert?: OperationUpsertWithoutOperationDefectsInput
    connect?: OperationWhereUniqueInput
    update?: XOR<XOR<OperationUpdateToOneWithWhereWithoutOperationDefectsInput, OperationUpdateWithoutOperationDefectsInput>, OperationUncheckedUpdateWithoutOperationDefectsInput>
  }

  export type UserUpdateOneRequiredWithoutRecordedDefectsNestedInput = {
    create?: XOR<UserCreateWithoutRecordedDefectsInput, UserUncheckedCreateWithoutRecordedDefectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecordedDefectsInput
    upsert?: UserUpsertWithoutRecordedDefectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecordedDefectsInput, UserUpdateWithoutRecordedDefectsInput>, UserUncheckedUpdateWithoutRecordedDefectsInput>
  }

  export type OperationDefectEditRequestUncheckedUpdateManyWithoutOperationDefectNestedInput = {
    create?: XOR<OperationDefectEditRequestCreateWithoutOperationDefectInput, OperationDefectEditRequestUncheckedCreateWithoutOperationDefectInput> | OperationDefectEditRequestCreateWithoutOperationDefectInput[] | OperationDefectEditRequestUncheckedCreateWithoutOperationDefectInput[]
    connectOrCreate?: OperationDefectEditRequestCreateOrConnectWithoutOperationDefectInput | OperationDefectEditRequestCreateOrConnectWithoutOperationDefectInput[]
    upsert?: OperationDefectEditRequestUpsertWithWhereUniqueWithoutOperationDefectInput | OperationDefectEditRequestUpsertWithWhereUniqueWithoutOperationDefectInput[]
    createMany?: OperationDefectEditRequestCreateManyOperationDefectInputEnvelope
    set?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    disconnect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    delete?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    connect?: OperationDefectEditRequestWhereUniqueInput | OperationDefectEditRequestWhereUniqueInput[]
    update?: OperationDefectEditRequestUpdateWithWhereUniqueWithoutOperationDefectInput | OperationDefectEditRequestUpdateWithWhereUniqueWithoutOperationDefectInput[]
    updateMany?: OperationDefectEditRequestUpdateManyWithWhereWithoutOperationDefectInput | OperationDefectEditRequestUpdateManyWithWhereWithoutOperationDefectInput[]
    deleteMany?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
  }

  export type OperationDefectCreateNestedOneWithoutEditRequestsInput = {
    create?: XOR<OperationDefectCreateWithoutEditRequestsInput, OperationDefectUncheckedCreateWithoutEditRequestsInput>
    connectOrCreate?: OperationDefectCreateOrConnectWithoutEditRequestsInput
    connect?: OperationDefectWhereUniqueInput
  }

  export type OperationCreateNestedOneWithoutEditRequestsInput = {
    create?: XOR<OperationCreateWithoutEditRequestsInput, OperationUncheckedCreateWithoutEditRequestsInput>
    connectOrCreate?: OperationCreateOrConnectWithoutEditRequestsInput
    connect?: OperationWhereUniqueInput
  }

  export type ProductionOrderCreateNestedOneWithoutEditRequestsInput = {
    create?: XOR<ProductionOrderCreateWithoutEditRequestsInput, ProductionOrderUncheckedCreateWithoutEditRequestsInput>
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutEditRequestsInput
    connect?: ProductionOrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestedEditRequestsInput = {
    create?: XOR<UserCreateWithoutRequestedEditRequestsInput, UserUncheckedCreateWithoutRequestedEditRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestedEditRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResolvedEditRequestsInput = {
    create?: XOR<UserCreateWithoutResolvedEditRequestsInput, UserUncheckedCreateWithoutResolvedEditRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedEditRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type OperationDefectUpdateOneWithoutEditRequestsNestedInput = {
    create?: XOR<OperationDefectCreateWithoutEditRequestsInput, OperationDefectUncheckedCreateWithoutEditRequestsInput>
    connectOrCreate?: OperationDefectCreateOrConnectWithoutEditRequestsInput
    upsert?: OperationDefectUpsertWithoutEditRequestsInput
    disconnect?: OperationDefectWhereInput | boolean
    delete?: OperationDefectWhereInput | boolean
    connect?: OperationDefectWhereUniqueInput
    update?: XOR<XOR<OperationDefectUpdateToOneWithWhereWithoutEditRequestsInput, OperationDefectUpdateWithoutEditRequestsInput>, OperationDefectUncheckedUpdateWithoutEditRequestsInput>
  }

  export type OperationUpdateOneRequiredWithoutEditRequestsNestedInput = {
    create?: XOR<OperationCreateWithoutEditRequestsInput, OperationUncheckedCreateWithoutEditRequestsInput>
    connectOrCreate?: OperationCreateOrConnectWithoutEditRequestsInput
    upsert?: OperationUpsertWithoutEditRequestsInput
    connect?: OperationWhereUniqueInput
    update?: XOR<XOR<OperationUpdateToOneWithWhereWithoutEditRequestsInput, OperationUpdateWithoutEditRequestsInput>, OperationUncheckedUpdateWithoutEditRequestsInput>
  }

  export type ProductionOrderUpdateOneRequiredWithoutEditRequestsNestedInput = {
    create?: XOR<ProductionOrderCreateWithoutEditRequestsInput, ProductionOrderUncheckedCreateWithoutEditRequestsInput>
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutEditRequestsInput
    upsert?: ProductionOrderUpsertWithoutEditRequestsInput
    connect?: ProductionOrderWhereUniqueInput
    update?: XOR<XOR<ProductionOrderUpdateToOneWithWhereWithoutEditRequestsInput, ProductionOrderUpdateWithoutEditRequestsInput>, ProductionOrderUncheckedUpdateWithoutEditRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutRequestedEditRequestsNestedInput = {
    create?: XOR<UserCreateWithoutRequestedEditRequestsInput, UserUncheckedCreateWithoutRequestedEditRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestedEditRequestsInput
    upsert?: UserUpsertWithoutRequestedEditRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequestedEditRequestsInput, UserUpdateWithoutRequestedEditRequestsInput>, UserUncheckedUpdateWithoutRequestedEditRequestsInput>
  }

  export type UserUpdateOneWithoutResolvedEditRequestsNestedInput = {
    create?: XOR<UserCreateWithoutResolvedEditRequestsInput, UserUncheckedCreateWithoutResolvedEditRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedEditRequestsInput
    upsert?: UserUpsertWithoutResolvedEditRequestsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResolvedEditRequestsInput, UserUpdateWithoutResolvedEditRequestsInput>, UserUncheckedUpdateWithoutResolvedEditRequestsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCreateWithoutUserInput = {
    tableName: string
    recordId: string
    action: string
    oldValues?: string | null
    newValues?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number
    tableName: string
    recordId: string
    action: string
    oldValues?: string | null
    newValues?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MasterDefectCreateWithoutDeactivatedByInput = {
    name: string
    description?: string | null
    category?: string | null
    applicableOperation?: string | null
    reworkable?: boolean
    machine?: string | null
    isActive?: boolean
    deactivatedAt?: Date | string | null
    operationDefects?: OperationDefectCreateNestedManyWithoutDefectInput
  }

  export type MasterDefectUncheckedCreateWithoutDeactivatedByInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    applicableOperation?: string | null
    reworkable?: boolean
    machine?: string | null
    isActive?: boolean
    deactivatedAt?: Date | string | null
    operationDefects?: OperationDefectUncheckedCreateNestedManyWithoutDefectInput
  }

  export type MasterDefectCreateOrConnectWithoutDeactivatedByInput = {
    where: MasterDefectWhereUniqueInput
    create: XOR<MasterDefectCreateWithoutDeactivatedByInput, MasterDefectUncheckedCreateWithoutDeactivatedByInput>
  }

  export type MasterDefectCreateManyDeactivatedByInputEnvelope = {
    data: MasterDefectCreateManyDeactivatedByInput | MasterDefectCreateManyDeactivatedByInput[]
    skipDuplicates?: boolean
  }

  export type OperationDefectEditRequestCreateWithoutRequestedByInput = {
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    operationDefect?: OperationDefectCreateNestedOneWithoutEditRequestsInput
    operation: OperationCreateNestedOneWithoutEditRequestsInput
    productionOrder: ProductionOrderCreateNestedOneWithoutEditRequestsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedEditRequestsInput
  }

  export type OperationDefectEditRequestUncheckedCreateWithoutRequestedByInput = {
    id?: number
    operationDefectId?: number | null
    operationId: number
    productionOrderId: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolvedById?: number | null
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationDefectEditRequestCreateOrConnectWithoutRequestedByInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    create: XOR<OperationDefectEditRequestCreateWithoutRequestedByInput, OperationDefectEditRequestUncheckedCreateWithoutRequestedByInput>
  }

  export type OperationDefectEditRequestCreateManyRequestedByInputEnvelope = {
    data: OperationDefectEditRequestCreateManyRequestedByInput | OperationDefectEditRequestCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type OperationDefectEditRequestCreateWithoutResolvedByInput = {
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    operationDefect?: OperationDefectCreateNestedOneWithoutEditRequestsInput
    operation: OperationCreateNestedOneWithoutEditRequestsInput
    productionOrder: ProductionOrderCreateNestedOneWithoutEditRequestsInput
    requestedBy: UserCreateNestedOneWithoutRequestedEditRequestsInput
  }

  export type OperationDefectEditRequestUncheckedCreateWithoutResolvedByInput = {
    id?: number
    operationDefectId?: number | null
    operationId: number
    productionOrderId: number
    requestedById: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationDefectEditRequestCreateOrConnectWithoutResolvedByInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    create: XOR<OperationDefectEditRequestCreateWithoutResolvedByInput, OperationDefectEditRequestUncheckedCreateWithoutResolvedByInput>
  }

  export type OperationDefectEditRequestCreateManyResolvedByInputEnvelope = {
    data: OperationDefectEditRequestCreateManyResolvedByInput | OperationDefectEditRequestCreateManyResolvedByInput[]
    skipDuplicates?: boolean
  }

  export type OperationDefectCreateWithoutRecordedByInput = {
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    editRequests?: OperationDefectEditRequestCreateNestedManyWithoutOperationDefectInput
    defect?: MasterDefectCreateNestedOneWithoutOperationDefectsInput
    operation: OperationCreateNestedOneWithoutOperationDefectsInput
  }

  export type OperationDefectUncheckedCreateWithoutRecordedByInput = {
    id?: number
    operationId: number
    defectId?: number | null
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    editRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutOperationDefectInput
  }

  export type OperationDefectCreateOrConnectWithoutRecordedByInput = {
    where: OperationDefectWhereUniqueInput
    create: XOR<OperationDefectCreateWithoutRecordedByInput, OperationDefectUncheckedCreateWithoutRecordedByInput>
  }

  export type OperationDefectCreateManyRecordedByInputEnvelope = {
    data: OperationDefectCreateManyRecordedByInput | OperationDefectCreateManyRecordedByInput[]
    skipDuplicates?: boolean
  }

  export type OperationCreateWithoutEncodedByInput = {
    operation: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestCreateNestedManyWithoutOperationInput
    operationDefects?: OperationDefectCreateNestedManyWithoutOperationInput
    operator: UserCreateNestedOneWithoutOperationsInput
    productionOrder: ProductionOrderCreateNestedOneWithoutOperationsInput
  }

  export type OperationUncheckedCreateWithoutEncodedByInput = {
    id?: number
    productionOrderId: number
    operation: string
    operatorId: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutOperationInput
    operationDefects?: OperationDefectUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationCreateOrConnectWithoutEncodedByInput = {
    where: OperationWhereUniqueInput
    create: XOR<OperationCreateWithoutEncodedByInput, OperationUncheckedCreateWithoutEncodedByInput>
  }

  export type OperationCreateManyEncodedByInputEnvelope = {
    data: OperationCreateManyEncodedByInput | OperationCreateManyEncodedByInput[]
    skipDuplicates?: boolean
  }

  export type OperationCreateWithoutOperatorInput = {
    operation: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestCreateNestedManyWithoutOperationInput
    operationDefects?: OperationDefectCreateNestedManyWithoutOperationInput
    encodedBy: UserCreateNestedOneWithoutEncodedOperationsInput
    productionOrder: ProductionOrderCreateNestedOneWithoutOperationsInput
  }

  export type OperationUncheckedCreateWithoutOperatorInput = {
    id?: number
    productionOrderId: number
    operation: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedById: number
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutOperationInput
    operationDefects?: OperationDefectUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationCreateOrConnectWithoutOperatorInput = {
    where: OperationWhereUniqueInput
    create: XOR<OperationCreateWithoutOperatorInput, OperationUncheckedCreateWithoutOperatorInput>
  }

  export type OperationCreateManyOperatorInputEnvelope = {
    data: OperationCreateManyOperatorInput | OperationCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivity?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivity?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    linkUrl?: string | null
    sourceId?: string | null
    sourceType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    linkUrl?: string | null
    sourceId?: string | null
    sourceType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    oldValues?: StringNullableFilter<"AuditLog"> | string | null
    newValues?: StringNullableFilter<"AuditLog"> | string | null
    userId?: IntFilter<"AuditLog"> | number
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
  }

  export type MasterDefectUpsertWithWhereUniqueWithoutDeactivatedByInput = {
    where: MasterDefectWhereUniqueInput
    update: XOR<MasterDefectUpdateWithoutDeactivatedByInput, MasterDefectUncheckedUpdateWithoutDeactivatedByInput>
    create: XOR<MasterDefectCreateWithoutDeactivatedByInput, MasterDefectUncheckedCreateWithoutDeactivatedByInput>
  }

  export type MasterDefectUpdateWithWhereUniqueWithoutDeactivatedByInput = {
    where: MasterDefectWhereUniqueInput
    data: XOR<MasterDefectUpdateWithoutDeactivatedByInput, MasterDefectUncheckedUpdateWithoutDeactivatedByInput>
  }

  export type MasterDefectUpdateManyWithWhereWithoutDeactivatedByInput = {
    where: MasterDefectScalarWhereInput
    data: XOR<MasterDefectUpdateManyMutationInput, MasterDefectUncheckedUpdateManyWithoutDeactivatedByInput>
  }

  export type MasterDefectScalarWhereInput = {
    AND?: MasterDefectScalarWhereInput | MasterDefectScalarWhereInput[]
    OR?: MasterDefectScalarWhereInput[]
    NOT?: MasterDefectScalarWhereInput | MasterDefectScalarWhereInput[]
    id?: IntFilter<"MasterDefect"> | number
    name?: StringFilter<"MasterDefect"> | string
    description?: StringNullableFilter<"MasterDefect"> | string | null
    category?: StringNullableFilter<"MasterDefect"> | string | null
    applicableOperation?: StringNullableFilter<"MasterDefect"> | string | null
    reworkable?: BoolFilter<"MasterDefect"> | boolean
    machine?: StringNullableFilter<"MasterDefect"> | string | null
    isActive?: BoolFilter<"MasterDefect"> | boolean
    deactivatedAt?: DateTimeNullableFilter<"MasterDefect"> | Date | string | null
    deactivatedById?: IntNullableFilter<"MasterDefect"> | number | null
  }

  export type OperationDefectEditRequestUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    update: XOR<OperationDefectEditRequestUpdateWithoutRequestedByInput, OperationDefectEditRequestUncheckedUpdateWithoutRequestedByInput>
    create: XOR<OperationDefectEditRequestCreateWithoutRequestedByInput, OperationDefectEditRequestUncheckedCreateWithoutRequestedByInput>
  }

  export type OperationDefectEditRequestUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    data: XOR<OperationDefectEditRequestUpdateWithoutRequestedByInput, OperationDefectEditRequestUncheckedUpdateWithoutRequestedByInput>
  }

  export type OperationDefectEditRequestUpdateManyWithWhereWithoutRequestedByInput = {
    where: OperationDefectEditRequestScalarWhereInput
    data: XOR<OperationDefectEditRequestUpdateManyMutationInput, OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type OperationDefectEditRequestScalarWhereInput = {
    AND?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
    OR?: OperationDefectEditRequestScalarWhereInput[]
    NOT?: OperationDefectEditRequestScalarWhereInput | OperationDefectEditRequestScalarWhereInput[]
    id?: IntFilter<"OperationDefectEditRequest"> | number
    operationDefectId?: IntNullableFilter<"OperationDefectEditRequest"> | number | null
    operationId?: IntFilter<"OperationDefectEditRequest"> | number
    productionOrderId?: IntFilter<"OperationDefectEditRequest"> | number
    requestedById?: IntFilter<"OperationDefectEditRequest"> | number
    requestType?: StringFilter<"OperationDefectEditRequest"> | string
    defectId?: IntNullableFilter<"OperationDefectEditRequest"> | number | null
    defectName?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    defectCategory?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    defectReworkable?: BoolNullableFilter<"OperationDefectEditRequest"> | boolean | null
    defectMachine?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    currentQty?: IntFilter<"OperationDefectEditRequest"> | number
    currentRw?: IntFilter<"OperationDefectEditRequest"> | number
    currentNg?: IntFilter<"OperationDefectEditRequest"> | number
    currentReplacement?: IntFilter<"OperationDefectEditRequest"> | number
    requestedQty?: IntFilter<"OperationDefectEditRequest"> | number
    requestedRw?: IntFilter<"OperationDefectEditRequest"> | number
    requestedNg?: IntFilter<"OperationDefectEditRequest"> | number
    requestedReplacement?: IntFilter<"OperationDefectEditRequest"> | number
    operationCode?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    reason?: StringFilter<"OperationDefectEditRequest"> | string
    status?: StringFilter<"OperationDefectEditRequest"> | string
    resolvedById?: IntNullableFilter<"OperationDefectEditRequest"> | number | null
    resolutionNote?: StringNullableFilter<"OperationDefectEditRequest"> | string | null
    createdAt?: DateTimeFilter<"OperationDefectEditRequest"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"OperationDefectEditRequest"> | Date | string | null
  }

  export type OperationDefectEditRequestUpsertWithWhereUniqueWithoutResolvedByInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    update: XOR<OperationDefectEditRequestUpdateWithoutResolvedByInput, OperationDefectEditRequestUncheckedUpdateWithoutResolvedByInput>
    create: XOR<OperationDefectEditRequestCreateWithoutResolvedByInput, OperationDefectEditRequestUncheckedCreateWithoutResolvedByInput>
  }

  export type OperationDefectEditRequestUpdateWithWhereUniqueWithoutResolvedByInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    data: XOR<OperationDefectEditRequestUpdateWithoutResolvedByInput, OperationDefectEditRequestUncheckedUpdateWithoutResolvedByInput>
  }

  export type OperationDefectEditRequestUpdateManyWithWhereWithoutResolvedByInput = {
    where: OperationDefectEditRequestScalarWhereInput
    data: XOR<OperationDefectEditRequestUpdateManyMutationInput, OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByInput>
  }

  export type OperationDefectUpsertWithWhereUniqueWithoutRecordedByInput = {
    where: OperationDefectWhereUniqueInput
    update: XOR<OperationDefectUpdateWithoutRecordedByInput, OperationDefectUncheckedUpdateWithoutRecordedByInput>
    create: XOR<OperationDefectCreateWithoutRecordedByInput, OperationDefectUncheckedCreateWithoutRecordedByInput>
  }

  export type OperationDefectUpdateWithWhereUniqueWithoutRecordedByInput = {
    where: OperationDefectWhereUniqueInput
    data: XOR<OperationDefectUpdateWithoutRecordedByInput, OperationDefectUncheckedUpdateWithoutRecordedByInput>
  }

  export type OperationDefectUpdateManyWithWhereWithoutRecordedByInput = {
    where: OperationDefectScalarWhereInput
    data: XOR<OperationDefectUpdateManyMutationInput, OperationDefectUncheckedUpdateManyWithoutRecordedByInput>
  }

  export type OperationDefectScalarWhereInput = {
    AND?: OperationDefectScalarWhereInput | OperationDefectScalarWhereInput[]
    OR?: OperationDefectScalarWhereInput[]
    NOT?: OperationDefectScalarWhereInput | OperationDefectScalarWhereInput[]
    id?: IntFilter<"OperationDefect"> | number
    operationId?: IntFilter<"OperationDefect"> | number
    defectId?: IntNullableFilter<"OperationDefect"> | number | null
    defectName?: StringNullableFilter<"OperationDefect"> | string | null
    defectCategory?: StringFilter<"OperationDefect"> | string
    defectMachine?: StringNullableFilter<"OperationDefect"> | string | null
    defectReworkable?: BoolFilter<"OperationDefect"> | boolean
    quantity?: IntFilter<"OperationDefect"> | number
    quantityRework?: IntFilter<"OperationDefect"> | number
    quantityNogood?: IntFilter<"OperationDefect"> | number
    quantityReplacement?: IntFilter<"OperationDefect"> | number
    recordedAt?: DateTimeFilter<"OperationDefect"> | Date | string
    recordedById?: IntFilter<"OperationDefect"> | number
  }

  export type OperationUpsertWithWhereUniqueWithoutEncodedByInput = {
    where: OperationWhereUniqueInput
    update: XOR<OperationUpdateWithoutEncodedByInput, OperationUncheckedUpdateWithoutEncodedByInput>
    create: XOR<OperationCreateWithoutEncodedByInput, OperationUncheckedCreateWithoutEncodedByInput>
  }

  export type OperationUpdateWithWhereUniqueWithoutEncodedByInput = {
    where: OperationWhereUniqueInput
    data: XOR<OperationUpdateWithoutEncodedByInput, OperationUncheckedUpdateWithoutEncodedByInput>
  }

  export type OperationUpdateManyWithWhereWithoutEncodedByInput = {
    where: OperationScalarWhereInput
    data: XOR<OperationUpdateManyMutationInput, OperationUncheckedUpdateManyWithoutEncodedByInput>
  }

  export type OperationScalarWhereInput = {
    AND?: OperationScalarWhereInput | OperationScalarWhereInput[]
    OR?: OperationScalarWhereInput[]
    NOT?: OperationScalarWhereInput | OperationScalarWhereInput[]
    id?: IntFilter<"Operation"> | number
    productionOrderId?: IntFilter<"Operation"> | number
    operation?: StringFilter<"Operation"> | string
    operatorId?: IntFilter<"Operation"> | number
    startTime?: DateTimeNullableFilter<"Operation"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Operation"> | Date | string | null
    inputQuantity?: IntFilter<"Operation"> | number
    outputQuantity?: IntNullableFilter<"Operation"> | number | null
    productionHours?: FloatNullableFilter<"Operation"> | number | null
    accumulatedManHours?: FloatNullableFilter<"Operation"> | number | null
    rf?: IntNullableFilter<"Operation"> | number | null
    lineNo?: StringNullableFilter<"Operation"> | string | null
    shift?: StringNullableFilter<"Operation"> | string | null
    encodedById?: IntFilter<"Operation"> | number
    encodedTime?: DateTimeFilter<"Operation"> | Date | string
    defectCost?: DecimalNullableFilter<"Operation"> | Decimal | DecimalJsLike | number | string | null
  }

  export type OperationUpsertWithWhereUniqueWithoutOperatorInput = {
    where: OperationWhereUniqueInput
    update: XOR<OperationUpdateWithoutOperatorInput, OperationUncheckedUpdateWithoutOperatorInput>
    create: XOR<OperationCreateWithoutOperatorInput, OperationUncheckedCreateWithoutOperatorInput>
  }

  export type OperationUpdateWithWhereUniqueWithoutOperatorInput = {
    where: OperationWhereUniqueInput
    data: XOR<OperationUpdateWithoutOperatorInput, OperationUncheckedUpdateWithoutOperatorInput>
  }

  export type OperationUpdateManyWithWhereWithoutOperatorInput = {
    where: OperationScalarWhereInput
    data: XOR<OperationUpdateManyMutationInput, OperationUncheckedUpdateManyWithoutOperatorInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: IntFilter<"Session"> | number
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    lastActivity?: DateTimeFilter<"Session"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    linkUrl?: StringNullableFilter<"Notification"> | string | null
    userId?: IntFilter<"Notification"> | number
    sourceId?: StringNullableFilter<"Notification"> | string | null
    sourceType?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
  }

  export type OperationDefectEditRequestCreateWithoutProductionOrderInput = {
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    operationDefect?: OperationDefectCreateNestedOneWithoutEditRequestsInput
    operation: OperationCreateNestedOneWithoutEditRequestsInput
    requestedBy: UserCreateNestedOneWithoutRequestedEditRequestsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedEditRequestsInput
  }

  export type OperationDefectEditRequestUncheckedCreateWithoutProductionOrderInput = {
    id?: number
    operationDefectId?: number | null
    operationId: number
    requestedById: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolvedById?: number | null
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationDefectEditRequestCreateOrConnectWithoutProductionOrderInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    create: XOR<OperationDefectEditRequestCreateWithoutProductionOrderInput, OperationDefectEditRequestUncheckedCreateWithoutProductionOrderInput>
  }

  export type OperationDefectEditRequestCreateManyProductionOrderInputEnvelope = {
    data: OperationDefectEditRequestCreateManyProductionOrderInput | OperationDefectEditRequestCreateManyProductionOrderInput[]
    skipDuplicates?: boolean
  }

  export type OperationCreateWithoutProductionOrderInput = {
    operation: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestCreateNestedManyWithoutOperationInput
    operationDefects?: OperationDefectCreateNestedManyWithoutOperationInput
    encodedBy: UserCreateNestedOneWithoutEncodedOperationsInput
    operator: UserCreateNestedOneWithoutOperationsInput
  }

  export type OperationUncheckedCreateWithoutProductionOrderInput = {
    id?: number
    operation: string
    operatorId: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedById: number
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutOperationInput
    operationDefects?: OperationDefectUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationCreateOrConnectWithoutProductionOrderInput = {
    where: OperationWhereUniqueInput
    create: XOR<OperationCreateWithoutProductionOrderInput, OperationUncheckedCreateWithoutProductionOrderInput>
  }

  export type OperationCreateManyProductionOrderInputEnvelope = {
    data: OperationCreateManyProductionOrderInput | OperationCreateManyProductionOrderInput[]
    skipDuplicates?: boolean
  }

  export type OperationDefectEditRequestUpsertWithWhereUniqueWithoutProductionOrderInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    update: XOR<OperationDefectEditRequestUpdateWithoutProductionOrderInput, OperationDefectEditRequestUncheckedUpdateWithoutProductionOrderInput>
    create: XOR<OperationDefectEditRequestCreateWithoutProductionOrderInput, OperationDefectEditRequestUncheckedCreateWithoutProductionOrderInput>
  }

  export type OperationDefectEditRequestUpdateWithWhereUniqueWithoutProductionOrderInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    data: XOR<OperationDefectEditRequestUpdateWithoutProductionOrderInput, OperationDefectEditRequestUncheckedUpdateWithoutProductionOrderInput>
  }

  export type OperationDefectEditRequestUpdateManyWithWhereWithoutProductionOrderInput = {
    where: OperationDefectEditRequestScalarWhereInput
    data: XOR<OperationDefectEditRequestUpdateManyMutationInput, OperationDefectEditRequestUncheckedUpdateManyWithoutProductionOrderInput>
  }

  export type OperationUpsertWithWhereUniqueWithoutProductionOrderInput = {
    where: OperationWhereUniqueInput
    update: XOR<OperationUpdateWithoutProductionOrderInput, OperationUncheckedUpdateWithoutProductionOrderInput>
    create: XOR<OperationCreateWithoutProductionOrderInput, OperationUncheckedCreateWithoutProductionOrderInput>
  }

  export type OperationUpdateWithWhereUniqueWithoutProductionOrderInput = {
    where: OperationWhereUniqueInput
    data: XOR<OperationUpdateWithoutProductionOrderInput, OperationUncheckedUpdateWithoutProductionOrderInput>
  }

  export type OperationUpdateManyWithWhereWithoutProductionOrderInput = {
    where: OperationScalarWhereInput
    data: XOR<OperationUpdateManyMutationInput, OperationUncheckedUpdateManyWithoutProductionOrderInput>
  }

  export type OperationDefectEditRequestCreateWithoutOperationInput = {
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    operationDefect?: OperationDefectCreateNestedOneWithoutEditRequestsInput
    productionOrder: ProductionOrderCreateNestedOneWithoutEditRequestsInput
    requestedBy: UserCreateNestedOneWithoutRequestedEditRequestsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedEditRequestsInput
  }

  export type OperationDefectEditRequestUncheckedCreateWithoutOperationInput = {
    id?: number
    operationDefectId?: number | null
    productionOrderId: number
    requestedById: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolvedById?: number | null
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationDefectEditRequestCreateOrConnectWithoutOperationInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    create: XOR<OperationDefectEditRequestCreateWithoutOperationInput, OperationDefectEditRequestUncheckedCreateWithoutOperationInput>
  }

  export type OperationDefectEditRequestCreateManyOperationInputEnvelope = {
    data: OperationDefectEditRequestCreateManyOperationInput | OperationDefectEditRequestCreateManyOperationInput[]
    skipDuplicates?: boolean
  }

  export type OperationDefectCreateWithoutOperationInput = {
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    editRequests?: OperationDefectEditRequestCreateNestedManyWithoutOperationDefectInput
    defect?: MasterDefectCreateNestedOneWithoutOperationDefectsInput
    recordedBy: UserCreateNestedOneWithoutRecordedDefectsInput
  }

  export type OperationDefectUncheckedCreateWithoutOperationInput = {
    id?: number
    defectId?: number | null
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    recordedById: number
    editRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutOperationDefectInput
  }

  export type OperationDefectCreateOrConnectWithoutOperationInput = {
    where: OperationDefectWhereUniqueInput
    create: XOR<OperationDefectCreateWithoutOperationInput, OperationDefectUncheckedCreateWithoutOperationInput>
  }

  export type OperationDefectCreateManyOperationInputEnvelope = {
    data: OperationDefectCreateManyOperationInput | OperationDefectCreateManyOperationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutEncodedOperationsInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectCreateNestedManyWithoutRecordedByInput
    operations?: OperationCreateNestedManyWithoutOperatorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEncodedOperationsInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectUncheckedCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectUncheckedCreateNestedManyWithoutRecordedByInput
    operations?: OperationUncheckedCreateNestedManyWithoutOperatorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEncodedOperationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEncodedOperationsInput, UserUncheckedCreateWithoutEncodedOperationsInput>
  }

  export type UserCreateWithoutOperationsInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationCreateNestedManyWithoutEncodedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOperationsInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectUncheckedCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectUncheckedCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationUncheckedCreateNestedManyWithoutEncodedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOperationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOperationsInput, UserUncheckedCreateWithoutOperationsInput>
  }

  export type ProductionOrderCreateWithoutOperationsInput = {
    poNumber: string
    lotNumber?: string | null
    poQuantity: number
    itemName?: string | null
    status: string
    currentOperation?: string | null
    currentOperationStartTime?: Date | string | null
    currentOperationEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    editingUserId?: number | null
    editingUserName?: string | null
    lockedAt?: Date | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: Date | string | null
    editRequests?: OperationDefectEditRequestCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderUncheckedCreateWithoutOperationsInput = {
    id?: number
    poNumber: string
    lotNumber?: string | null
    poQuantity: number
    itemName?: string | null
    status: string
    currentOperation?: string | null
    currentOperationStartTime?: Date | string | null
    currentOperationEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    editingUserId?: number | null
    editingUserName?: string | null
    lockedAt?: Date | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: Date | string | null
    editRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderCreateOrConnectWithoutOperationsInput = {
    where: ProductionOrderWhereUniqueInput
    create: XOR<ProductionOrderCreateWithoutOperationsInput, ProductionOrderUncheckedCreateWithoutOperationsInput>
  }

  export type OperationDefectEditRequestUpsertWithWhereUniqueWithoutOperationInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    update: XOR<OperationDefectEditRequestUpdateWithoutOperationInput, OperationDefectEditRequestUncheckedUpdateWithoutOperationInput>
    create: XOR<OperationDefectEditRequestCreateWithoutOperationInput, OperationDefectEditRequestUncheckedCreateWithoutOperationInput>
  }

  export type OperationDefectEditRequestUpdateWithWhereUniqueWithoutOperationInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    data: XOR<OperationDefectEditRequestUpdateWithoutOperationInput, OperationDefectEditRequestUncheckedUpdateWithoutOperationInput>
  }

  export type OperationDefectEditRequestUpdateManyWithWhereWithoutOperationInput = {
    where: OperationDefectEditRequestScalarWhereInput
    data: XOR<OperationDefectEditRequestUpdateManyMutationInput, OperationDefectEditRequestUncheckedUpdateManyWithoutOperationInput>
  }

  export type OperationDefectUpsertWithWhereUniqueWithoutOperationInput = {
    where: OperationDefectWhereUniqueInput
    update: XOR<OperationDefectUpdateWithoutOperationInput, OperationDefectUncheckedUpdateWithoutOperationInput>
    create: XOR<OperationDefectCreateWithoutOperationInput, OperationDefectUncheckedCreateWithoutOperationInput>
  }

  export type OperationDefectUpdateWithWhereUniqueWithoutOperationInput = {
    where: OperationDefectWhereUniqueInput
    data: XOR<OperationDefectUpdateWithoutOperationInput, OperationDefectUncheckedUpdateWithoutOperationInput>
  }

  export type OperationDefectUpdateManyWithWhereWithoutOperationInput = {
    where: OperationDefectScalarWhereInput
    data: XOR<OperationDefectUpdateManyMutationInput, OperationDefectUncheckedUpdateManyWithoutOperationInput>
  }

  export type UserUpsertWithoutEncodedOperationsInput = {
    update: XOR<UserUpdateWithoutEncodedOperationsInput, UserUncheckedUpdateWithoutEncodedOperationsInput>
    create: XOR<UserCreateWithoutEncodedOperationsInput, UserUncheckedCreateWithoutEncodedOperationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEncodedOperationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEncodedOperationsInput, UserUncheckedUpdateWithoutEncodedOperationsInput>
  }

  export type UserUpdateWithoutEncodedOperationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUpdateManyWithoutRecordedByNestedInput
    operations?: OperationUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEncodedOperationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUncheckedUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUncheckedUpdateManyWithoutRecordedByNestedInput
    operations?: OperationUncheckedUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutOperationsInput = {
    update: XOR<UserUpdateWithoutOperationsInput, UserUncheckedUpdateWithoutOperationsInput>
    create: XOR<UserCreateWithoutOperationsInput, UserUncheckedCreateWithoutOperationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOperationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOperationsInput, UserUncheckedUpdateWithoutOperationsInput>
  }

  export type UserUpdateWithoutOperationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUpdateManyWithoutEncodedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOperationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUncheckedUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUncheckedUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUncheckedUpdateManyWithoutEncodedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductionOrderUpsertWithoutOperationsInput = {
    update: XOR<ProductionOrderUpdateWithoutOperationsInput, ProductionOrderUncheckedUpdateWithoutOperationsInput>
    create: XOR<ProductionOrderCreateWithoutOperationsInput, ProductionOrderUncheckedCreateWithoutOperationsInput>
    where?: ProductionOrderWhereInput
  }

  export type ProductionOrderUpdateToOneWithWhereWithoutOperationsInput = {
    where?: ProductionOrderWhereInput
    data: XOR<ProductionOrderUpdateWithoutOperationsInput, ProductionOrderUncheckedUpdateWithoutOperationsInput>
  }

  export type ProductionOrderUpdateWithoutOperationsInput = {
    poNumber?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    poQuantity?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentOperation?: NullableStringFieldUpdateOperationsInput | string | null
    currentOperationStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentOperationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editingUserId?: NullableIntFieldUpdateOperationsInput | number | null
    editingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editRequests?: OperationDefectEditRequestUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateWithoutOperationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    poNumber?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    poQuantity?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentOperation?: NullableStringFieldUpdateOperationsInput | string | null
    currentOperationStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentOperationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editingUserId?: NullableIntFieldUpdateOperationsInput | number | null
    editingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    editRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutProductionOrderNestedInput
  }

  export type UserCreateWithoutDeactivatedDefectsInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    requestedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationCreateNestedManyWithoutEncodedByInput
    operations?: OperationCreateNestedManyWithoutOperatorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeactivatedDefectsInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectUncheckedCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationUncheckedCreateNestedManyWithoutEncodedByInput
    operations?: OperationUncheckedCreateNestedManyWithoutOperatorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeactivatedDefectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeactivatedDefectsInput, UserUncheckedCreateWithoutDeactivatedDefectsInput>
  }

  export type OperationDefectCreateWithoutDefectInput = {
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    editRequests?: OperationDefectEditRequestCreateNestedManyWithoutOperationDefectInput
    operation: OperationCreateNestedOneWithoutOperationDefectsInput
    recordedBy: UserCreateNestedOneWithoutRecordedDefectsInput
  }

  export type OperationDefectUncheckedCreateWithoutDefectInput = {
    id?: number
    operationId: number
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    recordedById: number
    editRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutOperationDefectInput
  }

  export type OperationDefectCreateOrConnectWithoutDefectInput = {
    where: OperationDefectWhereUniqueInput
    create: XOR<OperationDefectCreateWithoutDefectInput, OperationDefectUncheckedCreateWithoutDefectInput>
  }

  export type OperationDefectCreateManyDefectInputEnvelope = {
    data: OperationDefectCreateManyDefectInput | OperationDefectCreateManyDefectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDeactivatedDefectsInput = {
    update: XOR<UserUpdateWithoutDeactivatedDefectsInput, UserUncheckedUpdateWithoutDeactivatedDefectsInput>
    create: XOR<UserCreateWithoutDeactivatedDefectsInput, UserUncheckedCreateWithoutDeactivatedDefectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeactivatedDefectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeactivatedDefectsInput, UserUncheckedUpdateWithoutDeactivatedDefectsInput>
  }

  export type UserUpdateWithoutDeactivatedDefectsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    requestedEditRequests?: OperationDefectEditRequestUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeactivatedDefectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUncheckedUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUncheckedUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUncheckedUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OperationDefectUpsertWithWhereUniqueWithoutDefectInput = {
    where: OperationDefectWhereUniqueInput
    update: XOR<OperationDefectUpdateWithoutDefectInput, OperationDefectUncheckedUpdateWithoutDefectInput>
    create: XOR<OperationDefectCreateWithoutDefectInput, OperationDefectUncheckedCreateWithoutDefectInput>
  }

  export type OperationDefectUpdateWithWhereUniqueWithoutDefectInput = {
    where: OperationDefectWhereUniqueInput
    data: XOR<OperationDefectUpdateWithoutDefectInput, OperationDefectUncheckedUpdateWithoutDefectInput>
  }

  export type OperationDefectUpdateManyWithWhereWithoutDefectInput = {
    where: OperationDefectScalarWhereInput
    data: XOR<OperationDefectUpdateManyMutationInput, OperationDefectUncheckedUpdateManyWithoutDefectInput>
  }

  export type OperationDefectEditRequestCreateWithoutOperationDefectInput = {
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    operation: OperationCreateNestedOneWithoutEditRequestsInput
    productionOrder: ProductionOrderCreateNestedOneWithoutEditRequestsInput
    requestedBy: UserCreateNestedOneWithoutRequestedEditRequestsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedEditRequestsInput
  }

  export type OperationDefectEditRequestUncheckedCreateWithoutOperationDefectInput = {
    id?: number
    operationId: number
    productionOrderId: number
    requestedById: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolvedById?: number | null
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationDefectEditRequestCreateOrConnectWithoutOperationDefectInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    create: XOR<OperationDefectEditRequestCreateWithoutOperationDefectInput, OperationDefectEditRequestUncheckedCreateWithoutOperationDefectInput>
  }

  export type OperationDefectEditRequestCreateManyOperationDefectInputEnvelope = {
    data: OperationDefectEditRequestCreateManyOperationDefectInput | OperationDefectEditRequestCreateManyOperationDefectInput[]
    skipDuplicates?: boolean
  }

  export type MasterDefectCreateWithoutOperationDefectsInput = {
    name: string
    description?: string | null
    category?: string | null
    applicableOperation?: string | null
    reworkable?: boolean
    machine?: string | null
    isActive?: boolean
    deactivatedAt?: Date | string | null
    deactivatedBy?: UserCreateNestedOneWithoutDeactivatedDefectsInput
  }

  export type MasterDefectUncheckedCreateWithoutOperationDefectsInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    applicableOperation?: string | null
    reworkable?: boolean
    machine?: string | null
    isActive?: boolean
    deactivatedAt?: Date | string | null
    deactivatedById?: number | null
  }

  export type MasterDefectCreateOrConnectWithoutOperationDefectsInput = {
    where: MasterDefectWhereUniqueInput
    create: XOR<MasterDefectCreateWithoutOperationDefectsInput, MasterDefectUncheckedCreateWithoutOperationDefectsInput>
  }

  export type OperationCreateWithoutOperationDefectsInput = {
    operation: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestCreateNestedManyWithoutOperationInput
    encodedBy: UserCreateNestedOneWithoutEncodedOperationsInput
    operator: UserCreateNestedOneWithoutOperationsInput
    productionOrder: ProductionOrderCreateNestedOneWithoutOperationsInput
  }

  export type OperationUncheckedCreateWithoutOperationDefectsInput = {
    id?: number
    productionOrderId: number
    operation: string
    operatorId: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedById: number
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationCreateOrConnectWithoutOperationDefectsInput = {
    where: OperationWhereUniqueInput
    create: XOR<OperationCreateWithoutOperationDefectsInput, OperationUncheckedCreateWithoutOperationDefectsInput>
  }

  export type UserCreateWithoutRecordedDefectsInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutResolvedByInput
    encodedOperations?: OperationCreateNestedManyWithoutEncodedByInput
    operations?: OperationCreateNestedManyWithoutOperatorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecordedDefectsInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectUncheckedCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutResolvedByInput
    encodedOperations?: OperationUncheckedCreateNestedManyWithoutEncodedByInput
    operations?: OperationUncheckedCreateNestedManyWithoutOperatorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecordedDefectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecordedDefectsInput, UserUncheckedCreateWithoutRecordedDefectsInput>
  }

  export type OperationDefectEditRequestUpsertWithWhereUniqueWithoutOperationDefectInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    update: XOR<OperationDefectEditRequestUpdateWithoutOperationDefectInput, OperationDefectEditRequestUncheckedUpdateWithoutOperationDefectInput>
    create: XOR<OperationDefectEditRequestCreateWithoutOperationDefectInput, OperationDefectEditRequestUncheckedCreateWithoutOperationDefectInput>
  }

  export type OperationDefectEditRequestUpdateWithWhereUniqueWithoutOperationDefectInput = {
    where: OperationDefectEditRequestWhereUniqueInput
    data: XOR<OperationDefectEditRequestUpdateWithoutOperationDefectInput, OperationDefectEditRequestUncheckedUpdateWithoutOperationDefectInput>
  }

  export type OperationDefectEditRequestUpdateManyWithWhereWithoutOperationDefectInput = {
    where: OperationDefectEditRequestScalarWhereInput
    data: XOR<OperationDefectEditRequestUpdateManyMutationInput, OperationDefectEditRequestUncheckedUpdateManyWithoutOperationDefectInput>
  }

  export type MasterDefectUpsertWithoutOperationDefectsInput = {
    update: XOR<MasterDefectUpdateWithoutOperationDefectsInput, MasterDefectUncheckedUpdateWithoutOperationDefectsInput>
    create: XOR<MasterDefectCreateWithoutOperationDefectsInput, MasterDefectUncheckedCreateWithoutOperationDefectsInput>
    where?: MasterDefectWhereInput
  }

  export type MasterDefectUpdateToOneWithWhereWithoutOperationDefectsInput = {
    where?: MasterDefectWhereInput
    data: XOR<MasterDefectUpdateWithoutOperationDefectsInput, MasterDefectUncheckedUpdateWithoutOperationDefectsInput>
  }

  export type MasterDefectUpdateWithoutOperationDefectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    applicableOperation?: NullableStringFieldUpdateOperationsInput | string | null
    reworkable?: BoolFieldUpdateOperationsInput | boolean
    machine?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: UserUpdateOneWithoutDeactivatedDefectsNestedInput
  }

  export type MasterDefectUncheckedUpdateWithoutOperationDefectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    applicableOperation?: NullableStringFieldUpdateOperationsInput | string | null
    reworkable?: BoolFieldUpdateOperationsInput | boolean
    machine?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperationUpsertWithoutOperationDefectsInput = {
    update: XOR<OperationUpdateWithoutOperationDefectsInput, OperationUncheckedUpdateWithoutOperationDefectsInput>
    create: XOR<OperationCreateWithoutOperationDefectsInput, OperationUncheckedCreateWithoutOperationDefectsInput>
    where?: OperationWhereInput
  }

  export type OperationUpdateToOneWithWhereWithoutOperationDefectsInput = {
    where?: OperationWhereInput
    data: XOR<OperationUpdateWithoutOperationDefectsInput, OperationUncheckedUpdateWithoutOperationDefectsInput>
  }

  export type OperationUpdateWithoutOperationDefectsInput = {
    operation?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUpdateManyWithoutOperationNestedInput
    encodedBy?: UserUpdateOneRequiredWithoutEncodedOperationsNestedInput
    operator?: UserUpdateOneRequiredWithoutOperationsNestedInput
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type OperationUncheckedUpdateWithoutOperationDefectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    operation?: StringFieldUpdateOperationsInput | string
    operatorId?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedById?: IntFieldUpdateOperationsInput | number
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type UserUpsertWithoutRecordedDefectsInput = {
    update: XOR<UserUpdateWithoutRecordedDefectsInput, UserUncheckedUpdateWithoutRecordedDefectsInput>
    create: XOR<UserCreateWithoutRecordedDefectsInput, UserUncheckedCreateWithoutRecordedDefectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecordedDefectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecordedDefectsInput, UserUncheckedUpdateWithoutRecordedDefectsInput>
  }

  export type UserUpdateWithoutRecordedDefectsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUpdateManyWithoutResolvedByNestedInput
    encodedOperations?: OperationUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecordedDefectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUncheckedUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByNestedInput
    encodedOperations?: OperationUncheckedUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUncheckedUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OperationDefectCreateWithoutEditRequestsInput = {
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    defect?: MasterDefectCreateNestedOneWithoutOperationDefectsInput
    operation: OperationCreateNestedOneWithoutOperationDefectsInput
    recordedBy: UserCreateNestedOneWithoutRecordedDefectsInput
  }

  export type OperationDefectUncheckedCreateWithoutEditRequestsInput = {
    id?: number
    operationId: number
    defectId?: number | null
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    recordedById: number
  }

  export type OperationDefectCreateOrConnectWithoutEditRequestsInput = {
    where: OperationDefectWhereUniqueInput
    create: XOR<OperationDefectCreateWithoutEditRequestsInput, OperationDefectUncheckedCreateWithoutEditRequestsInput>
  }

  export type OperationCreateWithoutEditRequestsInput = {
    operation: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    operationDefects?: OperationDefectCreateNestedManyWithoutOperationInput
    encodedBy: UserCreateNestedOneWithoutEncodedOperationsInput
    operator: UserCreateNestedOneWithoutOperationsInput
    productionOrder: ProductionOrderCreateNestedOneWithoutOperationsInput
  }

  export type OperationUncheckedCreateWithoutEditRequestsInput = {
    id?: number
    productionOrderId: number
    operation: string
    operatorId: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedById: number
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
    operationDefects?: OperationDefectUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationCreateOrConnectWithoutEditRequestsInput = {
    where: OperationWhereUniqueInput
    create: XOR<OperationCreateWithoutEditRequestsInput, OperationUncheckedCreateWithoutEditRequestsInput>
  }

  export type ProductionOrderCreateWithoutEditRequestsInput = {
    poNumber: string
    lotNumber?: string | null
    poQuantity: number
    itemName?: string | null
    status: string
    currentOperation?: string | null
    currentOperationStartTime?: Date | string | null
    currentOperationEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    editingUserId?: number | null
    editingUserName?: string | null
    lockedAt?: Date | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: Date | string | null
    operations?: OperationCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderUncheckedCreateWithoutEditRequestsInput = {
    id?: number
    poNumber: string
    lotNumber?: string | null
    poQuantity: number
    itemName?: string | null
    status: string
    currentOperation?: string | null
    currentOperationStartTime?: Date | string | null
    currentOperationEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    editingUserId?: number | null
    editingUserName?: string | null
    lockedAt?: Date | string | null
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: Date | string | null
    operations?: OperationUncheckedCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderCreateOrConnectWithoutEditRequestsInput = {
    where: ProductionOrderWhereUniqueInput
    create: XOR<ProductionOrderCreateWithoutEditRequestsInput, ProductionOrderUncheckedCreateWithoutEditRequestsInput>
  }

  export type UserCreateWithoutRequestedEditRequestsInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectCreateNestedManyWithoutDeactivatedByInput
    resolvedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationCreateNestedManyWithoutEncodedByInput
    operations?: OperationCreateNestedManyWithoutOperatorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRequestedEditRequestsInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectUncheckedCreateNestedManyWithoutDeactivatedByInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectUncheckedCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationUncheckedCreateNestedManyWithoutEncodedByInput
    operations?: OperationUncheckedCreateNestedManyWithoutOperatorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRequestedEditRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestedEditRequestsInput, UserUncheckedCreateWithoutRequestedEditRequestsInput>
  }

  export type UserCreateWithoutResolvedEditRequestsInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutRequestedByInput
    recordedDefects?: OperationDefectCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationCreateNestedManyWithoutEncodedByInput
    operations?: OperationCreateNestedManyWithoutOperatorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResolvedEditRequestsInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectUncheckedCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutRequestedByInput
    recordedDefects?: OperationDefectUncheckedCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationUncheckedCreateNestedManyWithoutEncodedByInput
    operations?: OperationUncheckedCreateNestedManyWithoutOperatorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResolvedEditRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResolvedEditRequestsInput, UserUncheckedCreateWithoutResolvedEditRequestsInput>
  }

  export type OperationDefectUpsertWithoutEditRequestsInput = {
    update: XOR<OperationDefectUpdateWithoutEditRequestsInput, OperationDefectUncheckedUpdateWithoutEditRequestsInput>
    create: XOR<OperationDefectCreateWithoutEditRequestsInput, OperationDefectUncheckedCreateWithoutEditRequestsInput>
    where?: OperationDefectWhereInput
  }

  export type OperationDefectUpdateToOneWithWhereWithoutEditRequestsInput = {
    where?: OperationDefectWhereInput
    data: XOR<OperationDefectUpdateWithoutEditRequestsInput, OperationDefectUncheckedUpdateWithoutEditRequestsInput>
  }

  export type OperationDefectUpdateWithoutEditRequestsInput = {
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defect?: MasterDefectUpdateOneWithoutOperationDefectsNestedInput
    operation?: OperationUpdateOneRequiredWithoutOperationDefectsNestedInput
    recordedBy?: UserUpdateOneRequiredWithoutRecordedDefectsNestedInput
  }

  export type OperationDefectUncheckedUpdateWithoutEditRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationId?: IntFieldUpdateOperationsInput | number
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: IntFieldUpdateOperationsInput | number
  }

  export type OperationUpsertWithoutEditRequestsInput = {
    update: XOR<OperationUpdateWithoutEditRequestsInput, OperationUncheckedUpdateWithoutEditRequestsInput>
    create: XOR<OperationCreateWithoutEditRequestsInput, OperationUncheckedCreateWithoutEditRequestsInput>
    where?: OperationWhereInput
  }

  export type OperationUpdateToOneWithWhereWithoutEditRequestsInput = {
    where?: OperationWhereInput
    data: XOR<OperationUpdateWithoutEditRequestsInput, OperationUncheckedUpdateWithoutEditRequestsInput>
  }

  export type OperationUpdateWithoutEditRequestsInput = {
    operation?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operationDefects?: OperationDefectUpdateManyWithoutOperationNestedInput
    encodedBy?: UserUpdateOneRequiredWithoutEncodedOperationsNestedInput
    operator?: UserUpdateOneRequiredWithoutOperationsNestedInput
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type OperationUncheckedUpdateWithoutEditRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    operation?: StringFieldUpdateOperationsInput | string
    operatorId?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedById?: IntFieldUpdateOperationsInput | number
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operationDefects?: OperationDefectUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type ProductionOrderUpsertWithoutEditRequestsInput = {
    update: XOR<ProductionOrderUpdateWithoutEditRequestsInput, ProductionOrderUncheckedUpdateWithoutEditRequestsInput>
    create: XOR<ProductionOrderCreateWithoutEditRequestsInput, ProductionOrderUncheckedCreateWithoutEditRequestsInput>
    where?: ProductionOrderWhereInput
  }

  export type ProductionOrderUpdateToOneWithWhereWithoutEditRequestsInput = {
    where?: ProductionOrderWhereInput
    data: XOR<ProductionOrderUpdateWithoutEditRequestsInput, ProductionOrderUncheckedUpdateWithoutEditRequestsInput>
  }

  export type ProductionOrderUpdateWithoutEditRequestsInput = {
    poNumber?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    poQuantity?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentOperation?: NullableStringFieldUpdateOperationsInput | string | null
    currentOperationStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentOperationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editingUserId?: NullableIntFieldUpdateOperationsInput | number | null
    editingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operations?: OperationUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateWithoutEditRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    poNumber?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    poQuantity?: IntFieldUpdateOperationsInput | number
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentOperation?: NullableStringFieldUpdateOperationsInput | string | null
    currentOperationStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentOperationEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editingUserId?: NullableIntFieldUpdateOperationsInput | number | null
    editingUserName?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDefectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCostUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operations?: OperationUncheckedUpdateManyWithoutProductionOrderNestedInput
  }

  export type UserUpsertWithoutRequestedEditRequestsInput = {
    update: XOR<UserUpdateWithoutRequestedEditRequestsInput, UserUncheckedUpdateWithoutRequestedEditRequestsInput>
    create: XOR<UserCreateWithoutRequestedEditRequestsInput, UserUncheckedCreateWithoutRequestedEditRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequestedEditRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequestedEditRequestsInput, UserUncheckedUpdateWithoutRequestedEditRequestsInput>
  }

  export type UserUpdateWithoutRequestedEditRequestsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUpdateManyWithoutDeactivatedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestedEditRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUncheckedUpdateManyWithoutDeactivatedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUncheckedUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUncheckedUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUncheckedUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutResolvedEditRequestsInput = {
    update: XOR<UserUpdateWithoutResolvedEditRequestsInput, UserUncheckedUpdateWithoutResolvedEditRequestsInput>
    create: XOR<UserCreateWithoutResolvedEditRequestsInput, UserUncheckedCreateWithoutResolvedEditRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResolvedEditRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResolvedEditRequestsInput, UserUncheckedUpdateWithoutResolvedEditRequestsInput>
  }

  export type UserUpdateWithoutResolvedEditRequestsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUpdateManyWithoutRequestedByNestedInput
    recordedDefects?: OperationDefectUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResolvedEditRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUncheckedUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    recordedDefects?: OperationDefectUncheckedUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUncheckedUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUncheckedUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    deactivatedDefects?: MasterDefectCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationCreateNestedManyWithoutEncodedByInput
    operations?: OperationCreateNestedManyWithoutOperatorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    deactivatedDefects?: MasterDefectUncheckedCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectUncheckedCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationUncheckedCreateNestedManyWithoutEncodedByInput
    operations?: OperationUncheckedCreateNestedManyWithoutOperatorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedDefects?: MasterDefectUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    deactivatedDefects?: MasterDefectUncheckedUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUncheckedUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUncheckedUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUncheckedUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationCreateNestedManyWithoutEncodedByInput
    operations?: OperationCreateNestedManyWithoutOperatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectUncheckedCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectUncheckedCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationUncheckedCreateNestedManyWithoutEncodedByInput
    operations?: OperationUncheckedCreateNestedManyWithoutOperatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUpdateManyWithoutOperatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUncheckedUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUncheckedUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUncheckedUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUncheckedUpdateManyWithoutOperatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationCreateNestedManyWithoutEncodedByInput
    operations?: OperationCreateNestedManyWithoutOperatorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    lastLogin?: Date | string | null
    department?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deactivatedDefects?: MasterDefectUncheckedCreateNestedManyWithoutDeactivatedByInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutRequestedByInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedCreateNestedManyWithoutResolvedByInput
    recordedDefects?: OperationDefectUncheckedCreateNestedManyWithoutRecordedByInput
    encodedOperations?: OperationUncheckedCreateNestedManyWithoutEncodedByInput
    operations?: OperationUncheckedCreateNestedManyWithoutOperatorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deactivatedDefects?: MasterDefectUncheckedUpdateManyWithoutDeactivatedByNestedInput
    requestedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByNestedInput
    resolvedEditRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByNestedInput
    recordedDefects?: OperationDefectUncheckedUpdateManyWithoutRecordedByNestedInput
    encodedOperations?: OperationUncheckedUpdateManyWithoutEncodedByNestedInput
    operations?: OperationUncheckedUpdateManyWithoutOperatorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AuditLogCreateManyUserInput = {
    id?: number
    tableName: string
    recordId: string
    action: string
    oldValues?: string | null
    newValues?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type MasterDefectCreateManyDeactivatedByInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    applicableOperation?: string | null
    reworkable?: boolean
    machine?: string | null
    isActive?: boolean
    deactivatedAt?: Date | string | null
  }

  export type OperationDefectEditRequestCreateManyRequestedByInput = {
    id?: number
    operationDefectId?: number | null
    operationId: number
    productionOrderId: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolvedById?: number | null
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationDefectEditRequestCreateManyResolvedByInput = {
    id?: number
    operationDefectId?: number | null
    operationId: number
    productionOrderId: number
    requestedById: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationDefectCreateManyRecordedByInput = {
    id?: number
    operationId: number
    defectId?: number | null
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
  }

  export type OperationCreateManyEncodedByInput = {
    id?: number
    productionOrderId: number
    operation: string
    operatorId: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type OperationCreateManyOperatorInput = {
    id?: number
    productionOrderId: number
    operation: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedById: number
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type SessionCreateManyUserInput = {
    id?: number
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    lastActivity?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    linkUrl?: string | null
    sourceId?: string | null
    sourceType?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditLogUpdateWithoutUserInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null
    newValues?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterDefectUpdateWithoutDeactivatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    applicableOperation?: NullableStringFieldUpdateOperationsInput | string | null
    reworkable?: BoolFieldUpdateOperationsInput | boolean
    machine?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDefects?: OperationDefectUpdateManyWithoutDefectNestedInput
  }

  export type MasterDefectUncheckedUpdateWithoutDeactivatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    applicableOperation?: NullableStringFieldUpdateOperationsInput | string | null
    reworkable?: BoolFieldUpdateOperationsInput | boolean
    machine?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDefects?: OperationDefectUncheckedUpdateManyWithoutDefectNestedInput
  }

  export type MasterDefectUncheckedUpdateManyWithoutDeactivatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    applicableOperation?: NullableStringFieldUpdateOperationsInput | string | null
    reworkable?: BoolFieldUpdateOperationsInput | boolean
    machine?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationDefectEditRequestUpdateWithoutRequestedByInput = {
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDefect?: OperationDefectUpdateOneWithoutEditRequestsNestedInput
    operation?: OperationUpdateOneRequiredWithoutEditRequestsNestedInput
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutEditRequestsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedEditRequestsNestedInput
  }

  export type OperationDefectEditRequestUncheckedUpdateWithoutRequestedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationDefectId?: NullableIntFieldUpdateOperationsInput | number | null
    operationId?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationDefectEditRequestUncheckedUpdateManyWithoutRequestedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationDefectId?: NullableIntFieldUpdateOperationsInput | number | null
    operationId?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationDefectEditRequestUpdateWithoutResolvedByInput = {
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDefect?: OperationDefectUpdateOneWithoutEditRequestsNestedInput
    operation?: OperationUpdateOneRequiredWithoutEditRequestsNestedInput
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutEditRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRequestedEditRequestsNestedInput
  }

  export type OperationDefectEditRequestUncheckedUpdateWithoutResolvedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationDefectId?: NullableIntFieldUpdateOperationsInput | number | null
    operationId?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationDefectEditRequestUncheckedUpdateManyWithoutResolvedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationDefectId?: NullableIntFieldUpdateOperationsInput | number | null
    operationId?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationDefectUpdateWithoutRecordedByInput = {
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editRequests?: OperationDefectEditRequestUpdateManyWithoutOperationDefectNestedInput
    defect?: MasterDefectUpdateOneWithoutOperationDefectsNestedInput
    operation?: OperationUpdateOneRequiredWithoutOperationDefectsNestedInput
  }

  export type OperationDefectUncheckedUpdateWithoutRecordedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationId?: IntFieldUpdateOperationsInput | number
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutOperationDefectNestedInput
  }

  export type OperationDefectUncheckedUpdateManyWithoutRecordedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationId?: IntFieldUpdateOperationsInput | number
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationUpdateWithoutEncodedByInput = {
    operation?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUpdateManyWithoutOperationNestedInput
    operationDefects?: OperationDefectUpdateManyWithoutOperationNestedInput
    operator?: UserUpdateOneRequiredWithoutOperationsNestedInput
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type OperationUncheckedUpdateWithoutEncodedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    operation?: StringFieldUpdateOperationsInput | string
    operatorId?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutOperationNestedInput
    operationDefects?: OperationDefectUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateManyWithoutEncodedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    operation?: StringFieldUpdateOperationsInput | string
    operatorId?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type OperationUpdateWithoutOperatorInput = {
    operation?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUpdateManyWithoutOperationNestedInput
    operationDefects?: OperationDefectUpdateManyWithoutOperationNestedInput
    encodedBy?: UserUpdateOneRequiredWithoutEncodedOperationsNestedInput
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type OperationUncheckedUpdateWithoutOperatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    operation?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedById?: IntFieldUpdateOperationsInput | number
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutOperationNestedInput
    operationDefects?: OperationDefectUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateManyWithoutOperatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    operation?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedById?: IntFieldUpdateOperationsInput | number
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type OperationDefectEditRequestCreateManyProductionOrderInput = {
    id?: number
    operationDefectId?: number | null
    operationId: number
    requestedById: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolvedById?: number | null
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationCreateManyProductionOrderInput = {
    id?: number
    operation: string
    operatorId: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    inputQuantity: number
    outputQuantity?: number | null
    productionHours?: number | null
    accumulatedManHours?: number | null
    rf?: number | null
    lineNo?: string | null
    shift?: string | null
    encodedById: number
    encodedTime?: Date | string
    defectCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type OperationDefectEditRequestUpdateWithoutProductionOrderInput = {
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDefect?: OperationDefectUpdateOneWithoutEditRequestsNestedInput
    operation?: OperationUpdateOneRequiredWithoutEditRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRequestedEditRequestsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedEditRequestsNestedInput
  }

  export type OperationDefectEditRequestUncheckedUpdateWithoutProductionOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationDefectId?: NullableIntFieldUpdateOperationsInput | number | null
    operationId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationDefectEditRequestUncheckedUpdateManyWithoutProductionOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationDefectId?: NullableIntFieldUpdateOperationsInput | number | null
    operationId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationUpdateWithoutProductionOrderInput = {
    operation?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUpdateManyWithoutOperationNestedInput
    operationDefects?: OperationDefectUpdateManyWithoutOperationNestedInput
    encodedBy?: UserUpdateOneRequiredWithoutEncodedOperationsNestedInput
    operator?: UserUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type OperationUncheckedUpdateWithoutProductionOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    operation?: StringFieldUpdateOperationsInput | string
    operatorId?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedById?: IntFieldUpdateOperationsInput | number
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    editRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutOperationNestedInput
    operationDefects?: OperationDefectUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateManyWithoutProductionOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    operation?: StringFieldUpdateOperationsInput | string
    operatorId?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inputQuantity?: IntFieldUpdateOperationsInput | number
    outputQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    productionHours?: NullableFloatFieldUpdateOperationsInput | number | null
    accumulatedManHours?: NullableFloatFieldUpdateOperationsInput | number | null
    rf?: NullableIntFieldUpdateOperationsInput | number | null
    lineNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    encodedById?: IntFieldUpdateOperationsInput | number
    encodedTime?: DateTimeFieldUpdateOperationsInput | Date | string
    defectCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type OperationDefectEditRequestCreateManyOperationInput = {
    id?: number
    operationDefectId?: number | null
    productionOrderId: number
    requestedById: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolvedById?: number | null
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationDefectCreateManyOperationInput = {
    id?: number
    defectId?: number | null
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    recordedById: number
  }

  export type OperationDefectEditRequestUpdateWithoutOperationInput = {
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operationDefect?: OperationDefectUpdateOneWithoutEditRequestsNestedInput
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutEditRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRequestedEditRequestsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedEditRequestsNestedInput
  }

  export type OperationDefectEditRequestUncheckedUpdateWithoutOperationInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationDefectId?: NullableIntFieldUpdateOperationsInput | number | null
    productionOrderId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationDefectEditRequestUncheckedUpdateManyWithoutOperationInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationDefectId?: NullableIntFieldUpdateOperationsInput | number | null
    productionOrderId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationDefectUpdateWithoutOperationInput = {
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editRequests?: OperationDefectEditRequestUpdateManyWithoutOperationDefectNestedInput
    defect?: MasterDefectUpdateOneWithoutOperationDefectsNestedInput
    recordedBy?: UserUpdateOneRequiredWithoutRecordedDefectsNestedInput
  }

  export type OperationDefectUncheckedUpdateWithoutOperationInput = {
    id?: IntFieldUpdateOperationsInput | number
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: IntFieldUpdateOperationsInput | number
    editRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutOperationDefectNestedInput
  }

  export type OperationDefectUncheckedUpdateManyWithoutOperationInput = {
    id?: IntFieldUpdateOperationsInput | number
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: IntFieldUpdateOperationsInput | number
  }

  export type OperationDefectCreateManyDefectInput = {
    id?: number
    operationId: number
    defectName?: string | null
    defectCategory: string
    defectMachine?: string | null
    defectReworkable: boolean
    quantity?: number
    quantityRework?: number
    quantityNogood?: number
    quantityReplacement?: number
    recordedAt?: Date | string
    recordedById: number
  }

  export type OperationDefectUpdateWithoutDefectInput = {
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editRequests?: OperationDefectEditRequestUpdateManyWithoutOperationDefectNestedInput
    operation?: OperationUpdateOneRequiredWithoutOperationDefectsNestedInput
    recordedBy?: UserUpdateOneRequiredWithoutRecordedDefectsNestedInput
  }

  export type OperationDefectUncheckedUpdateWithoutDefectInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationId?: IntFieldUpdateOperationsInput | number
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: IntFieldUpdateOperationsInput | number
    editRequests?: OperationDefectEditRequestUncheckedUpdateManyWithoutOperationDefectNestedInput
  }

  export type OperationDefectUncheckedUpdateManyWithoutDefectInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationId?: IntFieldUpdateOperationsInput | number
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: StringFieldUpdateOperationsInput | string
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    quantityRework?: IntFieldUpdateOperationsInput | number
    quantityNogood?: IntFieldUpdateOperationsInput | number
    quantityReplacement?: IntFieldUpdateOperationsInput | number
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedById?: IntFieldUpdateOperationsInput | number
  }

  export type OperationDefectEditRequestCreateManyOperationDefectInput = {
    id?: number
    operationId: number
    productionOrderId: number
    requestedById: number
    requestType?: string
    defectId?: number | null
    defectName?: string | null
    defectCategory?: string | null
    defectReworkable?: boolean | null
    defectMachine?: string | null
    currentQty: number
    currentRw: number
    currentNg: number
    currentReplacement?: number
    requestedQty: number
    requestedRw: number
    requestedNg: number
    requestedReplacement?: number
    operationCode?: string | null
    reason: string
    status?: string
    resolvedById?: number | null
    resolutionNote?: string | null
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type OperationDefectEditRequestUpdateWithoutOperationDefectInput = {
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operation?: OperationUpdateOneRequiredWithoutEditRequestsNestedInput
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutEditRequestsNestedInput
    requestedBy?: UserUpdateOneRequiredWithoutRequestedEditRequestsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedEditRequestsNestedInput
  }

  export type OperationDefectEditRequestUncheckedUpdateWithoutOperationDefectInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationId?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationDefectEditRequestUncheckedUpdateManyWithoutOperationDefectInput = {
    id?: IntFieldUpdateOperationsInput | number
    operationId?: IntFieldUpdateOperationsInput | number
    productionOrderId?: IntFieldUpdateOperationsInput | number
    requestedById?: IntFieldUpdateOperationsInput | number
    requestType?: StringFieldUpdateOperationsInput | string
    defectId?: NullableIntFieldUpdateOperationsInput | number | null
    defectName?: NullableStringFieldUpdateOperationsInput | string | null
    defectCategory?: NullableStringFieldUpdateOperationsInput | string | null
    defectReworkable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    defectMachine?: NullableStringFieldUpdateOperationsInput | string | null
    currentQty?: IntFieldUpdateOperationsInput | number
    currentRw?: IntFieldUpdateOperationsInput | number
    currentNg?: IntFieldUpdateOperationsInput | number
    currentReplacement?: IntFieldUpdateOperationsInput | number
    requestedQty?: IntFieldUpdateOperationsInput | number
    requestedRw?: IntFieldUpdateOperationsInput | number
    requestedNg?: IntFieldUpdateOperationsInput | number
    requestedReplacement?: IntFieldUpdateOperationsInput | number
    operationCode?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableIntFieldUpdateOperationsInput | number | null
    resolutionNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductionOrderCountOutputTypeDefaultArgs instead
     */
    export type ProductionOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductionOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationCountOutputTypeDefaultArgs instead
     */
    export type OperationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MasterDefectCountOutputTypeDefaultArgs instead
     */
    export type MasterDefectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MasterDefectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationDefectCountOutputTypeDefaultArgs instead
     */
    export type OperationDefectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationDefectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductionOrderDefaultArgs instead
     */
    export type ProductionOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductionOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationDefaultArgs instead
     */
    export type OperationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MasterDefectDefaultArgs instead
     */
    export type MasterDefectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MasterDefectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StandardCostDefaultArgs instead
     */
    export type StandardCostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StandardCostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationDefectDefaultArgs instead
     */
    export type OperationDefectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationDefectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationDefectEditRequestDefaultArgs instead
     */
    export type OperationDefectEditRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationDefectEditRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationStepDefaultArgs instead
     */
    export type OperationStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationLineDefaultArgs instead
     */
    export type OperationLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationLineDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}